# 一个实际的schedule函数  

该部分看参考Linux内核完全注释相关内容  

* struct task_struct ** p;  //任务结构指针的指针  
* linux0.11中把PCB做成了一个数组

下图是调度程序的主要部分(完整代码查看源码)  

核心目标是找到一个next并switch_to(next)

* 调度函数中定义了   struct task_struct ** p;  //任务结构指针的指针   
* while循环条件表示   从任务数组的最后一个任务开始循环处理   
* 循环体中，根据 * p->state 是否是TASK_RUNNING(就绪态)(因为处于阻塞态的也放在这个数组里)，是就绪态并且 * p->counter(任务运行时间的递减滴答计数)值，哪一个值大，运行时间还不长，next就指向哪个任务号(所以c设置了初始值为-1)  并且更新c  
* 经过这样循环一遍,就求出了 具有最大时间片的就绪态进程  (**典型的优先级方法**)  

* 下面代码while循环中少了一部分就是会跳过不含任务的数组槽  



* if(c) break;   分三种情况
* 如果上面至少含有一个就绪态任务并且它的counter大于0,这里的c就不会为1，break循环然后去执行switch_to();
* 如果c为0，说明上面的就绪态任务的counter都为0，即所有进程的时间片都用完了，**说明当前就绪态任务都执行了"很多次"了**,  这个时候是不是该考虑下阻塞态程序了因为待会阻塞态变成就绪态就应该快点被执行；  因此，会执行下面的for循环内容**：即根据每个任务的优先级权值，更新**每一个任务的counter值**，**然后重新回到最外层c = -1位置开始选择**; 具体更新方式是：counter = counter / 2 + priority
    * 注意这里更新的是每一个任务包括了阻塞和就绪态  
    * 就绪态的counter为0，除以2还是0，再加上对应的优先级(也就是它们counter的初始值)
    * 阻塞态的counter除以2以后，再加上初值，将来如果阻塞态的进程变成了就绪态，它的counter一定比就绪态大 (就绪态是恢复成原来的值，阻塞态是加上了原来值)

    * 也就是说发现当前任务数组中就绪态的任务时间片都用完了，说明都同样执行了有一段时间了，这时候重新置他们的counter为初始值，同时阻塞态的counter稍微变小点(右移一位运算比较快？是为了控制下不至于counter太大？ 因为都除以2不会改变他们之间的大小关系)然后再加上他们的初始值，这样下次再进行判断时如果有阻塞态任务就绪，就会被优先执行(动态改变了优先级)，如果没有阻塞态任务就绪,就绪态任务还是按counter选就好，这个时候counter是他们的优先级初值  

* 如果c = -1，这种情况说明里面的while循环没起作用也就是没有任何一个任务处于就绪态，那么他就break，执行switch_to(next),由于next初始值是0，所以会执行任务0，此时任务0仅仅执行pause()，这是一个系统调用，它又会调用本函数,下面是这个系统调用函数

```cpp
int sys_pause(void) 
{
    current->state = TASK_INTERRUPTIBLE;
    schedule();
    return 0;
}
```
![image](https://user-images.githubusercontent.com/58176267/158792254-8ac482bb-b973-41c0-98c4-110d9914686c.png)  


## counter的两个作用  

### counter的作用 ： 时间片  

既然是时间片，在时钟中断中就应该对其进行修改

![image](https://user-images.githubusercontent.com/58176267/158817867-e167cc56-1547-4c40-b44f-329d61437a8c.png)

每次时钟中断时对当前任务的counter减一，并判断减1后其counter是否大于0，如果大于0就返回，如果等于0了就是当前任务时间片用完了，就执行调度函数  

这是典型的时间片轮转 

### counter的作用 ： 优先级  

* 在调度函数中会寻找counter最大的进程，所以其承担着优先级的作用，且counter代表的优先级可以动态调整  
* 阻塞的进程再就绪以后优先级高于非阻塞的进程(上面说了)
* IO进程进入阻塞态后，其IO时间越长，经过上面c = 0的情况的可能性越大，它的counter会慢慢变高

![image](https://user-images.githubusercontent.com/58176267/158818972-10b94960-7201-4780-af42-dad708ad64df.png)


 
## 总结  

* counter保证了响应时间的界 （靠时间片轮转）  
* 经过IO的进程counter就会变大；且IO时间越长counter会越大，照顾了IO进程，变相的**照顾了前台进程(IO约束型进程)**
    * 如果有进程的counter在不断的变大，还能保证响应时间吗，是可以的:
    * 因为一个进程最长的时间片的情况：c(0) = p, c(t) = c(t-1)/2 + p, c(1) = p + p/2  c(2) = p + p/2 + p/4......  所以c(无穷大)收敛，<= 2p,也就是时间片最长也就是2p(这是一直阻塞的情况)，因此一个进程，它的时间片最大是2p，这个2p就保证了响应时间有界性    一个进程被执行的时间不会无法保证有界  
    * 这里除以3除以4也可以，但是做成减法就不收敛了，如果不收敛某个进程的时间片最大的情况可能是无穷大，则无法保证响应时间的界  

* **后台进程**一直按照counter轮转，**近似了SJF调度**，不断的轮转，短作业的进程会先“完事”  
     * 也就是这里的短作业优先的体现，不是简单通过让执行时间短的先执行？因为我们也不知道谁会执行的长谁会执行的短？ **而通过时间片不断乱转，间接的就会让短作业先执行完**

* 每个进程**只维护一个counter变量，简单、高效**

 
