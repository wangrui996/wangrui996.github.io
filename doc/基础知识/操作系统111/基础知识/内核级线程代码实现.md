# 内核级线程代码实现  

**补充知识**  

CPU的 **ESP** 寄存器存放 **当前线程的栈顶指针**  
**EBP** 寄存器中保存 **当前线程的栈底指针**  
**EIP** 寄存器存放 **下一个CPU指令存放的内存地址** ，**当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行**。  

  
## switch_to  

在linux 0.11中没有用内核栈(kernal stack)实现，而是用的TSS(task struct segment 任务结构段)，也就是段任务切换  

* 这里的TR是CPU固有的寄存器，相当于存储着任务信息的地址  
* 当需要进程核心级线程切换时,将TR指向第二个线程描述符(GDT表中)  
* 根据TR的值, 通过GDT表中拿到新的任务(线程段)的信息，这个**新的任务的信息包括CPU所有寄存器的信息**   

![image](https://user-images.githubusercontent.com/58176267/157384443-e7ec0b59-a307-4917-a548-cc56895b9030.png)  

上面的过程的解释：  
ljmp长跳转指令 ：   
* 先将当前CPU的所有寄存器放在当前TR指向的段中(它指向的段是通过查GDT表找到的)(现在的TR还代表当前执行的任务信息)  
* 因为调度算法得到了下一个任务选择子n并传入了switch_to     根据TSS(n)找到新的段
* 将新的任务段中信息赋值给CPU各寄存器  
* 上面CPU寄存器包括了栈寄存器ESP，栈也会切换过来  与TCB配合**栈**方式的相比多拷贝了很多寄存器内容(在一条长跳转指令中)  


**所以上述方法也能实现内核级线程五段论的过程，其中核心代码是int、switch_to函数中的ljmp、iret   操作系统核心的地方在linux0.11中就是包含了他们的总共几十行代码   

将上面的过程修改为基于栈的方式切换代码量也不会太多重要的是细节的处理  


## ThreadCreate  

理解了线程的切换，创建一个线程就是把它变成可以切换的样子，如果是上面的tss方式，重点是把TSS做好  

做好TSS，首先要有PCB（线程控制块）  

![image](https://user-images.githubusercontent.com/58176267/157389539-6bd33506-d7bb-4924-b94d-311aaafeb7e1.png)


* 1._sys_fork函数中，有个_copy_process  也就是父进程(创建新的进程的那个进程)在创建子进程时，先要在内核栈压入很多内容，主要是父进程在用户态执行时的"样子"，这些内容要传递给子进程，通过_copy_process   

* 2. 图中代码_copy_process函数的参数都没有值，因为_sys_fork函数是一段汇编代码，在里面调用了C函数，那么这个C函数的所有参数完全取自栈，而要取的这些参数实际上已经在栈中了(1中解释过)  
* 3. C函数的参数中，最后面的参数来自栈底，也就是函数参数从栈中取参数时是，栈顶参数先给第一个参数，依次赋值  
* 4.上图代码中，在栈中EFLAGS下面的ret=??1  代表的是，int 0x80 执行完之后的地址(因为创建进程时，int 0x80一执行，就会把SS,SP,EFLAGS,ret等压入了栈)  


## copy_process细节 ： 创建栈  

linux0.11中只有进程没有线程，且切换是利用的TSS，因此下面代码是这样的  

![image](https://user-images.githubusercontent.com/58176267/157392289-c94f2382-325e-447b-b207-8b3cb14fa396.png)


* 1. 申请内存空间  get_free_page()
    * 在系统初始化时有个mem_map，将内存分成了4k为一页，get_free_page()就是找到空闲的页  (这里不能用malloc以为这是用户态代码)  
    * 将申请得到的地址返回并做了强制类型转换，**这段内存作为PCB  因为linux 0.11没有线程只有进程，所以这里说是PCB，不然理解起来会有点乱**  
* 2. 创建TSS  创建内核栈和用户栈并与TSS关联(TSS中有这两个内容)
    * esp0:内核栈   PAGE_SIZE + (long) p  4k加上刚才申请内存的起始地址 这样作为核心栈的栈顶
    * ss0 赋为0x10也就是在PCB申请的内存起始地址偏移16字节以后，作为核心栈的栈底
    * 也就是说实际上 get_free_page()申请的内存一部分做了PCB(task_struct)，一部分做了内核栈  
    * ss、esp:用户栈  其中的ss和esp参数看前面 ThreadCreate部分代码，是从栈中取出的参数，也就是用的父进程在执行int 0x80时用到的用户栈(ss, esp),即使用了和父进程相同的用户栈  
* 3.**右边的五个步骤是创建核心级线程的关键，因为linux0.11只有进程，与核心级线程的步骤基本一致，不同点在于黑色的填写两个stsck，因为讲核心级线程时填写这两个栈的目的是把eip压入栈？，而这里是依靠TSS做的**

* 4.设置tss的eip，eip也是栈中取出的，是父进程在执行完int 0x80后压入的，压入的就是父进程执行完int 0x80后的那条指令的地址  
* 5.设置cs  等其他寄存器
 
* 即使没有创建成功


![image](https://user-images.githubusercontent.com/58176267/157394639-59cd4b61-f33a-47a1-9e31-3eeebec9ad45.png)


## 特别注意 

**父进程执行fork就会执行上面创建过程去创建子进程，fork执行完后，假设fork中做了某件事导致状态变成阻塞态————>会调用schedule————>就要进行switch_to，就会切到子进程，怎么切的，上面switch_to函数中提到了，通过将刚才初始化好的子进程的TSS中各寄存器的值赋值给真实的物理寄存器，这里面包括eip(而eip是父进程调用INT 0x80之后的那条指令，在子进程初始化时给了子进程的TTS中的eip)，这里将子进程TSS中的eip给物理寄存器eip后，子进程一开始执行的就是父进程INT 0x80后面的那句话也就是mov res, %eax  会将eax给res作为返回值————>那此时eas值是多少呢？ 看上面创建子进程的代码中将子进程的TSS中eax置为了0！ 

因为父进程如果创建成功子进程，它继续执行INT 0x80后面的代码，也是将eax给res返回，但此时eax的值不为0(具体可看下源码)

**所以，在调用fork时经常有一句话 if(!fork()) {} 这里，如果是父进程回来，if判断条件是不为真的，子进程回来的话，这里条件为真，所以如果是子进程返回的话，让子进程执行{}内代码;**



## 创建好一个线程如何执行我们想要的代码  

![image](https://user-images.githubusercontent.com/58176267/157405260-c7f8eb58-6130-46b2-af8e-c8f348c451b8.png)
![image](https://user-images.githubusercontent.com/58176267/157405697-bcf37b78-dcb2-4d17-8c6d-d8f3f3a1e48d.png)
![image](https://user-images.githubusercontent.com/58176267/157435181-49b524a3-f290-40ea-b2dd-cd425727e725.png)


* 1.如shell循环等待用户输入到终端的指令cmd，一旦输入后会创建子进程从而执行exec(cmd)，而exec是一个系统调用    这里注意：子进程进入sys_execve，将来再从内核态返回后，子进程就要执行新的代码，如cmd是ls，那么就是执行ls的入口代码  

* 2.在进入sys_execve之前，父进程和子进程执行同样的代码，通过exec中的系统调用进入内核态，在中断返回的时候要执行ls的代码，中断返回时，要执行iret，而iret的工作原理就是从栈中去取出那**5个内容**(ret返回地址实际上是 寄存器eip和CS，EFLAGS，SS，SP)，那么**既然我们想让系统调用sys_execve执行完后，中断返回指令iret执行后去执行ls(或其他指令代码段)，就需要在iret前把ls的入口地址给栈中保存的eip(后面PC就是eip即ls的入口)**
* 3.sys_execve函数 : 会执行_do_execve,在执行它执行将eax压入栈，eax = esp(此时栈顶)+一个偏移0x1C(28，esp+28正好是在eip那个位置)，相当于将栈中eip的地址传入了sys_execve  

* 4.do_execve函数： 将ls的入口地址置给eip   代码中eip[3]实际上栈ESP，因为28位置处，ret实际上是两个，CS : eip，所以eip[0] 是eip的地址，eip[1]是CS的地址，eip[2]是EFLAGS, eip[3]是ESP  因为要执行ls代码了，iret返回前除了修改好eip外，还需要将栈也切换，因此eip[3] = p p是从change_ldt()函数获取的    那么ls的入口地址即ax.a_entry是从哪来的，像ls，hello等是个可执行文件，可执行程序存在于磁盘中，从磁盘中读进来时，会有个文件头，其中就有a_entry(其在编译链接时将源文件编译链接成可执行文件后，将入口地址写了进去)





## 总结　　
应该理解好一个完成的过程  因为前面讲的代码发生的前后顺序并不是按记录的顺序而是先讲的核心级线程(或者进程)的切换，再将的创建进程   

下面这个图理解好  
![image](https://user-images.githubusercontent.com/58176267/157409701-2c595094-6682-4a5e-814a-13101df64ed4.png)





