# 用户级线程  


## 线程的引入  

**进程 = 资源 + 指令执行序列**  

其中**资源表示映射表(内存资源)**，那么多进程切换时，能否只切换指令序列变换，而资源不变换？  
* 将资源和指令执行分来  
* 一个资源+多个指令执行序列  

### 线程  

在一个资源下，启动了多个轻巧的指令序列，这个指令序列可以来回切，而且切换的时候只切换指令序列不需要动资源，既然也是指令序列在来回切，而且和进程不同(不需要特别复杂)，就叫**线程**

* **保留了并发的优点，避免了进程切换代价**  
* 进程的切换可以分成两部分，指令切换+映射表切换(内存管理部分)  
* 线程的切换可以只关注指令的切换  

![image](https://user-images.githubusercontent.com/58176267/156487067-cb07e0f7-bbcd-4587-8a2d-9dcce081df1a.png)


#### 线程的价值 即 多个指令序列 + 一个地址空间是否实用  

* 一个网页浏览器  
    * 一个线程用来从服务器接收数据  
    * 一个线程用来显示图片  
    * 一个线程用来出来图片(如解压缩)  
    * 一个线程用来显示图片  

* 上面这些如果变成顺序执行，就需要先下载数据，等所有数据下载完，再调用另外一段程序来显示文本，执行完以后，再调用另外一段程序显示图片  
* 因此这些**线程需要共享资源**
    * 接收数据放在内存100处，需要显示时从该处读  
    * 所有的文本、图片都显示在一个屏幕上  
* 合理的顺序是：启动一段程序，接收数据，启动一段程序显示文本，另一段程序显示图片，这些程序序列交替执行  
* 这样的例子为什么不是**进程**是而叫**线程**：因为指令序列1需要从服务器拿到数据放在缓冲区, 另一个指令序列需要从缓冲区拿数据来显示，如果两个指令序列用的不是同一个映射，就需要从放数据的缓冲区拷贝数据到自己读数据的缓冲区太费劲，本身就需要共享缓冲区，共享资源，没必要分开  


### 怎么实现线程  

注意：只是同时让两个指令序列开始执行不叫并发，还需要两指令序列交替执行  

![image](https://user-images.githubusercontent.com/58176267/156489305-3418c7b4-7bbc-4503-b48d-301da8181ca9.png)


上面的例子中，create函数，就能让他们同时出发  
Yield函数，能让他们交替执行,程序A执行过程中通过Yield函数切出去  

* 核心是Yield
* 能切换就知道**切换时需要是什么样子**  
* Create就是要制造出**第一次切换时应该的样子**

### 两个执行序列(线程)与一个栈的问题  

两段执行序列，第一段执行序列执行100处A函数，然后调用B函数(需要将返回地址104压栈，执行完B就知道再从104地址开始执行)，执行B函数时通过Yiled()函数切换到另一个指令序列执行(本质也是一个函数，也要压栈)；  Yiled函数找到另一段指令执行序列的地址300并修改PC指针跳转到300处，执行C函数，C函数调用D函数(压入304)，D函数调用Yiled函数切回第一个指令序列(压入404)，Yiled()函数找到204地址，继续执行B函数  

但是接着执行B函数发现函数结束(遇到}，需要出栈)，结果弹出的地址是404，但是我们执行完B函数需要的是回到A函数中也就是104位置，所以这里发生了错乱，**原因就在于两个指令序列用了一个栈**  

![image](https://user-images.githubusercontent.com/58176267/156490334-c90353dc-56fd-43e6-8463-83d71ede5dd3.png)

### TCB + 栈实现 线程切换——Yiled函数  

TCB是一个全局的数据结构，存放栈指针  
**esp：物理寄存器，CPU中的寄存器，所以切换栈实际上就是修改这个寄存器的值**

如下面示例中，线程1的TCB1存放的是1000，表示线程1用的是1000这个地方的栈; 线程2用的是2000地方的栈，因此TCB2.esp = 2000  

在Yiled切换线程时，如从线程2切换到线程1，首先要将当前栈记录进TCB2.esp,即TCB2.esp = esp(因为现在执行的是线程2，它内部的函数调用等，返回地址都被压入了栈，而栈地址被保存在CPU寄存器esp中),然后找到TCB1.esp给当前esp，再跳转到线程1刚才切换到线程2的地方，也就是204处；

![image](https://user-images.githubusercontent.com/58176267/156496526-bc6d0875-c276-46a2-8d3f-18ce58d9c033.png)

#### 还有个问题

当线程2的Yield执行后，跳到了线程1的204位置，遇到}括号，弹栈(esp = 1000处的栈)，此时弹出的是204，然后又执行204，有点小问题； **仔细分析发现，是线程1的B函数在调用Yiled函数时，将204压栈的；** A函数调用B函数，将104压栈，什么时候弹出来的，是B函数执行完成后弹出的104； 而204是在Yiled执行时压入的，所以Yiled执行结束返回的时候应该弹出204；但是上面的例子中B中调用的Yiled是在D中再调用Yiled时返回的(返回到204)，**但是D中的Yiled最后 jmp 204回直接跳到204，函数最后的花括号永远不会被执行，也就不会导致204被弹栈**  

#### 解决  

**去掉Yiled函数中的jmp 204;**,在函数D的Yiled函数中，已经设置了esp = TCB1.esp,而没有了jmp，遇到花括号后，一个函数结束就会从栈中弹栈找到应该返回到哪里执行，此时弹出的正好就是204;  
**因此，Yiled只需要切换栈即可实现线程的切换，不需要修改PC，为什么呢因为想要切换到的目标线程中某个地址已经被压入栈了**

所以 **TCB + 栈 实现线程切换**

### ThreadCreate
两个线程的样子 ： 两个TCB、两个栈、切换的PC在栈中  

**ThreadCreate**的**核心就是用程序做出这三样东西**    

![image](https://user-images.githubusercontent.com/58176267/156498918-ffaf1de2-a3a3-4ff0-8c3f-94b21abe60d8.png)


* 1，申请一段内存作为TCB  
* 2.申请一段内存作为栈  
* 3.将要执行的线程的起始地址放入栈中  
* 4，将栈和TCB关联  tcb.esp = stack;

这样，当切换时(执行Yield时)，首先找到TCB1，将TCB1.esp赋给物理寄存器esp，Yiled函数的结束处右大括号处，就会弹栈，将100弹出执行；


## 总结  

1.ThreadCreate函数分别创建不同的线程，要为每个线程申请TCB，申请栈，将这个线程首先要执行的函数地址func压入栈，关联TCB与栈，这样在Yiled函数调用时，如果根据线程调度函数选出了一个线程X要执行，从TCBx.esp赋值给esp后，出栈的就是线程X首先要执行的那个函数(因为刚创建这个线程的时候只将最先要执行的函数地址压栈了)  

2.程序执行过程中，调用Yiled()函数，就会首先切换栈(修改了物理寄存器的esp),然后遇到Yiled的右大括号，就会弹栈，此时就会切换到另外一个线程执行；  

![image](https://user-images.githubusercontent.com/58176267/156499995-95e23fb8-e964-4522-9711-c7656a251a7b.png)

3.关于什么时候调用Yiled，用户级线程，是用户自己设计的，比如在GetFDate函数从服务器下载到文本时，调用Yield()；
  Yiled内会有个Next函数进行线程调度，如可以优先将显示线程的TCB中的esp、赋给真实esp


4.**问题引入**  

引出**核心级线程**  

为什么说上面的线程是用户级线程：因为Yiled是用户程序，它的执行不需要到内核中，线程在用户态交替执行  
* 当执行GetData时(线程1)，会需要操作网卡，这是内核态才能做的事(要访问硬件必须要通过操作系统)，这时候进入内核态，由于网卡IO比较慢，进程1阻塞，这时候内核就要切到别的进程，但内核是不知道其他线程如show的，它只能切换到别的进程，这个时候**浏览器就什么也不会显示**

![image](https://user-images.githubusercontent.com/58176267/156567236-0a0eeb65-6c6f-4492-936d-c30ef47df432.png)

