# CPU调度策略  


## 调度的基本想法  

1.FIFO  
* 简单有效   但是短作业是不是可以适当优先

2.Priority  

* 短任务适当优先，但任务占用的资源越来越多怎么办，可能需要再适当降低它的优先级

![image](https://user-images.githubusercontent.com/58176267/158096929-0810ffee-f66e-4676-86ec-24e107947e0c.png)


## 调度算法的评价指标  

* 尽快结束任务 ： 周转时间(从任务开始到结束)短
* 用户操作响应快 ： 响应时间(从操作发生到响应)短  
* 系统内耗时间少 ： 吞吐量(完成的任务量)  

**问题**  

* 吞吐量和响应是按有矛盾  
  * 响应时间小————>切换次数多————>系统内耗大————>吞吐量小  
* 前台任务和后台任务的关注点不同  
  * 前台任务关注响应时间  后台任务关注周转时间    响应时间小就要进程的切换次数多，但切换也是需要时间的，比如TSS，LDT(内存映射表)，栈等要切换，这都是系统内耗，切换频繁了系统内耗就大，吞吐量就小(实际给用户干活的时间少了)  
* IO约束型任务(如含read的)和CPU约束型任务(如gcc编译程序时)有各自的特点   
*    
**因此，调度系统需要做到折中，平衡，综合考虑，同时调度算法如果特别复杂会让操作系统变得复杂，内耗可能变大， 但有效的系统需要高效，需要调度算法尽量简单**    

IO约束型进程优先级高点，这样IO就能先执行起来，然后切换到CPU约束型任务执行，两者就能并行起来  

IO约束型任务往往对应的就是前台任务(和用户进行交互的)，前台任务优先级高一点，后台任务用户相对不是那么关心  


## 常见的调度算法  


1 FCFS （First Come First Served）   

假设所有进程都在就绪态等待，下面例子，每一个进程的周转时间分别为 10 39 42 49 61  所以平均周转时间是相加除以5
将其中一个短作业提前后，会发现平均周转时间变短，因此这种先来先服务的简单策略不实用，因此**主要看下面的调度策略**  

![image](https://user-images.githubusercontent.com/58176267/158099624-1162bd02-7e03-4b98-9171-8c5040e770a2.png)


## 重点

2 SJF : 短作业优先  

**可以证明，将短作业放前面，平均周转时间最短，因此这可以在后面的调度策略中融合进去**      

![image](https://user-images.githubusercontent.com/58176267/158100150-3825d024-ea59-46b4-90f1-b9cbe2a11d35.png)


3.响应时间方面  

单纯按照上面的短作业优先，无法保证响应时间，如P2表示用户某个操作，从0时刻开始的，等到前面四个进程响应完才到P2，P2等待时间太长，当然，如果换谁在后面，响应时间也太长；  

因此，可**按时间片轮转调度**


![image](https://user-images.githubusercontent.com/58176267/158102590-529be997-cab8-4663-86de-28b2ab4ef236.png)  



4 响应时间和周转时间同时存在  

如 word很关心响应时间(用户输入一个字符希望很快看到它在屏幕上显示)，而gcc更关心周转时间，两类任务同时存在  


直观想法：定义前台任务和后台任务两个队列，前台RR，后台SJF，各自类型的任务按各自调度算法来(前台任务使用时间片轮转调度保证响应时间，后台任务采用短作业优先保证周转时间)，但是前台任务和后台任务之间怎么选，要引入**优先级调度*，如前台任务优先级高，前台任务没有时才调度后台任务**  

**问题**： 

* **如果优先级调度的优先级是绝对的，可能会造成某些进程饥饿，比如上面的方式中，如果一直有前台任务，由于前台任务一直存在，导致后台任务得不到执行**

所以，任务的优先级应该动态调整？  
* 后台任务优先级动态升高，但后台任务(采用SJF调度)一旦执行，前台的响应时间无法保证  **因为后台任务通常是CPU占用很长的任务，而后台任务按照SJF调度所以一个进程完成后才会执行别的进程，导致CPU很长时间内不被释放，响应时间就无法保证**
* 为了保证前台任务的响应时间，后台任务也不能一直执行，优先级可以提高上来被执行，但执行一段时间后应该释放CPU，所以考虑后台任务也有时间片 也就是所有的任务都用时间片， **但对于后台任务而言，单纯使用时间片，会导致其退化成轮转调度，没有发挥SJF，而且这样的话，前后台任务都是用轮转调度，优先级的概念也弱化了   


所以，既要以**轮转调度为核心** (总有前台任务，要保证其响应时间)，又要在此基础上增加**优先级**，优先级不仅需要考虑前台任务先做，也要考虑短作业优先  


## 其余问题  

* 怎么知道哪些是前台任务哪些是后台任务，fork时也没有这个参数  
    * 可能要求调度算法有一定学习能力，根据任务的变化自己能调整  
* gcc也不是一点不需要交互   word也可能执行一段批处理  此时它们属于什么任务？ 也就是不能一概而论
* Ctrl+C     Ctrl+F  按键是怎么工作的  
* SJF的短作业优先如何体现   如何判断作业的长度？  

 





