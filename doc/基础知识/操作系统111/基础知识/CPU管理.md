# CPU管理  

**操作系统在管理CPU的过程中，引出了多进程"图像"**  

## CPU工作原理  

**取指——译码(解释指令)——执行**  

* CPU上电后，根据PC指针的值，从内存中**取指**  如PC = 50  内存中50的指令是mov ax, [100] 通过总线将此指令传给CPU  
* 只要有一个初始PC，后面PC会自动累加

## 管理CPU  

基于上面CPU的工作原理，最直观的管理CPU的方式就是**设置好PC的初值**  

## 问题  

IO操作的时间基本上大于计算指令的时间 (IO操作要访问磁盘，驱动磁臂，涉及到机械设备，CPU计算则完全是在电路上工作)  
**一个例子：** 内存中按地址前后顺序，如果先存在很多条计算指令，再有一条IO指令，然后又有很多计算指令，PC初值在计算的第一条指令，PC是不能跳过IO指令的因为后面的计算指令很可能依赖这条IO指令的结果。 如果按照上面管理CPU的方式(只设置好PC初值)，产生的想象就是，工作了一段时间，停一段时间(执行IO指令)，又继续工作一段时间，因为IO操作非常耗时，因此前面很多的计算指令加起来时间可能和一条IO指令差不多，这样CPU的利用率可能只有50%，当IO指令比例较高时，高到计算指令相对于IO操作耗费的时间几乎可以忽略，这样CPU利用率几乎是0，绝大多数时间都在等待IO  

## 并发————多道程序 交替执行  

一个CPU上交替的执行多个程序：**并发** 
管理好CPU(让CPU比较忙碌)的方式————并发（同时 出发 交替执行）

![image](https://user-images.githubusercontent.com/58176267/155948787-348f41a8-7668-40d2-a2f6-659827435c0c.png)


## 并发的实现  

* 执行任务A的时候在适当的时机切换PC的值去执行任务B，执行到一定程序再修改PC的值去执行任务A，  但是只需要这样修改PC的值就可以了吗，不可以   
* **需要一个存放信息的结构PCB**————**记录信息** : 包括**切出去的时候程序A执行到了哪些，执行的样子**，只有这样将来回来时才能继续执行  

## 进程概念的引入

**所以一个静态的程序(在内存中)和正在运行的程序的不同是需要记录当前正在运行时的"样子" ，怎么描述这种不一样？**    

运行的程序，正在进行中程序————**进程**  

* 进程是有开始、有结束、程序没有  
* 进程会走走停停，这对程序来说没有意义  
* 进程需要一个结构记录运行时的“样子”，程序不需要  


## 总结  

操作系统要使用CPU(给一段程序，CPU去取值执行，就开始工作了)————>只是一个程序一个程序顺序执行，利用率太低————>CPU交替的执行多道程序/并发，以提高CPU利用率————>为了实现能够交替的执行多道程序，为了实现切来切去，需要数据结构去对这样执行起来的程序进行记录————>这样的话执行起来的程序和静态的程序就不一样了，用进程来描述正在执行的程序  

**怎么管理好CPU，操作系统需要启动多个进程，CPU去运行多个进程，即多个进程运行的样子就是管理CPU的核心**



