# 操作系统内存管理  


## 地址空间 & 地址生成  
物理地址与逻辑地址的映射  

cpu执行某个程序的过程（怎样根据程序中的逻辑地址，拿到它对应的物理地址—）



##  内存碎片  

**外部碎片**：在分配单元间的未使用的内存  
**内存碎片**：在分配单元内的未使用的内存  

## 简单内存管理方法/连续内存分配（简单！意味着操作系统实际用的要更复杂）    
**场景**    
* 当一个程序准许运行在内存中时，分配一个连续的区间  
* 分配一个连续的内存区间给运行的程序以访问数据  

### 分配策略  
* 首次适配  
* 最优适配  
* 最差适配  

#### 首次适配算法/第一匹配分配  
为了分配n字节，使用第一个可用的空闲块以致块的尺寸比n大  

**基本原理&实现*  

**需求**  
* 按地址排序的空闲块的列表  
* 分配需要寻找一个合适的分区  
* 重分配需要检查，看是否自由分区能合并于相邻的空闲分区（如果有的话）  

**优势**  
* 简单  
* 易于产生更大空闲块（如果前面已经找到合适的空闲块，就不需要破坏后面可能存在的更大的空闲块）

**劣势**  
* 容易产生外部碎片  第一次找到一个空闲块，并没有全部利用，下一次可能找到的是下一个空闲块，因为上一个空间可能不够了  
* 不确定性


#### 最优适配  
* 为了分配n个字节，使用最小的可用空闲块，以致块的尺寸比n大  

**基本原理&实现**  

* 为了避免分割大空闲块
* 为了最小化外部碎片产生的尺寸  

**需求**  
* 按尺寸排列的空闲块列表（最好是能按照空闲块的大小排序）  
* 分配需要寻找一个合适的分区
* 重分配需要搜索及合并于相邻的空闲分区（如果有的话） 

**优势**  
* 当大部分分配是小尺寸时非常有效（避免大的空闲块被拆分）  
* 比较简单  

**劣势**  
* 外部碎片：每次都找最小的适合的内存块，这些内存块被使用一部分后剩下的空间就很小了，这部分外部碎片再被利用的可能性很小，所以可能出现很好小的碎片   
* 重分配慢  
* 易产生很多没用的微小碎片  

#### 最差适配  
* 为了分配n个字节，使用最大的可用空闲块，以致块的尺寸比n大  
目的：为了避免有太多微小的碎片  
特点是将大块给拆分了，尽可能的保留的小的块（可以认为是好处也可以认为是坏处）  

**基本原理&实现**  

**需求**  
* 按尺寸排列的空闲块列表
* 分配很快（获得最大的分区）  
* 重分配需要合并相邻的空闲分区（如果有的话），然后调整空闲块列表（按size排序）  

**优势**  
* 加入分配是中等尺寸效果最好  

**劣势**  
* 重分配慢  
* 外部碎片  
* 易于破碎大的空闲块以致大分区无法被分配  


## 连续内存分配：压缩式与交换式子碎片整理  

### 压缩式碎片整理  
将程序在内存块中的位置重置，达到将碎片压缩出来一个大的空闲块的目的  
* 重置程序以合并孔洞  
* 要求所有程序是动态可重置的  
但是
* 何时重置？程序运行过程中去重置？程序停止的时候？  
* 开销：如果频繁的去执行重置，需要在内存中频繁的执行拷贝操作，开销较大  

### 交换碎片整理  
* 运行程序需要更多的内存  
* 抢占等待的程序 & 回收它们的内存  

例如p1，p2，p4三个程序在等待执行，p3程序运行需要更多的内存，这时假设p4在等待某个事件需要很长的时间，可以将其从menmory主存移刀硬盘上（数据并未丢失），让p3可以正常执行， 但一旦p4又需要执行，这时可能还需要再"挪"，或者这时p3已经不需要这么多内存了，将p4再从硬盘拷回到主存。  

**问题**  
* 选择哪种程序用于交换（换出去）  
* 什么时候需要换出，换入操作  
* 换入、换出是以单个程序为主体的，如果程序比较大，换入换出的开销也比较大  


## 非连续内存分配  

**场景**

* 分段（Segmentation）  
* 分页（Paging)  
* 页表（Page Table）  


### 1.连续内存分配的缺点  
* 分配给一个程序的物理内存是连续的  
* 内存利用率低  
* 有外部片、内碎片的问题  

### 2.非连续内存分配的优点  
* 一个程序的物理地址空间是非连续的  
* 更好的内存利用和管理  
* 允许共享代码与数据（共享库等）  
* 支持动态加载和动态链接  

**缺点**  
* 如何建立虚拟地址和物理地址之间的转换？  
    * 软件方案（开销可能很大）
    * 硬件方案
* 两种硬件方案  
    * 分段
    * 分页  

### 分段管理机制  
* 程序的分段地址空间   
* 分段寻址方案  
更好的分离和共享  
利用程序执行的特点：程序有主程序、子程序、链接库等不同的段，数据也有不同的分段如堆区、栈区等  

#### 逻辑地址空间分散到多个物理地址空间  
逻辑地址空间虽然是连续的（**虚拟地址**），但是通过分段以后将其有效的隔离起来，如堆、栈等都放到不同的物理地址空间，其他的如程序数据、程序段（又可以分成用户代码和库）等都分离出来。  
**好处**：代码段之间可以共享；数据之间隔离后，有些数据只读，有些可以读写  

#### 分段寻址方案  
涉及到地址怎样表示的问题  

**段访问机制**  
* 一个段：一个内存"块"  
      * 一个逻辑地址空间  

##### 段寄存器+地址寄存器实现方案  
程序访问内存地址需要：  
* 一个2维的二元数组（s， addr） （x86的方式）    
      * s：段号  
      * addr：段内的偏移  
#### 单地址实现方案  
把一个逻辑地址分成两部分：s和addr在同一地址中保存，上半部分是段号，下半部分是段内的偏移    

#### 硬件实现方案  
操作系统建立段表  （看B站操作系统课程4.1图）  

### 分页管理机制  

[分页](https://wangchangchung.github.io/2017/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%88%86%E9%A1%B5-%E4%B8%80/)  
绝大多数cpu采用的是分页机制？  
**页号+页内偏移**

**分页与分段的区别：** 分段中段的大小可变，分页中页的大小是固定不变  

* 划分物理内存至固定大小的帧
      * 大小是2的幂，e.g. 512,4096,8192;  
* 划分逻辑地址空间至大小相同的页  
      * 大小是2的幂，e.g. 512,4096,8192;
* 建立转换关系（逻辑地址转换为物理地址 pages to frame）  
      * 页表
      * MMU/TLB(块表：完成对页表的缓存)  
      
 #### 页帧（Frame）  
 
* 物理内存被分割为大小相等的帧  


      


  




























