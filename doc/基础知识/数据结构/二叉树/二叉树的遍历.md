# 二叉树的遍历  

* 1.前序遍历  
* 2.中序遍历  
* 3.后序遍历  

 

## 前序遍历   

**算法流程：**  
若二叉树为空，则空操作  
若二叉树非空  
    * 访问**根节点**  
    * 前序遍历**左子树**    
    * 前序遍历**右子树**  

实现：  
基于BinaryList上实现  

   

## 中序遍历  

## 后序遍历  

* 若二叉树中各结点的值均不相同，则二叉树结点的三种遍历都是唯一的  
* 由二叉树的**前序遍历和中序遍历** ，或由二叉树的**后序遍历和中序遍历**都可以确定唯一的一颗二叉树  

## 遍历算法总结  
* 如果去掉输出语句，从**递归**角度蓝，三种算法实际上相同（**访问路径相同**），但**访问结点的时机不同**
    * 第一次经过时访问——前序遍历  
    * 第二次经过时访问——中序遍历  
    * 第三次经过时访问——后序遍历  
* 时间复杂度：O(n)，每个结点要经过3次
* 空间复杂度：O(n),每经过一个结点但不访问它时，需要用栈记录它的数据等访问完后才出栈，最坏情况下，n个结点在单支的树中需要存储n个结点等回来时才访问，因此是O(n)  
