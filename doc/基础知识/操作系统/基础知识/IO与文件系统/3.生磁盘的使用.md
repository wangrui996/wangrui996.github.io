# 生磁盘的使用  

* 所谓生磁盘是指通过盘块号访问磁盘， 熟磁盘是指通过文件访问磁盘  

* [磁盘的结构——B站视频演示](https://www.bilibili.com/video/BV1ET4y1w7De?spm_id_from=333.337.search-card.all.click)
* [磁盘的结构——CSDN](https://blog.csdn.net/weixin_46946895/article/details/108978100)
![image](https://user-images.githubusercontent.com/58176267/169259005-6ed7267b-80f2-4f1c-ab89-a7d565962f14.png)
![image](https://user-images.githubusercontent.com/58176267/169259067-fcfe12a2-42f0-4673-a085-e43ecb22c322.png)

![image](https://user-images.githubusercontent.com/58176267/169246036-490265e1-92c5-4828-86a7-aa9efa90f488.png)

![image](https://user-images.githubusercontent.com/58176267/169246288-7eb9aed3-0707-4491-b490-dc07b557a865.png)


* 移动磁头移动到磁道上,转动磁道移动到目标扇区   通过磁生电或者电生磁实现和内存缓冲区实现信息的交互

![image](https://user-images.githubusercontent.com/58176267/169247057-c38d838c-3c3d-4604-93d4-beebaf39631f.png)



## 直接使用磁盘的方式  

* 盘面、柱面、磁头、扇区、缓存位置的概念  
* 同一个盘面上不同磁道的扇区所占面积不同，最外圈要大，但是通过控制记录数据的密度，最终所有扇区容量是一致的,如512byte，4K 
* 根据磁盘示意图,如果是多盘面的磁盘,每一个盘面上的0磁道会组成一个柱面，每一个扇面上的1磁道同样会组成一个柱面
* 访问磁盘时，首先需要寻道——确定cyl(柱面确定了实际上就是磁道号确定了)  其次确定是哪一个磁头即head  最后再确定是哪一个扇区 sector

* 最直接的使用磁盘的方式是将上面几个参数写到磁盘控制器上， 使用"out"指令————这是最后真正读写磁盘的操作  

![image](https://user-images.githubusercontent.com/58176267/169248272-5439e019-7a5c-4cc3-9005-a01576f4ccb5.png)


* 上述直接操作磁盘的方式太麻烦比如参数过多，操作系统进行抽象、封装  使用户使用磁盘变得简单(且高效)       复杂的东西可能不止抽象一层，这里也是的操作系统不止对磁盘做了一层抽象   

## 操作系统读写磁盘的第一层抽象————通过盘块号读写磁盘  

* 涉及到从一维地址到三维地址的编址过程   一个盘块号block————>三个参数  

![image](https://user-images.githubusercontent.com/58176267/169252223-683182e4-877c-438d-a89a-66c4bc1df1e6.png)

* 操作系统为了提高读写效率，使block相邻的盘块能快速读写，采用了图示的编址方式上
    * 因为实际使用时，某段时间内很可能是某个进程一直使用某一段连续的盘块号，而磁盘读写对速度影响最大的是寻道
* 编址方式确定后，就能根据盘块号得到C、H、S也可以根据C、H、S得到盘块号 
* 同时操作系统为进一步提高读写磁盘的效率扇区到盘块，将每一次读写的单位变大，上层用户发出的是盘块号，一个盘块号可以是连续的几个扇区
    * 这样操作会浪费一定的空间(有碎片)，因为即时只有很小一部分数据，一次也是读一个盘块(好几个扇区)的内容; 如图，每个扇区包含数据越大，每个盘块包含的扇区越多，实际上空间利用率越低，但是时间上会有提升; 由于机械硬盘容量在不断提升但是转速等没有本质提升，因此这里操作系统是采用空间换时间的做法  

 
![image](https://user-images.githubusercontent.com/58176267/169261721-0bd4cd4f-7dfd-4e38-a03b-5bb9c689eb6d.png)

* 以上是第一层抽象 通过这层抽象，可以直接通过盘块号读写磁盘，且每个盘块号对应的扇区数是已知的(**每个盘块号对应的扇区数是操作系统根据机械硬盘的参数设定的吗？**)
* 使用磁盘的方式：处理程序输出的block号  

* linux0.11代码中，sector扇区号等于盘块号右移一位得到的，因此一个盘块号对应两个扇区
    * 盘块号0———扇区0  盘块号1————扇区2  盘块号2————扇区4  盘块号3————扇区6   

![image](https://user-images.githubusercontent.com/58176267/169262924-45b77213-3c5f-411a-bbc4-2bc4ab21884d.png)


## 操作系统读写磁盘的第二层抽象————多进程通过队列使用磁盘  

![image](https://user-images.githubusercontent.com/58176267/169269345-e57f42b1-60e8-4d81-a726-6f826cda55ac.png)

### FCFS磁盘调度算法  

* 请求队列中相邻任务的盘块号相差较大，没有规律，导致磁头不断地在较大范围内移动，时间损耗太大

![image](https://user-images.githubusercontent.com/58176267/169432391-03978fbb-0c2f-45a2-9737-17b97510418a.png)

### SSTF磁盘调度 (Shortest-seek-time First, 短寻道优先)  

* 对于一些读写较频繁的程序，可能盘块号集中于中间的某个区域, 离当前局部比较远的一些请求，比如183号，可能磁头在一段时间内都不会移动过去(短寻道优先)  
* **SSTF存在饥饿问题**

![image](https://user-images.githubusercontent.com/58176267/169432900-29db974c-ee55-4630-8921-500b554b32fa.png)

### SCAN磁盘调度  

* SSTF＋中途不回折：每个请求都会有处理机会  
* 中间的相对还真是占便宜了因为从53扫描到0，再从0扫描到199，中间的一些请求会重复扫描到，而边缘的如65到199的只扫描了一次  
![image](https://user-images.githubusercontent.com/58176267/169433265-3d2aed9c-b92a-4c53-9569-f6b4038c0255.png)

### C-SCAN磁盘调度(电梯算法)

* 磁臂的复位是比较快的
* 与真实的电梯类似，比如从53楼降落到14后，有67，98，等请求，但是有个183请求，因此会直接到183，再回来的时候响应其他请求，而不是

### 多进程共同使用磁盘——第二层抽象总结  

* 核心是多进程通过电梯算法使用磁盘
* make_request这个函数：多进程访问磁盘时会产生请求，放到请求队列，然后在磁盘中断时从请求队列取出盘块号，换算成CHS，再通过out发给磁盘控制器
* 以上就是使用生磁盘的完整过程  


* 部分代码解释
    * static void make_request()函数   
        * ...req->sector=bh->b_blocknr<<1; //通过盘块号换算成扇区号
        * add_request(major+blk_dev, req); //加入到请求队列
    * add_request()函数
        * cli()； //关中断 对应的后面有sti()  中间的代码属于临界区,进行保护 
        * 中间这部分代码 实际上就是实现了**电梯队列**
        * req是当前请求，for循环从队列前到后遍历，直到到达满足某个条件的位置后退出，就是插入的位置 
        * IN_ORDER(tmp, req)  IN_ORDER(s1,s2) 实际上s1<s2实际上就是C1 < C2 因为扇区号中C起到决定作用
        
![image](https://user-images.githubusercontent.com/58176267/169492044-0efd355b-01e4-4262-818d-d25f34d023fa.png)
    


## 生磁盘(raw disk)的使用整理  

* 下面流程中(2)：用扇区号make_req(做出磁盘请求) 因为磁盘内容最重要读到内存中,实际这里还涉及到了内存缓冲区的申请、管理的代码(**该部分对磁盘读写的速度提升很大,很重要**) 
* 进程sleep_on：当前进程放出请求后，接下来的事情又硬件去做，进程睡眠 
* 磁盘中断处理：磁盘中断会处理请求，调用磁盘驱动程序(图上的磁盘驱动)，具体做的就是算出CHS，通过"out"发出指令，通过**DMA总线盗用技术**开始工作  
* 工作完成后磁盘中断，会结束该进程的请求，唤醒进程


![image](https://user-images.githubusercontent.com/58176267/169496117-54c15480-a0b1-4799-98fe-c396465e8dcf.png)







