

# 1.IO与显示器  

![image](https://user-images.githubusercontent.com/58176267/162975378-53bfcb02-cc30-4945-897b-752b67791d9e.png)


* 外设的工作实际上都是 向外设对应的设备控制器(显卡，网卡，磁盘控制器)中的寄存器或存储等写内容   设备控制器由寄存器中内容，实际驱动外设工作  

* CPU发出指令后，外设对应的控制器工作，CPU转而去处理其他进程，当外设工作完成后，向CPU发出中断

* 因此**使用外设的核心是： 向外设的控制器发送指令(查对应的手册)(类似 out xx, al 的指令), 外设工作完成会向CPU发送中断, CPU完成对应的中断处理程序**

![image](https://user-images.githubusercontent.com/58176267/162977692-a5d0b169-938f-401c-85cd-d6af811ac10d.png)

* 不同的外设，它的控制器不同，同一中外设不同公司，不同型号的设备也不同，因此，每种外设都要查寄存器地址，格式，语义等，如果让上层用户直接操作，非常麻烦; 因此，操作系统需要给上层提供一个简单视图————**文件视图**  
    * 比如，无论用什么显示器，向显示器上面打印都是prinf （当然c语言中的prinf不是系统调用）

![image](https://user-images.githubusercontent.com/58176267/162978136-0ea1270d-aaa9-4b8b-afa6-709c7e581fd3.png)


## 设备驱动的一般步骤   

* 1.形成文件视图
* 2.向设备控制器的寄存器发送指令  往往是 out xxx
* 3.进行设备中断的中断处理  


## 一段操纵外设的程序  

![image](https://user-images.githubusercontent.com/58176267/162981183-e03f704a-0a99-4160-9850-6051e2fd6d94.png)


![image](https://user-images.githubusercontent.com/58176267/162981704-25c05471-a529-4529-ab37-4786adc1ccbb.png)


## 显示器输出  

* printf展开后会先先创建缓存然后将格式化字符串输出到缓存，然后再write(1, buf,...) 
    * 原因在linux系统编程部分讲过，如果来一个字符就调用一次write，从用户态到内核态的开销比较大，最后总的开销就大  经过缓冲区缓存后，一次write可以不止写很多数据  当然，我们知道内核也会有一个缓冲区，缓冲区数据再外设输出 
    * 上面的1是设备描述符，1表示的是标准输出设备描述符 宏是STDOYT_FILENO 
* write 最后体现是 out xxx  只不过需要根据设备描述符，对write进行分支，决定out 到不同的地方  在这里就是out到一个显示器  


* write最终对应的系统调用是sys_write  其中参数中的buf和count就是缓冲区还有缓冲区大小 基本上所有write都是这样 
* 设备描述符fd为1 即为标准输出描述符  
* file = current->filp[fd]  通过标准输出描述符和进程PCB的filp 得到一个文件file  
* 获取文件的inode    inode = file->f_inode  


![image](https://user-images.githubusercontent.com/58176267/162984053-6e76f82f-1007-4137-a550-9b8f0c726bc4.png)

![image](https://user-images.githubusercontent.com/58176267/162985736-9da04853-aa7b-41b6-9f2a-52b25f67c642.png)  


## 文件描述符 1 (也就是标准输出设备描述符)是从哪里来的

* 进程的PCB中的filp数组，是创建进程(fork)时，copy_process(..){..}函数中，从父进程拷贝来的  因此和父进程是一样的   
* 前面说了进程的printf最后展开成了sys_write函数，直接就向1这个设备描述符写了，那这个设备是什么时候打开的呢？
* 往上追究，shell进程启动了whoami命令，shell是该进程的父进程   首先看0号进程的main函数 有个 if(!fork()) { init(); }  也就是1号进程执行init()函数 
* 1号进程执行init()函数，打开了“dev/tty0”,然后拷贝了两份(dup(0)，dup(0))，因此打开的那个文件描述符是0，之后的两份是1,2  所以write中文件描述符是1 对应的设备文件就是 "dev/tty0"  
* [关于 dup和dup2 一定要看](https://blog.csdn.net/silent123go/article/details/71108501)
* "dev/tty0" 就是终端设备  

![image](https://user-images.githubusercontent.com/58176267/162989661-e11ed0df-36f6-461a-ad8e-50a7f9336758.png)


## open系统调用做了什么   

* 对应了sys_open(..) 这个系统调用  
* 首先根据传递的文件名，











