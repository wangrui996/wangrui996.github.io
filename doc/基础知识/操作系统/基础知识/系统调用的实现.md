# 系统调用的实现  

看完这一部分，需要理解用户程序printf()是怎样最后到的操作系统内核的sys_write 

**操作系统在内存中执行，用户的应用程序也在内存中执行，当用户想访问操作系统提供的某个功能时，是不能直接跳到操作系统具有相应功能的那段内存中，如用jmp，mov，为什么？**  

## 原因  
 
**原因：将内核程序和用户程序隔离！**

不能随意调用操作系统数据，随意jmp，因为操作系统中保存着很多重要数据，如root密码，如果一个应用程序能随意访问操作系统中的数据，这个root密码就可能被获取

## 怎样实现  

**内核态和用户态**：一种处理器的“硬件设计”————特权环 ，**用户态**对应的是内存中的**用户段**， **内核态**对应的是内存中的**内核段**  
* 内核态可以访问任何数据，用户态不能访问内核数据
* 对于跳转指令也一样实现了隔离

由于CS:IP是当前指令，用CS最低两位来表示：0 是内核态  3是用户态

每一次访问时，要比较检查当前特权级CPL和目标特权级DPL，只有CPL<=DPL,这条指令才被允许（硬件检查）

* **在系统初始化时，head.s执行的时候，会针对内核态的代码和数据建立GDT表，其对应的GDT表的项的DPL就等于0**  
* **系统初始化完成后进入用户态后，当执行一个用户的main程序时，PC指向main函数，PC由CS和IP组成，此时CS表示main函数在内存中的区域，CS中的某部分就表示了它的特权级，其值为3；实际上是在初始化结束进入进入用户态（启动shell）前，将CS的CPL置为3**  

## 硬件提供了主动进入内核的方法————中断  

对于intel X86，就是中断指令int  

* int指令将使CS中的CPL改成0，“进入内核”  
* 这是用户程序发起的调用内核代码的唯一方式  

* 系统调用的核心：  
    * (1)**用户程序**中包含一段包含**int指令**的代码
        * 对于上层应用程序，需要有含中断的代码，由库函数来做 
    * (2)**操作系统**写**中断处理**，获取想调用程序的编号
    * (3)**操作系统**根据编号**执行相应代码**  

## 系统调用背后的故事——核心原理

**以open()函数为例：因为想要利用这个函数进入操作系统内核，因为上面的原因，它实际上要变成一段含有int的程序————>而要想实现，操作系统还必须提供对应的中断处理函数————>在中断处理函数中，根据是open还是read等，再跳到相应位置执行**  

**操作系统初始化时设定了，只能通过int 0x80 进入内核**

系统调用需要提供一种能够进入内核的手段  

## 用户态到内核态  

调用printf(...)/应用程序————>库函数printf(...)/库函数————>库函数write(...)————>系统调用write(...)/包含int的代码、在linux/include/unistd.h中

因为用户程序中调用printf(...)格式是里面包含了要打印的字符串等等，而write(...)需要好几个参数（源码在linux/lib/write.c）,所以C库函数需要做个转换；  
然后调用write(...)变成包含int 0x80的中断代码，既可以通过中断处理进入操作系统内核  

### write库函数，怎样实现的最后能进入对应的系统中断处理

实际上，系统调用的write含int 0x80，已经在库函数write中用到了宏定义并将一些参数传入了，如name 是 write，然后系统调用的write中，执行int 0x80时会有个传入参数，__NR_write也就是**系统调用号**, 被放在eax中，在linux/include/unistd.h中，__NR_write是一宏定义，值是4

或者说上面的write怎么转换成系统调用write(含int 0x8x)代码后，怎么进入的write这个中断处理，可看视频或linux源码

## **int 0x80到底做了什么  

因为**中断要去另外一个地方执行程序然后再回来，int 0x80 要取址执行，从IDT表取出中断处理函数去执行**  

在系统初始化时有个void sched_init(void){set_system_gate(0x80, &system_call);}  其中的set_system_gate(0x80, &system_call);就是用来设置0x80的中断处理，主要是生成那张IDT表，表中对应的DPL“故意置成了3”； 

![image](https://user-images.githubusercontent.com/58176267/155877918-c1831301-324b-4afe-b785-9c44300cd765.png)

 **所以用户程序执行时，最后展开成了含有int 0x80的代码，而这个中断去查IDT表取址执行的时候，DPL为3，此时CPL=DPL，就可以跳到80号中断，**   
 **跳到80号中断，要用上面的段选择符(设置成了8)和处理函数入口点偏移(system_call)去执行，两者合成设置为PC(CS为8，CS最后两位是CPL，为0，IP为system_call)，这里的8与前面的jmpi 0, 8一样，是需要到GDT表中查到项，找到内核对应的代码段，在操作系统代码段找到system_call代码段**  
 
 **在操作系统初始化时，故意将80号中断的DPL设置成3，从而使CPL为3的用户程序可以进入中断处理，在中断处理中根据段选择符中的8就将CPL设置为0了，到了内核，就可以做任何事了，中断在返回的时候会执行一段指令，将CS最后两位又变成3，即又回到用户态**  
 
 ## 中断处理程序 system_call做了什么  
 
 ![image](https://user-images.githubusercontent.com/58176267/155878740-3b8d2fab-b2a4-4561-ae88-d1b632f4aa3a.png)

 ![image](https://user-images.githubusercontent.com/58176267/155878909-9b7e6e26-024c-4251-9fa3-4dcc397d8e0c.png)

