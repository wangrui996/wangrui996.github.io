

# 死锁处理  


## 生产着消费者例子————死锁的一个例子  

下图是生产者消费者的例子  该程序为用户所写，很有可能将信号量顺序写反（红色部分顺序） 如下  

mutex信号量值为1  
假设empty一开始为0(缓冲区满了，初始值为缓冲区大小)

* 假如生产者申请 P(mutex),  mutex 变为0  
* 生产者P(empty), empty 减为-1  生产者阻塞  
* 消费者进程执行， P(mutex)  mutex变为-1 消费者阻塞
* 生产者想要被唤醒，需要有进程将empty释放（执行V（empty）），但是V(empty)只在消费者那  但消费者想执行V(empty),必须要进程释放mutex，mutex只有生产者先被唤醒才能释放 
* 此时如果再来一个进程，仍然P(mutex) 还会造成自己阻塞，且也死锁

* 这种多个进程由于**互相等待对方持有的资源**而造成谁都无法执行的情况叫**死锁**

![image](https://user-images.githubusercontent.com/58176267/161228049-f95b3a7d-292c-47cb-8fb4-900b48500f08.png)  


## 死锁的成因  

* 资源**互斥**使用，一旦占有别人无法使用  

![image](https://user-images.githubusercontent.com/58176267/161230595-6ea71d94-07ea-41b1-b5ec-212609afba4f.png)

## 死锁的4个必要条件  

* **互斥使用**
    * 资源的固有特性，如道口 
* **不可抢占**
    * 资源只能资源放弃，如车开走以后别的车才能申请使用
* 请求和保持
    * 进程必须占有资源，再去申请(保持住资源的情况下再去申请别的)
* 循环等待
    * 在资源分配图中存在一个环路 

## 死锁处理方法概述  

* 死锁预防
    * 破坏死锁出现的条件 （不让某个进程在保持占有某个资源的情况下再去申请其他资源）

* 死锁避免
    * 检测每个资源请求，如果造成死锁就拒绝

* 死锁检测 + 恢复
    * 检测到死锁出现时，让部分进程回滚，让出资源

* 死锁忽略


## 死锁预防的例子  

* 在进程执行前，**一次性申请所有需要的资源**，不会占有资源再去申请其它资源
    * 缺点1： 需要预知未来，编程困难
    * 缺点2： 许多资源分配后很长时间后才使用，资源利用率低

* 对资源类型进行排序，**资源申请必须按序进行，**不会出现环路等待
    * 缺点：仍然造成资源浪费 （比如10号资源已经能申请，但是按顺序申请，必须先“预定”7号资源，然后再申请10号进行工作，在用到7号资源之前，不能把它释放
   




    
    
    










