# 核心级线程  

[CS和IP寄存器](https://zhuge.blog.csdn.net/article/details/115979811?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_paycolumn_v3&utm_relevant_index=5)

* **内核级线程的ThreadCreate是系统调用，会进入内核，内核知道TCB  Yiled()用户不可见，调度点由系统决定**

* 进程只有内核级进程，因为进程要分配资源，要访问内存，可能还要访问文件等，必须要内核态才能控制这些资源
* 进程的切换实际上要理解好内核级线程的切换和资源的切换  

## 多核与多CPU的区别  

* 多CPU(处理器)：每个CPU有自己的一套缓存(Cache)，有自己的一套MMU(内存映射)
* 多核：多cpu用的是一套缓存和内存映射  **多个执行序列用一套映射，就是线程； 多个线程可以通过内核分配到不同的cpu核上，而且用的是同一套映射，所以多个线程只有到内核中去，才能充分的利用多个核** 
* 如果是用户级线程，操作系统是看不到的，无法为他们分配硬件
* 所谓充分发挥多核的特性，是让他们**并行**，其中其中执行的时候另一个也执行； 与**并发**的区别：**并发是同时出发，交替执行**



## 核心级线程  

* ThreadCreate是系统调用，内核管理TCB，内核负责切换线程

### 内核栈、TCB  

* 用户栈是否还要用？ 因为执行的代码仍然在用户态，还要进行函数调用，要有用户栈
* 也要在核心态跑，所以也要有核心栈  
* 内核级线程与用户级线程的本质区别：就是一个栈到一套栈，两个栈到两套栈  **用户级线程中两个线程需要两个栈，内核级线程中两个线程要两套栈**  

* **TCB应该关联一套栈，且在内核中，切换TCB时要切换两套栈，由一个内核栈切换到另一个内核栈，用户栈也跟着从一个用户栈切换到另一个用户栈**

### 用户栈和内核栈之间的关联  

什么时候会有内核栈，显然是进入内核的时候因为进入内核后也会有c语言函数调用； 那么什么时候会进入内核？，进入内核的唯一方法是 **中断**(可能是代码中int指令，或者是硬件如鼠标，时钟中断)  

* 一旦通过int指令进入内核，操作系统会通过一些硬件的寄存器找到这个线程对应的内核栈，还要压入一些东西包括在用户态执行的栈，和刚才的IP，CS(合成得到PC，记录用户态执行到什么地方了)

理解下图，就是在用户态进入内核态的时候(**发生中断的时候**)，**通过向内核栈**(操作系统根据计算机硬件寄存器找到的该线程对应的内核栈)**压入用户栈(栈顶和栈底地址)，用户态执行代码的偏移地址IP，段基址CS等(先拿到段基址再弹出偏移，就得到了PC执行)，实现了内核栈和用户栈的关联**，在IRET即中断返回时，弹出刚才的东西，就会回到用户态刚才执行的地方  

![image](https://user-images.githubusercontent.com/58176267/156908629-d784e69a-3017-483f-a535-75550148aba2.png)

![image](https://user-images.githubusercontent.com/58176267/156908864-c6d6cb13-bbf6-4452-aeba-eb0b8a9e9891.png)  

### 具体例子理解  

以上图为例：

* 1.**认真理解上图**：遇到int 0x80时需要找出内核栈，并把用户栈地址记录到里面，然后是304，CS是100(段基址)，后面就是中断响应函数system_call中，调用了sys_read，同时将1000压栈(内核栈)；
* 2.**中断返回的过程**：当sys_read()执行完成后，从内核栈弹出1000继续执行system_call，然后发现system_call完成，中断返回，弹出内核栈中的CS，再弹出偏移304，就能开始接着执行用户态程序，同时弹出了用户栈，接下来用户态程序执行也不会乱  
* 3.在内核中执行代码的时候, 要启动磁盘读(sys_read(){启动磁盘读； 将自己变成阻塞; 找到next; switch_to(cur, next);} ，其中cur表示当前线程的TCB，next表示下一个线程的TCB，就会切换到另外一个内核级线程； 
* 4.**switch_to:仍然是通过TCB找到内核栈指针(进程切换中switch_to中cur和next是当前和下一个进程的PCB)；然后通过ret切到另外一个内核程序；当切换到的内核程序执行到ret时；最后再用CS:IP切到用户程序**，如下图，所以右边的内核栈中，四个问号的地方是什么——应该是一段包含有iret(中断返回指令)的代码

![image](https://user-images.githubusercontent.com/58176267/156910830-4f93e2f8-0ef8-4b94-be98-9a825d121b24.png)

![image](https://user-images.githubusercontent.com/58176267/156910989-34317900-130d-48b7-866f-d4b3517b253d.png)


### 内核线程switch_to的五段论  

![image](https://user-images.githubusercontent.com/58176267/156911139-dfda141b-a73e-4b78-b106-c1e054b3df1c.png)


## ThreadCreate  

![image](https://user-images.githubusercontent.com/58176267/156911205-4110045b-a378-4cbd-879a-bf47243ef456.png)


其中填写两个栈的目的在于将EIP压入这两个栈？ 

CPU的 ESP 寄存器存放 当前线程的栈顶指针 ，

EBP 寄存器中保存 当前线程的栈底指针 。

CPU的 EIP 寄存器存放 下一个CPU指令存放的内存地址 ，当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行。

