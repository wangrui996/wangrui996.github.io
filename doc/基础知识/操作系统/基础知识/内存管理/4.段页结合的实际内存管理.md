

# 4.段页结合的实际内存管理

* 对于物理内存，分页(多级分页+快表)，有利于内存的空间利用
* 对于程序员，希望使用段，方便程序管理  

## 段页结合  

* 虚拟内存相当于一块地址空间  
* 应用程序的分段，并不从物理地址分割，而是在这块虚拟内存(一块地址空间)上分割  
* 虚拟内存里面的段，分割成固定大小的页，每一页映射到物理内存

![image](https://user-images.githubusercontent.com/58176267/161668186-49a4f06d-ad8f-4313-a15a-9a376270ce0c.png)

* 每一个应用程序都有一个0-4G内存空间，这个内存空间是虚拟内存  程序分段后放在不同位置  
* 段在逻辑上是连续序，但是操作系统会将每个段都打散成页，离散的映射到物理内存中

![image](https://user-images.githubusercontent.com/58176267/161668764-7b548a09-383d-4537-b38d-ef000b4bbcff.png)

## 段页同时存在的重定位(地址位置)  

* 1.用户(程序员)发出的地址还是  段号+偏移  CS:IP  (逻辑地址)  
* 2.根据段表和 CS表示的段号，找到基地址，再加上段内偏移得到一个虚拟地址 (如果只有分段，这就是物理地址) 
* 3.得到的虚拟内存分为页号和偏移，再经过映射，得到页框号后，再由偏移，最终得到物理地址  

![image](https://user-images.githubusercontent.com/58176267/161670330-7f13e512-2193-4900-a8d9-779ae697e58a.png)



## 一个实际的段、页式内存管理  

### 从fork中内存分配开始  到程序能使用内存  

![image](https://user-images.githubusercontent.com/58176267/161671173-dfc77611-c57d-4c23-80f5-c49352782d3a.png)

### 段、页式内存下程序如何载入内存  

**步骤**
* **1. 首先要在虚拟内存上分割出区域来分配给用户程序段，建立段表 (映射关系)**  
    * 怎么分割，虚拟内存也看成一段地址空间，使用分区适配算法(最佳适配、最差适配、首次适配等(内存管理第2小节内容))将虚拟内存分割，假装将程序段放到了虚拟内存
* 2.虚拟内存中的每一段，分页，每一页与物理内存一个页框关联; 完成虚拟内存到物理内存的映射

* **操作系统管理内存的核心就是： 1.程序能够载入物理内存  2.程序能够使用物理内存**

    * 例子：假设ds寄存器值为1 mov [300], 0  首先通过ds值和段表，查得基地址0x45000,再加上偏移300，得到虚拟内存中的地址0x00045300
    * 操作系统通过页表，将0x45300，映射到物理地址0x0007300
   
![image](https://user-images.githubusercontent.com/58176267/161679251-cdf09a8a-07a0-4c91-991b-05ad63ac0d61.png)

# 内存管理的代码实现  

## 从fork()开始  

* set_base（p->ldt[1], new_data_base）; // 设置基址 
    * p是pcb，将ldt[1]和ldt[2]表示代码段和数据段的基址都设置成new_data_base(64M * nr), 也就是都用一个段？, 其中nr是新进程在线性地址上的进程号  表示第几个进程，0号进程nr是0，一号进程nr是1
* **实际上，new_data_base就是虚拟内存的基址**，这64M空间用作ldt表？  图中1就是表示虚拟内存的分割，2就是段表的填写
* 进程切换时，PCB切换，ldt也切换  

![image](https://user-images.githubusercontent.com/58176267/161682440-30f4ba7b-1c33-4c84-a761-e0ef3a73d1e7.png)

## 进程的虚拟地址  

* 通过上面fork()中代码，每个进程的代码段和数据段都是一个段(这只是linux初始版本的一种分割方案)  
* 每个进程占64M虚拟地址空间，互不重叠  
* 每个进程的虚拟地址空间不重叠，接下来以虚拟地址为页号映射的物理地址，也不会出现重叠    这是一种简化处理操作，意味着后面页表不同进程也可以共用一套，因为不同进程页号也不会出现重叠
* 实际现在版本的linux中，每个进程会有自己的段和页表； 在linux0.11中用的这种简化的方案，因此进程切换时，会发现没有切换页表  
  
  
![image](https://user-images.githubusercontent.com/58176267/161682867-b1ffd8b0-abcc-45da-9cf1-6726fc191368.png)

##  分配内存、建页表  

* copy_page_tables(xxxx)  子进程和父进程共用一套页，如图中父进程用了三个页，子进程也是用那三个  
* 因此按理说应该分配物理内存建立页表，这里子进程不用再分配物理内存，因为父进程已经分配了，子进程和父进程共用  
* 但是**子进程需要建立页表**，因为需要完成自己这一部分虚拟内存到物理内存的映射，只不过建立也表示，只需要拷贝
    * copy_page_tables(xxxx) **传入参数就是父进程虚拟内存地址的起始old_data_base和结束位置new_data_base，然后建立映射**
        * form_dir = (unsigned long *) ((from>>20) & 0xffc);     // from>>20表示父进程起始虚拟地址

![image](https://user-images.githubusercontent.com/58176267/161690781-dba5df7a-103c-4cff-9e93-12281fd8dec0.png)



### frm_dir  to_dir  

from  32位虚拟地址，格式如图  
如果是 from>>22，得到的是页目录号，也就是对应的一个1K的页表，即4M的物理内存  但是为什么右移了20位  

* 结合上一节内容和下图，虚拟内存地址右移22位得到的是页目录号，每一个页目录号对应一个页目录，一个页目录是4个字节，所以这个页目录号再乘以4，就得到了目录项的起始地址  (如这个页目录表中，地址0-3的4字节是页目录号为0的，如果一个页目录号是1，则1 * 4得4，表示当前页目录号的起始地址是4)  所以from>>22 再乘4 也就是 from>>20 再将最低两位置为0 （from>>20）& 0xffc

![image](https://user-images.githubusercontent.com/58176267/161686464-9d6344f5-d621-406a-9a96-dcaf2a714e9b.png)















