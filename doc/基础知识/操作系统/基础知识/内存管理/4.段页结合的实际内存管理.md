

# 4.段页结合的实际内存管理

* 对于物理内存，分页(多级分页+快表)，有利于内存的空间利用
* 对于程序员，希望使用段，方便程序管理  

## 段页结合  

* 虚拟内存相当于一块地址空间  
* 应用程序的分段，并不从物理地址分割，而是在这块虚拟内存(一块地址空间)上分割  
* 虚拟内存里面的段，分割成固定大小的页，每一页映射到物理内存

![image](https://user-images.githubusercontent.com/58176267/161668186-49a4f06d-ad8f-4313-a15a-9a376270ce0c.png)

* 每一个应用程序都有一个0-4G内存空间，这个内存空间是虚拟内存  程序分段后放在不同位置  
* 段在逻辑上是连续序，但是操作系统会将每个段都打散成页，离散的映射到物理内存中

![image](https://user-images.githubusercontent.com/58176267/161668764-7b548a09-383d-4537-b38d-ef000b4bbcff.png)

## 段页同时存在的重定位(地址位置)  

* 1.用户(程序员)发出的地址还是  段号+偏移  CS:IP  (逻辑地址)  
* 2.根据段表和 CS表示的段号，找到基地址，再加上段内偏移得到一个虚拟地址 (如果只有分段，这就是物理地址) 
* 3.得到的虚拟内存分为页号和偏移，再经过映射，得到页框号后，再由偏移，最终得到物理地址  

![image](https://user-images.githubusercontent.com/58176267/161670330-7f13e512-2193-4900-a8d9-779ae697e58a.png)



## 一个实际的段、页式内存管理  

### 从fork中内存分配开始  到程序能使用内存  

![image](https://user-images.githubusercontent.com/58176267/161671173-dfc77611-c57d-4c23-80f5-c49352782d3a.png)

### 段、页式内存下程序如何载入内存  

**步骤**
* **1. 首先要在虚拟内存上分割出区域来分配给用户程序段，建立段表 (映射关系)**  
    * 怎么分割，虚拟内存也看成一段地址空间，使用分区适配算法(最佳适配、最差适配、首次适配等(内存管理第2小节内容))将虚拟内存分割，假装将程序段放到了虚拟内存
* 2.虚拟内存中的每一段，分页，每一页与物理内存一个页框关联; 完成虚拟内存到物理内存的映射

* **操作系统管理内存的核心就是： 1.程序能够载入物理内存  2.程序能够使用物理内存**

    * 例子：假设ds寄存器值为1 mov [300], 0  首先通过ds值和段表，查得基地址0x45000,再加上偏移300，得到虚拟内存中的地址0x00045300
    * 操作系统通过页表，将0x45300，映射到物理地址0x0007300
   
![image](https://user-images.githubusercontent.com/58176267/161679251-cdf09a8a-07a0-4c91-991b-05ad63ac0d61.png)

# 内存管理的代码实现  

## 从fork()开始  

* set_base（p->ldt[1], new_data_base）; // 设置基址 
    * p是pcb，将ldt[1]和ldt[2]代码段和数据段的即基址设置成new_data_base(64M * nr), 其中nr是新进程在线性地址上的进程号  表示第几个进程，0号进程nr是0，一号进程nr是1
* **实际上，new_data_base就是虚拟内存的基址**，这64M空间用作ldt表？  图中1就是表示虚拟内存的分割，2就是段表的填写
* 进程切换时，PCB切换，ldt也切换  

![image](https://user-images.githubusercontent.com/58176267/161682440-30f4ba7b-1c33-4c84-a761-e0ef3a73d1e7.png)





