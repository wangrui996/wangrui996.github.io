


# 5.内存的换入换出  

* 内存的换入换出是因为虚拟内存导致的  为什么要使用虚拟内存 因为要实现段页式，要借助虚拟内存(从虚拟内存中分割出一段一段，作为段，然后从段分割成一页一页，映射到物理内存页)  即虚拟内存是实现分段和分页的关键  

* 没有内存的换入换出，虚拟内存无法实现  

## 内存换入——请求调页  


* 32位机上，程序员眼中的内存，是0-4G的虚拟内存(地址空间)  这里是不管实际实际物理内存有多大，在程序员眼中的虚拟地址空间是0-4G； 含义就是有这些地址可供使用（一个内存单元是1字节，2^32个字节即4G）
* 在程序员使用这4G虚拟内存时，可以按代码段，数据段等进行分割使用，便于管理 
* 根据上节课的linux0.11的代码中，是64M虚拟内存？
* 虚拟内存到物理内存的映射对用户是透明的
* 操作系统的这种设计，给用户感觉上就像自己拥有一块4G大小的内存，可以随意使用(操作系统做了虚拟内存到物理内存的映射是用户能够随意使用4G大小虚拟内存的保障)  

![image](https://user-images.githubusercontent.com/58176267/161700435-6a91a1bd-ca28-4662-8cba-f3768b19c6e4.png)

![image](https://user-images.githubusercontent.com/58176267/161701092-9fdd3631-0cd1-489e-b758-bf69ebfc8ecb.png)

### 实际情况中的一个问题  

虚拟内存是4G，但是实际物理内存比它小，比如只有1G怎么办？  ——————用换入换出实现“大内存”  

* 如要使用虚拟内存中0-1G这部分，就将这一部分映射到实际物理内存1G中，如使用3-4G虚拟内存，就把这一部分映射到物理内存   即用的时候映射

## 换入的引出

* 假设用户代码0-4G，最开始存储在磁盘上(包括代码段数据段等)，现在要访问代码段，就把代码段对应的那一段从磁盘上**换入**内存，建立映射  
* 代码段程序突然跳到了数据段(假设在3-4G)，这一段现在还没映射到内存，但是要访问了，此时就要从磁盘中将那一段读入，建立映射，给用户的感觉是自己0-4G的内存都在使用
* 请求时才换入，然后建立映射

![image](https://user-images.githubusercontent.com/58176267/161703578-5deecdfc-dc5c-4603-b80c-2b4c0113d94d.png)

## 换入的实现————请求调页  

* 请求来了，如访问一个任意的逻辑地址，根据段号和段表，得到在虚拟内存中的基址，加上偏移，得到可能是0-4G中任意一个的虚拟地址(页号 偏移);
* 虚拟地址到物理地址映射，查页表，发现没有这一页的映射，即这一页没在内存中，缺页了，程序就不能继续执行了，需要操作系统做一部分工作后才能继续执行(调页)————MMU查页表发现缺页，将负责中断的寄存器其中一位，置为1，触发缺页中断 （CPU每执行完一条指令，都会去看是否有中断）————有缺页中断，就执行页错误处理程序  
* 页错误处理程序就要到磁盘找到缺的页(通过相应的数据结构和算法)，调入内存，前提是在内存中找到一个空闲页，把缺的那一页从磁盘读入空闲页，建立新的映射关系 退出中断，继续执行中断前指令，这里有点小细节就是刚才是碰到某条需要地址翻译的指令执行时MMU触发了中断，中断结束后应该从中断后的代码继续执行，这里需要硬件做点设计，如果是MMU发现是缺页造成的中断，让PC不动(不自动加1)，中断回来后，已经换入并建立好映射，这条指令就可以执行  

















