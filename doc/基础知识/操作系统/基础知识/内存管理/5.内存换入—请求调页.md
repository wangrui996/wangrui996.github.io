


# 5.内存的换入换出  

* 内存的换入换出是因为虚拟内存导致的  为什么要使用虚拟内存 因为要实现段页式，要借助虚拟内存(从虚拟内存中分割出一段一段，作为段，然后从段分割成一页一页，映射到物理内存页)  即虚拟内存是实现分段和分页的关键  

* 没有内存的换入换出，虚拟内存无法实现  

# 内存换入(Swap in)——请求调页  


* 32位机上，程序员眼中的内存，是0-4G的虚拟内存(地址空间)  这里是不管实际实际物理内存有多大，在程序员眼中的虚拟地址空间是0-4G； 含义就是有这些地址可供使用（一个内存单元是1字节，2^32个字节即4G）
* 在程序员使用这4G虚拟内存时，可以按代码段，数据段等进行分割使用，便于管理 
* 根据上节课的linux0.11的代码中，是64M虚拟内存？
* 虚拟内存到物理内存的映射对用户是透明的
* 操作系统的这种设计，给用户感觉上就像自己拥有一块4G大小的内存，可以随意使用(操作系统做了虚拟内存到物理内存的映射是用户能够随意使用4G大小虚拟内存的保障)  

![image](https://user-images.githubusercontent.com/58176267/161700435-6a91a1bd-ca28-4662-8cba-f3768b19c6e4.png)

![image](https://user-images.githubusercontent.com/58176267/161701092-9fdd3631-0cd1-489e-b758-bf69ebfc8ecb.png)

### 实际情况中的一个问题  

虚拟内存是4G，但是实际物理内存比它小，比如只有1G怎么办？  ——————用换入换出实现“大内存”  

* 如要使用虚拟内存中0-1G这部分，就将这一部分映射到实际物理内存1G中，如使用3-4G虚拟内存，就把这一部分映射到物理内存   即用的时候映射

## 换入的引出

* 假设用户代码0-4G，最开始存储在磁盘上(包括代码段数据段等)，现在要访问代码段，就把代码段对应的那一段从磁盘上**换入**内存，建立映射  
* 代码段程序突然跳到了数据段(假设在3-4G)，这一段现在还没映射到内存，但是要访问了，此时就要从磁盘中将那一段读入，建立映射，给用户的感觉是自己0-4G的内存都在使用
* 请求时才换入，然后建立映射

![image](https://user-images.githubusercontent.com/58176267/161703578-5deecdfc-dc5c-4603-b80c-2b4c0113d94d.png)

## 换入的实现————请求调页  

* 请求来了，如访问一个任意的逻辑地址，根据段号和段表，得到在虚拟内存中的基址，加上偏移，得到可能是0-4G中任意一个的虚拟地址(页号 偏移);
* 虚拟地址到物理地址映射，查页表，发现没有这一页的映射，即这一页没在内存中，缺页了，程序就不能继续执行了，需要操作系统做一部分工作后才能继续执行(调页)————MMU查页表发现缺页，将负责中断的寄存器其中一位，置为1，触发缺页中断 （CPU每执行完一条指令，都会去看是否有中断）————有缺页中断，就执行页错误处理程序  
* 页错误处理程序就要到磁盘找到缺的页(通过相应的数据结构和算法)，调入内存，前提是在内存中找到一个空闲页，把缺的那一页从磁盘读入空闲页，建立新的映射关系 退出中断，继续执行中断前指令，这里有点小细节就是刚才是碰到某条需要地址翻译的指令执行时MMU触发了中断，中断结束后应该从中断后的代码继续执行，这里需要硬件做点设计，如果是MMU发现是缺页造成的中断，让PC不动(不自动加1)，中断回来后，已经换入并建立好映射，这条指令就可以执行  

![image](https://user-images.githubusercontent.com/58176267/161706858-a7f4b7ee-f7af-4206-96a4-9c55e0246e3b.png)

* 下面这个题选C？ 因为请求调段效率会比请求调页低？

![image](https://user-images.githubusercontent.com/58176267/161706994-81b3ba88-f726-4153-ad73-50b965ce30dd.png)



## 请求调页的代码实现  

* MMU查页表发现缺页时，会触发中断，这是由硬件做点的，程序可能控制的是缺页中断的处理  
    
* 缺页中断的中断号时14，因此初始化时需要设置好，谁负责14号中断的处理  

```c
void tarp_init(void)
{set_trap_gate(14, &page_fault);//设置14号中断的处理 由page_fault处理}  
```
```c
# define set_trap_gate(n, addr) 
    _set_gate(&idt[n], 15, 0, addr);  //设置中断向量表，将14号中断设置为由addr处理  
```

![image](https://user-images.githubusercontent.com/58176267/161707758-4aa3b6d9-6025-47ca-aaf5-bfde004490b1.png)

### page fault 处理中断

* 将一堆数据压栈保存现场，要到内核态
* mov1 %cr2, %edx   页错误线性地址，放在了cr2寄存器  (前面已经把虚拟地址赋值给edx，现在给cr2)  
* push1 %eax  汇编中将一些值压栈，有可能是后面准备调用C函数，压栈是为了给C函数传参  call _ do_ no_page  这里将缺页的地址传入告诉c函数哪个地方缺页了  

![image](https://user-images.githubusercontent.com/58176267/161710008-ecac3d50-2220-420f-bb6d-ae47a86effad.png)
 

#### _do_no_page  

参数中address就是缺页的虚拟地址，它对应的虚拟页不在内存中，因此该函数，就是将磁盘，申请空闲页，建立映射  

* 1. address& = 0xfffff000; //页面地址 最后3位置0，表示把页内偏移去掉 得到的是虚拟页号    
* 2. page = get_free_page(); //申请物理内存空闲页 即申请了内存中一页的空间
* 3. bread_page(page, current->executable->i_dev, nr); //读磁盘中的一页到page   current->executable表示当前进程对应的可执行文件
* 4. put_page(page, address); // 物理页和虚拟地址建立映射  即填写页表   
* 

![image](https://user-images.githubusercontent.com/58176267/161711677-72ddc67b-6687-4011-8d1f-a031e2b05454.png)

#### put_page  修改页表  

* 根据页目录项找到页表，将物理页放在页表中  

![image](https://user-images.githubusercontent.com/58176267/161712181-9e16c681-d63d-45c0-bf09-fd10a1642d5f.png)



# 内存的换出(Swap out)  

* 内存换入中，从磁盘读内容之前，有个申请新的内存页的操作 page = get_free_page();  但并不是总有空闲页(内存是有限的)  
* 因此，需要有一个算法，选择将哪一页从内存中换出到磁盘，这个算法就应该在 get_free_page() 中  

![image](https://user-images.githubusercontent.com/58176267/161713058-2c77b193-db62-4145-8d84-10a230612832.png)


## FIFO页面置换  

* 可以发现，D请求时没有，将A换出，紧接着A又来了，把B换出  会发现A刚被换出又换入，比较频繁，影响效率













