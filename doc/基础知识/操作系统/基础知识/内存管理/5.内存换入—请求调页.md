


# 5.内存的换入换出  

* 内存的换入换出是因为虚拟内存导致的  为什么要使用虚拟内存 因为要实现段页式，要借助虚拟内存(从虚拟内存中分割出一段一段，作为段，然后从段分割成一页一页，映射到物理内存页)  即虚拟内存是实现分段和分页的关键  

* 没有内存的换入换出，虚拟内存无法实现  

# 内存换入(Swap in)——请求调页  


* 32位机上，程序员眼中的内存，是0-4G的虚拟内存(地址空间)  这里是不管实际实际物理内存有多大，在程序员眼中的虚拟地址空间是0-4G； 含义就是有这些地址可供使用（一个内存单元是1字节，2^32个字节即4G）
* 在程序员使用这4G虚拟内存时，可以按代码段，数据段等进行分割使用，便于管理 
* 根据上节课的linux0.11的代码中，是64M虚拟内存？
* 虚拟内存到物理内存的映射对用户是透明的
* 操作系统的这种设计，给用户感觉上就像自己拥有一块4G大小的内存，可以随意使用(操作系统做了虚拟内存到物理内存的映射是用户能够随意使用4G大小虚拟内存的保障)  

![image](https://user-images.githubusercontent.com/58176267/161700435-6a91a1bd-ca28-4662-8cba-f3768b19c6e4.png)

![image](https://user-images.githubusercontent.com/58176267/161701092-9fdd3631-0cd1-489e-b758-bf69ebfc8ecb.png)

### 实际情况中的一个问题  

虚拟内存是4G，但是实际物理内存比它小，比如只有1G怎么办？  ——————用换入换出实现“大内存”  

* 如要使用虚拟内存中0-1G这部分，就将这一部分映射到实际物理内存1G中，如使用3-4G虚拟内存，就把这一部分映射到物理内存   即用的时候映射

## 换入的引出

* 假设用户代码0-4G，最开始存储在磁盘上(包括代码段数据段等)，现在要访问代码段，就把代码段对应的那一段从磁盘上**换入**内存，建立映射  
* 代码段程序突然跳到了数据段(假设在3-4G)，这一段现在还没映射到内存，但是要访问了，此时就要从磁盘中将那一段读入，建立映射，给用户的感觉是自己0-4G的内存都在使用
* 请求时才换入，然后建立映射

![image](https://user-images.githubusercontent.com/58176267/161703578-5deecdfc-dc5c-4603-b80c-2b4c0113d94d.png)

## 换入的实现————请求调页  

* 请求来了，如访问一个任意的逻辑地址，根据段号和段表，得到在虚拟内存中的基址，加上偏移，得到可能是0-4G中任意一个的虚拟地址(页号 偏移);
* 虚拟地址到物理地址映射，查页表，发现没有这一页的映射，即这一页没在内存中，缺页了，程序就不能继续执行了，需要操作系统做一部分工作后才能继续执行(调页)————MMU查页表发现缺页，将负责中断的寄存器其中一位，置为1，触发缺页中断 （CPU每执行完一条指令，都会去看是否有中断）————有缺页中断，就执行页错误处理程序  
* 页错误处理程序就要到磁盘找到缺的页(通过相应的数据结构和算法)，调入内存，前提是在内存中找到一个空闲页，把缺的那一页从磁盘读入空闲页，建立新的映射关系 退出中断，继续执行中断前指令，这里有点小细节就是刚才是碰到某条需要地址翻译的指令执行时MMU触发了中断，中断结束后应该从中断后的代码继续执行，这里需要硬件做点设计，如果是MMU发现是缺页造成的中断，让PC不动(不自动加1)，中断回来后，已经换入并建立好映射，这条指令就可以执行  

![image](https://user-images.githubusercontent.com/58176267/161706858-a7f4b7ee-f7af-4206-96a4-9c55e0246e3b.png)

* 下面这个题选C？ 因为请求调段效率会比请求调页低？

![image](https://user-images.githubusercontent.com/58176267/161706994-81b3ba88-f726-4153-ad73-50b965ce30dd.png)



## 请求调页的代码实现  

* MMU查页表发现缺页时，会触发中断，这是由硬件做点的，程序可能控制的是缺页中断的处理  
    
* 缺页中断的中断号时14，因此初始化时需要设置好，谁负责14号中断的处理  

```c
void tarp_init(void)
{set_trap_gate(14, &page_fault);//设置14号中断的处理 由page_fault处理}  
```
```c
# define set_trap_gate(n, addr) 
    _set_gate(&idt[n], 15, 0, addr);  //设置中断向量表，将14号中断设置为由addr处理  
```

![image](https://user-images.githubusercontent.com/58176267/161707758-4aa3b6d9-6025-47ca-aaf5-bfde004490b1.png)

### page fault 处理中断

* 将一堆数据压栈保存现场，要到内核态
* mov1 %cr2, %edx   页错误线性地址，放在了cr2寄存器  (前面已经把虚拟地址赋值给edx，现在给cr2)  
* push1 %eax  汇编中将一些值压栈，有可能是后面准备调用C函数，压栈是为了给C函数传参  call _ do_ no_page  这里将缺页的地址传入告诉c函数哪个地方缺页了  

![image](https://user-images.githubusercontent.com/58176267/161710008-ecac3d50-2220-420f-bb6d-ae47a86effad.png)
 

#### _do_no_page  

参数中address就是缺页的虚拟地址，它对应的虚拟页不在内存中，因此该函数，就是将磁盘，申请空闲页，建立映射  

* 1. address& = 0xfffff000; //页面地址 最后3位置0，表示把页内偏移去掉 得到的是虚拟页号    
* 2. page = get_free_page(); //申请物理内存空闲页 即申请了内存中一页的空间
* 3. bread_page(page, current->executable->i_dev, nr); //读磁盘中的一页到page   current->executable表示当前进程对应的可执行文件
* 4. put_page(page, address); // 物理页和虚拟地址建立映射  即填写页表   
* 

![image](https://user-images.githubusercontent.com/58176267/161711677-72ddc67b-6687-4011-8d1f-a031e2b05454.png)

#### put_page  修改页表  

* 根据页目录项找到页表，将物理页放在页表中  

![image](https://user-images.githubusercontent.com/58176267/161712181-9e16c681-d63d-45c0-bf09-fd10a1642d5f.png)



# 内存的换出(Swap out)  

* 内存换入中，从磁盘读内容之前，有个申请新的内存页的操作 page = get_free_page();  但并不是总有空闲页(内存是有限的)  
* 因此，需要有一个算法，选择将哪一页从内存中换出到磁盘，这个算法就应该在 get_free_page() 中  

![image](https://user-images.githubusercontent.com/58176267/161713058-2c77b193-db62-4145-8d84-10a230612832.png)


## FIFO页面置换  

* 可以发现，D请求时没有，将A换出，紧接着A又来了，把B换出  会发现A刚被换出又换入，比较频繁，影响效率

![image](https://user-images.githubusercontent.com/58176267/161722421-d43bb2f9-ee09-4f91-b83f-078f210405d2.png)


## MIN页面置换  

![image](https://user-images.githubusercontent.com/58176267/161722156-879f6823-ac3b-41b5-b8ca-f387aa71db89.png)


## LRU页面置换  

* 过去预测未来  利用程序的局部性原理  未来如果可能用第7页，那么最近一段时间第7页也会很可能被使用，因此最近这一段时间没有使用的页，预测它在未来一段时间也不会使用，就把它换出  
* LRU即 选择最近最少使用的页  

![image](https://user-images.githubusercontent.com/58176267/161723518-57ee7710-a1b6-440e-b835-081f3092e53b.png)


## LRU的实现  

### 利用时间戳实现的LRU  

* 这种实现，每一次MMU查页表(每一次访问内存地址)时，也就是每执行一条指令(都要进程地址翻译)，就要修改要访问的页的时间戳，需要先找到维护的这个时间戳表对应的页，然后修改它; 实际中，这个过程会非常耗时，且有可能会溢出

![image](https://user-images.githubusercontent.com/58176267/161725104-5971a6b5-7c11-4616-8806-66302c574519.png)

### 页面栈实现LRU  

* 栈顶总是保留最近使用的页，栈底是最近最少使用的
* 每次淘汰栈底的，也得修改多次栈指针，代价也不小  

![image](https://user-images.githubusercontent.com/58176267/161725799-827e074d-524b-4a2c-b90a-3d3cca1d7a5a.png)

**通过上面的模拟，实际操作系统中如果想准确实现LRU，开销也太大**  

## LRU的近似实现————Clock算法/二次机会算法  

* 近似实现而不是准确实现，准确实现是找最近一段时间最少使用的那个
* 每一个页添加一个引用位
* 每一次访问一页时，硬件自动设置该位(访问到置为1？)
* 选择淘汰页：扫描页的引用位， **是1时就清0(表示再给这个页一次机会)，并继续扫描； 是0就淘汰该页** 
    * 如果一个页扫描到的时候是1，然后把它置0，当下次再扫到它的时候，如果发现它还是0，表示这段时间它没有被访问到，就淘汰它
* **所以近似的核心是：当有换出需要时，不是选择的最近最少使用的页来淘汰，而是选择了一个最近没被使用的页换出**
* 它能做到**效率高的原因在于**：每次MMU访问页时，只需要修改这一个页的那个标志位，当有换出需求时再扫描，扫描找的还不是最少使用的，只要遇到个标志位是0的就淘汰它；
    * 而上面的算法，每一次访问页，即使不需要淘汰时，也要对维护的时间戳表或者栈进行维护 而且需要淘汰时，寻找需要换出的页开销也大  

![image](https://user-images.githubusercontent.com/58176267/161727566-4bcd96dc-638f-41f7-952a-96694abf3ebe.png)

## Clock算法的问题  

* 实际中，缺页通常很少发生； 因为程序有局部性  
* 很少会有页的标志位是0(可能大家在最近一段时间都被访问过，就都被置为1了)，缺页少，也就很少有机会去转动指针从而把1变为0
* 也就是说，缺页很少的情况下，1会很多，基本上没有0，甚至全是1没有0
* 当发生缺页时，需要转动指针，遇到1置为0，也就是都扫描一次，把所有1变为0，再转第二次时，才能碰到0，换出;
* 之后一段时间，由于还是上面的情况，这些页的R又变为1; 在下一次被换出去的，实际上就是刚才被换出去的下一个；
* **这样这个算法不就退化成了FIFO，失去了LRU的特性**  

* 问题在于是这种Clock算法是用最近没有使用来代替最近最少使用，维护了太长的历史信息，转的时间太长就没法表达最近，比如缺页很少的情况下，如果维护的信息太长，大家在这段时间都被使用过了(已经都被置为1了)，削弱了查找最近没有使用的特性  


## 改进的一个版本的的Clock算法————解决Clock算法退化问题  

* **解决：定时清除R位，比如R位间隔比较短的时间就清0**
* **用一个扫描起来快的扫描指针把1置为0   这样的话，最近的一段时间，如果一个页没被时间，它的R就是0; 慢的那个指针只在缺页时转动来找R等于0的页换出**
* **如果慢的扫描指针扫描到一个页发现它的R为0，就说明了它在从上次清0完以后这一段比较短的时间内没有被使用！**  

* Clock算法中，快指针需要定时的清除R位，因此要放在时钟中断中, 慢指针扫描动作是发生在缺页时调用  在page = get_free_page();？

![image](https://user-images.githubusercontent.com/58176267/161732661-f58ea4fb-34cb-4b04-bbb7-961f4a62a800.png)


## 解决一个额外的问题  

* 给一个进程分配多少页框(帧frame)   Clock算法要循环扫描
    * 多了的话虽然可能缺页问题解决的好，但内存总量是有限的，请求调页导致的内存高效利用就没有了  
    * 少了也不合适 

* 下图中，CPU利用率急速下降通常称为系统颠簸，本质原因是进程多了，每个进程分配的页少了，当缺页率达到一定程序，进程等待调页完成的时间多了，CPU利用率就降低了  

![image](https://user-images.githubusercontent.com/58176267/161741090-33f8bc40-8951-4676-ae14-849fc47c3a17.png)

 




 











