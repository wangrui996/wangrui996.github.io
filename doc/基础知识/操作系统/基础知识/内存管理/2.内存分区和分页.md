

# 2.内存分区和分页  


## 内存分区  

### 内存分区的引出  

* 计算机工作的核心是  程序放入内存，然后CPU从内存中取指执行   cpu取指的过程也是使用内存的过程  

* 程序分段处理，因为不同段有不同的特点，分段有利于分治管理
* 程序载入内存时会将不同段分别寻找内存中空闲位置，如代码段找到了以1000起始的一块内存空间  此时1000这个基址会记录到该进程PCB的LDT(局部描述符表)中  
* 假如代码段第一句指令是 jmp 40   执行时需要重定位(运行时重定位),  根据汇编知识 jmp 40 实际上时 0：40即段号0的基址偏移40  根据LDT表中0，拿到基址1000，然后加40，就会跳到物理地址的1040处执行
* 一个进程是这样，多进程之间，切换时会切换PCB，也就会修改物理寄存器ldtr，指向另外一个进程的LDT表，接下来查LDT就找这个(讲解多进程时，说进程切换时，除了栈等的切换，还会切换一张映射表，就是这个LDT表)  

* 程序被执行经历的过程：
    * 将程序分段(编译时做的)
    * 内存中找空闲的分区
    * 找到空闲分区后，将段读入到分区中(怎么读入的与磁盘管理文件，系统设备，驱动等相关，暂时不深究)，读的时候要把LDT表内容初始化好，将LDT与PCB关联
    * cpu对取指执行，这个过程需要重定位  

### 如何从内存中找到一块空闲的区域？  

也就是内存应该怎么切割？  

固定分区肯定不合适，直接把内存按找固定大小分好，不同程序在内存中占用的空间不同，这样可能一个很小的程序也会占用内存的一个分区，太浪费  

### 可变分区的管理————核心数据结构  

![image](https://user-images.githubusercontent.com/58176267/161493754-93730db0-2cde-4503-8598-7e0290acf5a0.png)

![image](https://user-images.githubusercontent.com/58176267/161494279-461d8256-9255-4641-8109-413b6ee662a9.png)

![image](https://user-images.githubusercontent.com/58176267/161494477-8a5ccbb8-15f0-4927-8e4d-0597822940a0.png)


**再次申请————适配算法**  

* 最佳适配： 每次都选与所需长度最接近的空闲分区，这样内存中会出现很多碎片  
* 最差适配： 每次都从最大的空闲分区里面割(割出来的相对均匀)  
* 首先设配： 均匀随机分布(速度快，不用看哪个是最大的哪个是最小的)  


** 有了内存的分区，再配合之前的内容，一个最小的操作系统基本就有了  

![image](https://user-images.githubusercontent.com/58176267/161496200-6578c9cb-218c-4b74-9a4f-36b1295c22c6.png)

实际物理内存的管理采用的分页，分段配合虚拟内存————段页制   


## 内存分页  

解决内存分区导致的内存效率问题  

可变分区造成的问题：  

* 内存在多次分配和释放的过程中可能造成较多内存碎片，导致新的内存请求到时，总的内存空间是够的但是找不到任何一段可用的空闲分区  
* 想解决这个问题，必须空闲分区合并，可能需要移动已分配的内存（带颜色的），而移动实际上是需要复制，并且段移动了，对应的LDT也要改动(移动完之前，因为不知道会将段移动到哪里，这个时候CPU不能执行它对应的指令)，这就可能造成上层用户感知到操作系统处于“死机”状态(可能是某个或者几个进程根本不执行了)  
   
![image](https://user-images.githubusercontent.com/58176267/161497881-7fce8a35-9d6b-499c-b310-be71bc835c5d.png)


### 内存分页  

* 将程序段等分成国歌页，将内存也等分成多个页(操作系统初始化时，就将物理内存等分成了多个页，看源码中初始化内存部分，mem_map，每4k对应map中一项，使用了就是1没有使用就是0)  
* 不需要进程内存紧缩，内存的浪费少，没有外部碎片  
* 从用户角度，希望是分段，因为编译器编译完程序是分成了多个段 
* 从物理内存角度是希望分页，可以最大化利用内存空间
* 所以操作系统应该既支持段，也支持页，这就是为什么操作系统采用段——页制的原因

![image](https://user-images.githubusercontent.com/58176267/161498977-5641a9cb-713f-4526-806b-8ea7ee1c9522.png)

### 内存分页后的重定位问题  

程序分段分页并放入内存后，遇到jmp 40 怎么重定位？  


* 假设一页长度是100(实际中是4k)，jmp 40 应该是第 0 页  根据汇编的基础知识jmp 40只修改IP，  假设当前段号是0，意思是跳到当前段0的偏移40处，如果按假设一页100的话，就是跳到第0页，假设段0第0页的页框是5，最终发出的物理地址应该是，540  
* 怎么完成上面这个计算————**页表**  

* 页表对应的寄存器是cr3(8086中？) 
* 指令中的地址 如 jmp 40中的 40， 要去页表中查， 首先计算出它对应的页号，然后根据页号找到它对应的页框号(已知每个页框大小)，则页基地址就有了，加上这个40就是实际物理地址  

* 下图中实际例子  
    * 每一页是4K，指令 mov [0x2240], %eax中，用这个地址除以4K(除以2^12,即右移12位(这就是没有把一页做成100的原因，4K计算时可以通过右移实现))，就是页号，2240右移动12位得到2;页号是2，在页表中找到就可以查出页框号3(这个过程是MMU 内存管理单元做的)，所以是3 * 4K (而3 * 4K是3左移动12位置，即 3000)，再加240，得到实际物理地址是0x3240

![image](https://user-images.githubusercontent.com/58176267/161502787-c0821f39-2144-421a-a2f9-e36ef542b6e8.png)



















