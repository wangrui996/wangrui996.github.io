

# 内存使用与分段  

## 内存的使用 

**计算机工作方式**  

![image](https://user-images.githubusercontent.com/58176267/161415490-c246a831-051b-48b7-ba78-06969aef070b.png)


## 程序进入内存  

代码写完后保存在磁盘，编译后对应的汇编代码如图  读磁盘中程序就可以将01组成的指令读入内存，问题是读到内存中哪里  

PC一开始指向0，一开始遇到call 40，就要跳到40处从main函数开始执行，cpu执行call 40指令，就会向地址总线中发40，会到内存中40的位置去寻找指令，而我们希望它执行main函数的第一条指令，因此main函数的第一条指令就应该在物理内存的40处； 而整个程序从_entry开始，到_main的偏移是40，所以_entry应该放在0地址；   

这样做的问题是，该程序中call 40是想执行main函数，则main函数必须放在实际物理地址的40处； 

* 一个程序的_entry想放在物理内存的0地址处，不是随便放的，而且多个程序，不可能都放在这，而且0地址处开始不一定有足够的空闲可以可以用————————**也就是使用直接地址是不行的**  

* 因此应该将程序加载到一段有足够空闲的内存块中，如图中的1000处  
    * 但是这样的话，遇到call 40 会跳到物理内存的40，就出问题了，按理说应该跳到1040处执行    
    * 也就是说，将程序加载到内存中一段空闲区，并且设置到PC的初值，也还不能保证程序顺利执行  
![image](https://user-images.githubusercontent.com/58176267/161416064-5a2ab1a3-13b9-403d-bf98-b90425e25371.png)


## 重定位  修改程序中的地址(程序中的地址是相对地址(相对自己程序的入口地址的偏移))  

**重定位最合适的时机**————**运行时重定位**  下面慢慢来看下为什么有这个结论  


* 每一个程序中遇到的地址都是相对地址，一般称为**逻辑地址**，   即相对程序入口的地址;  多个程序之间的这个相对地址的数字是很有可能相同的； 
* 程序放到实际物理内存后，相对地址需要变成实际内存的物理地址
* 因此程序放到内存合适位置， 将**逻辑地址**修改成**物理地址**，然后PC设置好初值  如上面的例子中，40修改为1040，PC指向1000

* 这个过程即**重定位**  

### 重定位进行的时机

* **如果重定位在编译时做，这样在编译时就需要知道哪段内存是空闲的，实际中是无法预测，除非说一个系统中程序一旦烧进去后都不再变化，如嵌入式系统中静态系统中可能会有，如飞机，卫星等某些地方**————效率高(不用在载入时做加的计算)，程序只能放在内存的固定位置    

* **载入时： 该方式灵活，载入时找空闲地址区，找到后起始地址有了，然后将逻辑地址都加上这个逻辑地址即可** 

### 交换(swap)的概念————程序载入后可能还需要移动  

如下图，内存中进程1执行过程中可能发生阻塞，这段时间它占用的内存是没用的，而内存资源有限的情况下内存其他地方可能还有其他进程在执行，此时如果有新的进程2执行，就需要执行**交换**操作  

* 将进程1换出到磁盘，进程2换入到内存
* 过一会可能进程3阻塞了可以换出到磁盘，然后进程1再从磁盘中换入
* 在这个换出换入的过程中，没法保证重新换入的位置和之前一致，

* 因此，重定位如果只是在第一次载入时进行，也不行，应该在运行时重定位，即第一个可能在1000开始，40重定位成1040，之后可能有换出操作，再换入时要运行了重新重定位，可能是根据2000和40找到2040  

![image](https://user-images.githubusercontent.com/58176267/161416596-8369b6f8-9724-4a22-820f-ebc828d2c75a.png)


**重定位最合适的时机**————**运行时重定位**  

**运行时重定位** 也叫 **地址翻译**

**核心** ： **每执行一条指令，都是从逻辑地址和基地址算出物理地址  (地址翻译)** 

* **进程的基地址base在进程不断换出换入的过程中是有可能变化的，这个信息放在该进程的PCB中**
* 

![image](https://user-images.githubusercontent.com/58176267/161416918-c4a8965e-e153-4721-8c38-58969ad2ac1f.png)
















