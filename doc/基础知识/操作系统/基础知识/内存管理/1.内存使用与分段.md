

# 内存使用与分段  

## 内存的使用 

**计算机工作方式**  

![image](https://user-images.githubusercontent.com/58176267/161415490-c246a831-051b-48b7-ba78-06969aef070b.png)


## 程序进入内存  

代码写完后保存在磁盘，编译后对应的汇编代码如图  读磁盘中程序就可以将01组成的指令读入内存，问题是读到内存中哪里  

PC一开始指向0，一开始遇到call 40，就要跳到40处从main函数开始执行，cpu执行call 40指令，就会向地址总线中发40，会到内存中40的位置去寻找指令，而我们希望它执行main函数的第一条指令，因此main函数的第一条指令就应该在物理内存的40处； 而整个程序从_entry开始，到_main的偏移是40，所以_entry应该放在0地址；   

这样做的问题是，该程序中call 40是想执行main函数，则main函数必须放在实际物理地址的40处； 

* 一个程序的_entry想放在物理内存的0地址处，不是随便放的，而且多个程序，不可能都放在这，而且0地址处开始不一定有足够的空闲可以可以用————————**也就是使用直接地址是不行的**  

* 因此应该将程序加载到一段有足够空闲的内存块中，如图中的1000处  
    * 但是这样的话，遇到call 40 会跳到物理内存的40，就出问题了，按理说应该跳到1040处执行    
    * 也就是说，将程序加载到内存中一段空闲区，并且设置到PC的初值，也还不能保证程序顺利执行  
![image](https://user-images.githubusercontent.com/58176267/161416064-5a2ab1a3-13b9-403d-bf98-b90425e25371.png)


## 重定位  修改程序中的地址(程序中的地址是相对地址(相对自己程序的入口地址的偏移))  

**重定位最合适的时机**————**运行时重定位**  下面慢慢来看下为什么有这个结论  


* 每一个程序中遇到的地址都是相对地址，一般称为**逻辑地址**，   即相对程序入口的地址;  多个程序之间的这个相对地址的数字是很有可能相同的； 
* 程序放到实际物理内存后，相对地址需要变成实际内存的物理地址
* 因此程序放到内存合适位置， 将**逻辑地址**修改成**物理地址**，然后PC设置好初值  如上面的例子中，40修改为1040，PC指向1000

* 这个过程即**重定位**  

### 重定位进行的时机

* **如果重定位在编译时做，这样在编译时就需要知道哪段内存是空闲的，实际中是无法预测，除非说一个系统中程序一旦烧进去后都不再变化，如嵌入式系统中静态系统中可能会有，如飞机，卫星等某些地方**————效率高(不用在载入时做加的计算)，程序只能放在内存的固定位置    

* **载入时： 该方式灵活，载入时找空闲地址区，找到后起始地址有了，然后将逻辑地址都加上这个逻辑地址即可** 

### 交换(swap)的概念————程序载入后可能还需要移动  

如下图，内存中进程1执行过程中可能发生阻塞，这段时间它占用的内存是没用的，而内存资源有限的情况下内存其他地方可能还有其他进程在执行，此时如果有新的进程2执行，就需要执行**交换**操作  

* 将进程1换出到磁盘，进程2换入到内存
* 过一会可能进程3阻塞了可以换出到磁盘，然后进程1再从磁盘中换入
* 在这个换出换入的过程中，没法保证重新换入的位置和之前一致，

* 因此，重定位如果只是在第一次载入时进行，也不行，应该在运行时重定位，即第一个可能在1000开始，40重定位成1040，之后可能有换出操作，再换入时要运行了重新重定位，可能是根据2000和40找到2040  

![image](https://user-images.githubusercontent.com/58176267/161416596-8369b6f8-9724-4a22-820f-ebc828d2c75a.png)


**重定位最合适的时机**————**运行时重定位**  

**运行时重定位** 也叫 **地址翻译**

**核心** ： **每执行一条指令，都是从逻辑地址和基地址算出物理地址  (地址翻译)** 

* **进程的基地址base在进程不断换出换入的过程中是有可能变化的，这个信息放在该进程的PCB中**

* 创建进程时需要创建PCB，然后需要在内存中找一段空闲的内存，将该部分内存的起始地址如1000，赋值给PCB相应量  程序载入到该部分内存然后PC置好初值
* 之后执行进程过程中，每一条指令都要进行地址翻译(如果含地址的话，比如mov [300], 0  是将0赋值给内存的1000+300)  
* 进程的基地址是放在某个寄存器中的，进程切换时，新执行的进程的这个基地址值就会放在寄存器中

   * linux0.11中，TCB/PCB是靠一个task_struct结构体实现的  这个结构体里面有个结构体tss   tss相当于当前进程的CPU快照  进程切换时，cpu段寄存器的内容就放在task_struct结构体中的tss了 而新切换的进程，需要将自己tss中的基地址赋值给cpu段寄存器  

![image](https://user-images.githubusercontent.com/58176267/161416973-75be28c8-6071-47b6-9610-8c78656e3bb5.png)


## 分段的引入  

**程序载入到内存中，是将整个程序一起载入到内存中吗？**  

程序员眼中的程序：  

* 程序是否若干部分(我们把不同部分称为不同段)组成，每个段有个各自的特点和用途；  
* 代码段：只读  代码和数据段不会动态增长
* data段(变量集？) 可写  
* 堆、栈   栈只是单向增长  
* 函数库  函数库可能不需要载入 如动态链接库  在程序执行到调用链接库的代码时，链接库文件才从磁盘载入内存，如果不分段，动态链接库也需要一起载入  
* 。。。。。。

* 用户可以独立考虑每个段(**分治**)   如代码段只允许读，而data段可写，放在一起可能不安全，如将某个数赋值给data段某个量，但是偏移的地址可能出错导致写到代码所在内存  
* 每一个段都是从0开始，如300可能指的不是整个程序的偏移而是相当数据段起始地址的偏移  
* **指令或数据的定位** ： <段号， 段内偏移>  如 mov [es:bx], ax  要访问的地址是，es这个数据段中偏移bx的地址，将ax赋值给它  

![image](https://user-images.githubusercontent.com/58176267/161418171-640f1a74-e86c-4001-a380-b4993bd0b701.png)


















