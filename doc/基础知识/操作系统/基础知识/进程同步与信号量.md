# 进程同步与信号量  

 ## 进程合作的例子  
 
 ![image](https://user-images.githubusercontent.com/58176267/159871512-db7b2dec-f224-408f-bd58-b8b2f495c152.png)


### 生产者-消费者实例  

**进程同步**实际上就是让“进程走走停停”来保证多进程合作的合理有序  

* 生产者计数counter等于BUFFER_SIZE,就不能向下执行，知道消费者取出部分数据后消费者“通知”它以后继续执行   对于消费者，缓冲区空，也要停
* 也就是说进程执行到某种情况，就要进入阻塞态  

**进程同步关键就在于什么时候“停”，什么时候“走”**  


### 只发送“信号”表示的信息不够  

* 也就是按图中的代码逻辑，当有两个以上生产者时，消费者(假设有一个)只能唤醒一个生产者  问题在于消费者仅仅在缓冲区满的时候知道有生产者在等待  
* counter的含义不足以表示到底有几个生产者  
* “信号”不应该只发送“唤醒”这单一的语义  

![image](https://user-images.githubusercontent.com/58176267/159874241-38b998fd-bc98-4318-b581-ddf6c03484e6.png)

### 信号到信号量  

* **也就是信号再加一些量**

![image](https://user-images.githubusercontent.com/58176267/159876444-79cb2b15-87d0-4b8c-b9f5-5a9a963d42e4.png)

* 信号量表示了阻塞态进程 根据这个判断有无睡眠进程在等待  
* counter只对应缓冲区，因此只能根据缓冲区满还是不满决定是否发信号，但不知道有多少睡眠进程

**工作过程**  

* 1.P1执行，缓冲区满，P1 sleep    sem = -1
* 2.P2执行，缓冲区满， P2 sleep   sem = -2
* 3.C执行一次循环， wakeup P1(比如从阻塞队列队首取出)，  sem = -1
* 4.C执行一次循环， wakeup P2     sem = 0
* 5.C执行一次循环，   sem = 1
* 6.此时如果P3执行， 由于sem = 1(表示消费者还有1个空闲缓冲区)， P3不需要阻塞

* -1表示还欠1个空闲缓冲区，此时再有生产者执行会进入睡眠(消费者都欠一个了肯定不能再往缓冲区放了)
* C执行一次后将sem加1变成0
* 某个P再执行由于sem大于0所以可以执行，但是执行完要将sem减1

**也就是说生产者和消费者都是根据信号量的值决定自己是否"走"是否"停"**
