# 进程同步与信号量  

 ## 进程合作的例子  
 
 ![image](https://user-images.githubusercontent.com/58176267/159871512-db7b2dec-f224-408f-bd58-b8b2f495c152.png)


### 生产者-消费者实例  

**进程同步**实际上就是让“进程走走停停”来保证多进程合作的合理有序  

* 生产者计数counter等于BUFFER_SIZE,就不能向下执行，知道消费者取出部分数据后消费者“通知”它以后继续执行   对于消费者，缓冲区空，也要停
* 也就是说进程执行到某种情况，就要进入阻塞态  

**进程同步关键就在于什么时候“停”，什么时候“走”**  


### 只发送“信号”表示的信息不够  

* 也就是按图中的代码逻辑，当有两个以上生产者时，消费者(假设有一个)只能唤醒一个生产者  问题在于消费者仅仅在缓冲区满的时候知道有生产者在等待  
* counter的含义不足以表示到底有几个生产者  
* “信号”不应该只发送“唤醒”这单一的语义  

![image](https://user-images.githubusercontent.com/58176267/159874241-38b998fd-bc98-4318-b581-ddf6c03484e6.png)

### 信号到信号量  

* **也就是信号再加一些量**

![image](https://user-images.githubusercontent.com/58176267/159876444-79cb2b15-87d0-4b8c-b9f5-5a9a963d42e4.png)

* 信号量表示了阻塞态进程 根据这个判断有无睡眠进程在等待  
* counter只对应缓冲区，因此只能根据缓冲区满还是不满决定是否发信号，但不知道有多少睡眠进程

**工作过程**  

* 1.P1执行，缓冲区满，P1 sleep    sem = -1
* 2.P2执行，缓冲区满， P2 sleep   sem = -2
* 3.C执行一次循环， wakeup P1(比如从阻塞队列队首取出)，  sem = -1
* 4.C执行一次循环， wakeup P2     sem = 0
* 5.C执行一次循环，   sem = 1
* 6.此时如果P3执行， 由于sem = 1(表示消费者还有1个空闲缓冲区)， P3不需要阻塞

* -1表示还欠1个空闲缓冲区，此时再有生产者执行会进入睡眠(消费者都欠一个了肯定不能再往缓冲区放了
* C执行一次后将sem加1变成0
* 某个P再执行由于sem大于0所以可以执行，但是执行完要将sem减1


 ### 信号量定义  
 
* 一个结构体作为信号量 
    * 资源个数
    * 等待在该信号量上的进程 PCB * queue

* P 消费资源(比如生产者)   调用P(s)
    * 将s.value减1，因为自己要用这个资源了
    * 判断信号量的value如果小于0，如果是说明刚才信号量的value就是等于0或者小于0的，没资源或欠资源了，得不到资源，自己就sleep

* V 产生资源(比如消费者)  调用V(s)  

```c
V(semaphore s)
{
    s.value++; //生产资源
    if(s.value <= 0) {   // 如果s.value<0说明刚才就是负的，现在新生产了一个资源，因此需要唤醒，如果刚才s.value = 0,说明刚才是-1，也要唤醒  
        wakeup(s.queue);
    }
}
```
 
 ![image](https://user-images.githubusercontent.com/58176267/159892270-50628f0e-0d9f-43a7-af1a-91771575a7d1.png)


### 信号量解决生产者-消费者问题  

* 定义信号量并初始化 
    * semaphore empty = BUFFER_SIZE;  //用来判断生产者停走  初始化为缓冲区大小(因为它是buffer的剩余空间减为1时停，而一开始buffer空闲是满的)
    * semaphore full = 0  //用于判断消费者停走 初始化为0(它是在缓冲区空的时候停，一开始就是空的，所以初始化为0)
    * 两者停的时机是不同的，但P(s)的逻辑是一样的，看上面代码都是对信号量先减1再判断是否小于0，小于0就停
    
* 对于生产者  
    * 先P(empty); //判断是否还要空闲缓冲区 （对应的消费者最后要写V(empty)）
    * P
* 消费者
    * 先P(full);  (生产者最后要V(full))  

* 互斥信号量mutex初始化为1(1的原因是比如写文件1次也只能一个进程来写) 
    * 每一次一个进程想对文件执行写或读操作时，先检查P(mutex);原来因为是1减1后变成0，不会睡眠，进入程序执行写操作，执行完后再释放V(mutex)，在这个过程，没有释放前，加入有进程比如消费者要读文件，也会先检查P(mutex)，此时mutex减1后为-1，自己就阻塞;  



![image](https://user-images.githubusercontent.com/58176267/159901721-2362a434-4c03-4b1b-80e4-2000a7e336d8.png)



# 信号量临界区保护  

靠临界区保护信号量，靠信号量实现进程间同步  


信号量 ： 本质是一个整型变量， 通过对这个量的访问和修改，实现进程间同步(有序推进，什么 时候该睡眠，什么时候该执行)  


**问题**   
必须保证信号量是对的，比如前面提到的生产者对应的empty，生产者使用P(empty),检查，发现empty = -2,(没减之前就是-1)，即已经睡眠了一个进程，自己也该睡眠  


## 共同修改信号量引出的问题  

![image](https://user-images.githubusercontent.com/58176267/160275460-30937ce4-9481-4f46-9d23-e6e26f7c7a93.png)


**竞争条件： 和调度有关的共享数据语义错误** 

* 错误由多个进程并发操作共享数据引起 
* 错误和调度顺序有关，可能某次执行顺序是对的，可能就如上图所示造成错误，这种错误不是由编程错误引起的，难于发现和调试  

## 解决竞争条件的直观想法  

* 在写共享变量empty时阻止其他进程也访问emty  



* **原子操作** ：一段代码一次只允许一个进程进入，当一个进程要执行某段代码修改共享数据时，它先检查有没有锁，以此保证，要么一点也不做，要么就直接做完，这就是原子操作，它不可分割，必须做完

![image](https://user-images.githubusercontent.com/58176267/160284917-3b503e01-7edb-4c61-868c-44a4f878ce1b.png)


## 临界区  

* **临界区**：一次只允许一个进程进入的该进程的那一段代码  
    * 如生产者P1  empty--;    生产者P2  empty--;
* 一个非常重要的工作：**找出进程中的临界区代码**  
* 读写信号量的代码一定是临界区  

![image](https://user-images.githubusercontent.com/58176267/160285185-61b795c8-751a-47a0-8745-4156dbeee093.png)

### 临界区代码的保护原则  

* **基本原则**：
    * **互斥进入**：如果一个进程在临界区中执行，则其他进程不允许进入  这些进程间的约束关系称为**互斥**
* 好的原则 
    * **有空让进**：若干进程要求进入空闲临界区时，应尽快使一进程进入临界区
    * **有限等待**：从进程发出进入请求到允许进入，不能无限等待  


### 进入临界区的方法  

#### 方法1 ： 轮转  

* 进程P0判断如果没有轮到自己（turn != 0）,就自选， 当turn = 0时自己进入临界区，退出时置turn = 1  
* 进程P1判断如果turn != 1 ,自旋.........
* **问题** ：加入P0进程退出临界区后，将turn置为1了，但是进程1由于某种原因阻塞了，**没有请求进入临界区**，**那turn一时半会也不会置0**，此时临界区虽然有空(可以有进程进入)，但没有进程能进入   
* **核心问题就是，只用轮转思想的话，某一次我从临界区退出后，光知道下次轮到你了，但是如果你没申请进入，那咱俩谁都不会进入**

![image](https://user-images.githubusercontent.com/58176267/160286288-3ab857c1-71e6-4641-9c3a-ea66c0e79b6b.png)


#### 方法2 ： 标记法

* 自己要进入临界区前,打个标记 如进程P0  flag[0] = true  同时进入while循环，判断flag[1]如果也在true(说明进程P1在临界区)，那自己就等着； 自己从临界区出来以后，将标记修改 flag[0] = false  

![image](https://user-images.githubusercontent.com/58176267/160285601-8d5d0d3c-5f5b-4033-b5e8-67d4a8aa803a.png)

* 这种方法，满足互斥进入(P0能进入，说明flag[0] = true, flag[1] = flase   P1进入，说明flag[1] = true, flag[0] = false, 矛盾，所以满足互斥性)

* **解决了轮转方法的问题**——如果某一次进程P0退出后，进程2如果阻塞了不去申请，那么进程0申请的时候还是可以进入的，因此P1没申请flag[1] = false ,P0不会自旋，**但是，仍然不满足有空让进**

* 不满足**有空让进** 原因
    * 比如下图执行顺序 : (1) flag[0] = true 此时进程切换 (2) flag[2] = true 进程切换 （3） P0进程判断flag[1]  = true,因此自旋  进程切换（4）进程P1判断flag[0] = true,自旋，此时临界区允许进程进入，但是谁也进不去
    * 此时P0和P1的进入请求会无限等待
   
![image](https://user-images.githubusercontent.com/58176267/160285981-837cf996-52d4-4827-a0ef-5d0ac15bb44d.png)


#### 方法3 Peterson算法  非对称标记  

* 结合了标记和轮转两种思想(**也解决了上面两个各自存在的问题**)  

* 进程P0，请求进入临界区，自己打标记，同时将 turn 置为1(代表下一次轮到1了)  判断 如果进程P1打过标记(flag[1] = true)并且轮到1(turn == 1)了，那就自旋
* 进程P1相同，如果发现进程P0打了标记并且轮到P0了，就自旋


![image](https://user-images.githubusercontent.com/58176267/160286119-55c5e24c-a465-46b0-bddf-1b0911162e65.png)

**正确性验证**  

满足互斥进入，有空让进(命名有空缺没有进程可以进入)、有限等待

* **核心就是**，while循环的条件，使得不可能所有进程都在这里自旋    
    * 如果进程P0退出临界区，其他进程没有申请，P0再次申请时，虽然turn为1(轮到1了)，但是flag[1] 为false 会进入临界区——————解决了轮转的问题
    * 如果两进程同时申请，纯标记法可能会出现，flag[0]和flag[1]均为true的情况，但两者while循环判断时，turn总要是一个值，要么是0要么是1，所以两个进程总有一个能进入临界区  
    * 也满足**有限等待**：一个进程P0申请进入，即时另一个进程P1执行的再快，也无法重复进入，因为进入一次后，turn置为0，下一次P1就会自旋，此时P0申请是可以进入的

![image](https://user-images.githubusercontent.com/58176267/160287661-de31eac1-ecbb-4b0a-8cdc-22df9022991a.png)


