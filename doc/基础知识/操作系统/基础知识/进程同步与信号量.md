# 进程同步与信号量  

 ## 进程合作的例子  
 
 ![image](https://user-images.githubusercontent.com/58176267/159871512-db7b2dec-f224-408f-bd58-b8b2f495c152.png)


### 生产者-消费者实例  

**进程同步**实际上就是让“进程走走停停”来保证多进程合作的合理有序  

* 生产者计数counter等于BUFFER_SIZE,就不能向下执行，知道消费者取出部分数据后消费者“通知”它以后继续执行   对于消费者，缓冲区空，也要停
* 也就是说进程执行到某种情况，就要进入阻塞态  

**进程同步关键就在于什么时候“停”，什么时候“走”**  


### 只发送“信号”表示的信息不够  

* 也就是按图中的代码逻辑，当有两个以上生产者时，消费者(假设有一个)只能唤醒一个生产者  问题在于消费者仅仅在缓冲区满的时候知道有生产者在等待  
* counter的含义不足以表示到底有几个生产者  
* “信号”不应该只发送“唤醒”这单一的语义  

![image](https://user-images.githubusercontent.com/58176267/159874241-38b998fd-bc98-4318-b581-ddf6c03484e6.png)

### 信号到信号量  

* **也就是信号再加一些量**

![image](https://user-images.githubusercontent.com/58176267/159876444-79cb2b15-87d0-4b8c-b9f5-5a9a963d42e4.png)

* 信号量表示了阻塞态进程 根据这个判断有无睡眠进程在等待  
* counter只对应缓冲区，因此只能根据缓冲区满还是不满决定是否发信号，但不知道有多少睡眠进程

**工作过程**  

* 1.P1执行，缓冲区满，P1 sleep    sem = -1
* 2.P2执行，缓冲区满， P2 sleep   sem = -2
* 3.C执行一次循环， wakeup P1(比如从阻塞队列队首取出)，  sem = -1
* 4.C执行一次循环， wakeup P2     sem = 0
* 5.C执行一次循环，   sem = 1
* 6.此时如果P3执行， 由于sem = 1(表示消费者还有1个空闲缓冲区)， P3不需要阻塞

* -1表示还欠1个空闲缓冲区，此时再有生产者执行会进入睡眠(消费者都欠一个了肯定不能再往缓冲区放了
* C执行一次后将sem加1变成0
* 某个P再执行由于sem大于0所以可以执行，但是执行完要将sem减1


 ### 信号量定义  
 
* 一个结构体作为信号量 
    * 资源个数
    * 等待在该信号量上的进程 PCB * queue

* P 消费资源(比如生产者)   调用P(s)
    * 将s.value减1，因为自己要用这个资源了
    * 判断信号量的value如果小于0，如果是说明刚才信号量的value就是等于0或者小于0的，没资源或欠资源了，得不到资源，自己就sleep

* V 产生资源(比如消费者)  调用V(s)  

```c
V(semaphore s)
{
    s.value++; //生产资源
    if(s.value <= 0) {   // 如果s.value<0说明刚才就是负的，现在新生产了一个资源，因此需要唤醒，如果刚才s.value = 0,说明刚才是-1，也要唤醒  
        wakeup(s.queue);
    }
}
```
 
 ![image](https://user-images.githubusercontent.com/58176267/159892270-50628f0e-0d9f-43a7-af1a-91771575a7d1.png)


### 信号量解决生产者-消费者问题  

* 定义信号量并初始化 
    * semaphore empty = BUFFER_SIZE;  //用来判断生产者停走  初始化为缓冲区大小(因为它是buffer的剩余空间减为1时停，而一开始buffer空闲是满的)
    * semaphore full = 0  //用于判断消费者停走 初始化为0(它是在缓冲区空的时候停，一开始就是空的，所以初始化为0)
    * 两者停的时机是不同的，但P(s)的逻辑是一样的，看上面代码都是对信号量先减1再判断是否小于0，小于0就停
    
* 对于生产者  
    * 先P(empty); //判断是否还要空闲缓冲区 （对应的消费者最后要写V(empty)）
    * P
* 消费者
    * 先P(full);  (生产者最后要V(full))  

* 互斥信号量mutex初始化为1(1的原因是比如写文件1次也只能一个进程来写) 
    * 每一次一个进程想对文件执行写或读操作时，先检查P(mutex);原来因为是1减1后变成0，不会睡眠，进入程序执行写操作，执行完后再释放V(mutex)，在这个过程，没有释放前，加入有进程比如消费者要读文件，也会先检查P(mutex)，此时mutex减1后为-1，自己就阻塞;  



![image](https://user-images.githubusercontent.com/58176267/159901721-2362a434-4c03-4b1b-80e4-2000a7e336d8.png)



# 信号量临界区保护  

靠临界区保护信号量，靠信号量实现进程间同步  


信号量 ： 本质是一个整型变量， 通过对这个量的访问和修改，实现进程间同步(有序推进，什么 时候该睡眠，什么时候该执行)  


**问题**   
必须保证信号量是对的，比如前面提到的生产者对应的empty，生产者使用P(empty),检查，发现empty = -2,(没减之前就是-1)，即已经睡眠了一个进程，自己也该睡眠  


## 共同修改信号量引出的问题  

![image](https://user-images.githubusercontent.com/58176267/160275460-30937ce4-9481-4f46-9d23-e6e26f7c7a93.png)












