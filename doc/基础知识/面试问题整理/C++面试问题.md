# C++  


## override 关键字 (C++11 新特性)  

* 用于成员函数声明之后，表示这是个虚函数，并重写了基类里的虚函数
    * 如果父类中函数忘记了加virtual关键字,编译时就会报错
    * 如果重写时，语义和父类中虚函数不同，不如重写的函数多了个const，不希望修改类成员，这样编译时也会报错
    * 如果不加override 关键字，那么上面两种情况编译时都不会报错，运行效果可能就不是我们想要的

[override 关键字](https://blog.csdn.net/whahu1989/article/details/117535968)

## 虚函数  

虚函数实现多态的原理：虚函数表  
* 条件：基类中含有虚函数，派生类重写该虚函数; 基类指针指向派生类对象
* 编译器会为该基类创建一个虚函数表,本质上是个结构体，里面有一个函数指针成员  在基类和派生类的内存模型中(一个struct结构体?),包含一个虚函数表指针,即指向一个虚函数表的实例化对象
    * 其中, 基类的虚函数表指针没有默认值，它不指向一个实例化的虚函数表对象
    * 不同派生类的内存模型中的虚函数表指针指向不同的实例化的虚函数表对象，其中的函数指针指向不同的函数(分别指向自己重写的那个函数)
 
 
### 含有虚函数的基类
 
* 程序运行时，因为可能有多个类都有虚函数，**每一张虚函数表/vftable都会加载到内存的.rodata区(常量区/只读数据区)**、当定义一个含虚函数的类对象时，它的内存模型中不止含有数据成员，还会有一个vfptr，即虚函数表指针   
    * 虚函数表vftable主要包含RTTI指针(指向一个常量区字符串,类名)和虚函数地址(函数指针)、
    * 听一个类定义多个对象，它们的vfptr都是指向同一张虚函数表
    * 一个类中如果有多个虚函数, 和只有一个虚函数,类对象的内存大小是一样的,都是只需要一个虚函数表指针vfptr  但是虚函数表的大小就不同了，因为虚函数表中会存储虚函数的地址，因此多一个虚函数这个虚函数表就会增大

![image](https://user-images.githubusercontent.com/58176267/166108469-56516a13-892c-4dca-af01-68d6695915cc.png)

### 派生类  

* 如果派生类中方法，和基类继承来的某个方法，返回值，函数名，参数列表都相同，且基类的方法是virtual虚函数,**那么派生类的这个方法自动处理成虚函数(虽然没写virtual)**  
* 编译阶段，会给派生类这个类型生成一张虚函数表vftable 
    * 虚函数表中RTTI指针指向一个类型字符串(派生类类型名，实际上存的是一个RTTI类型的一个对象，这里只是简单理解); 
    * 还存了一个0？ 
    * 但是编译器发现派生类重写了这个方法(一般说覆盖了)，就不再记录从基类继承的虚函数地址了，而是存重写的函数地址，**所以说重写是覆盖，指得就是虚函数表中,函数地址的覆盖**
    * 假设基类有两个虚函数,可能是不同名，也可能是重载的，但是派生类只重写了其中一个，那么派生类虚函数表中,会从基类继承下没有重写的那个函数地址  

![image](https://user-images.githubusercontent.com/58176267/166108954-a5f0059c-e1f0-43a5-8ef9-4730ca45ef8c.png)









