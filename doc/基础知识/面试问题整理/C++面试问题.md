# C++  


<p id="父子类构造函数析构函数的调用顺序"></p>

## 父、子类构造函数、析构函数的调用顺序  




<p id="override"></p>


## override 关键字 (C++11 新特性)  

* 用于成员函数声明之后，表示这是个虚函数，并重写了基类里的虚函数
    * 如果父类中函数忘记了加virtual关键字,编译时就会报错
    * 如果重写时，语义和父类中虚函数不同，不如重写的函数多了个const，不希望修改类成员，这样编译时也会报错
    * 如果不加override 关键字，那么上面两种情况编译时都不会报错，运行效果可能就不是我们想要的

[override 关键字](https://blog.csdn.net/whahu1989/article/details/117535968)



<p id="C++多态与虚函数"></p>

* 多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为
* 实际上，广义上的多态应该分为编译时多态和运行时多态，编译时多态是通过函数重载实现的，运行时多态是通过虚函数,基类指针或引用指向派生类的对象实现的


## static 关键字  

[static 关键字](https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/9601831)  


## const 关键字  

[const 关键字](https://blog.csdn.net/little_rookie__/article/details/111873494)  


## 虚函数  

虚函数实现多态的原理：虚函数表  
* 条件：基类中含有虚函数，派生类重写该虚函数; 基类指针指向派生类对象
* 编译器会为该基类创建一个虚函数表,本质上是个结构体，里面有一个函数指针成员  在基类和派生类的内存模型中(一个struct结构体?),包含一个虚函数表指针,即指向一个虚函数表的实例化对象
    * 其中, 基类的虚函数表指针没有默认值，它不指向一个实例化的虚函数表对象
    * 不同派生类的内存模型中的虚函数表指针指向不同的实例化的虚函数表对象，其中的函数指针指向不同的函数(分别指向自己重写的那个函数)
 
### 含有虚函数的基类
 
* 程序运行时，因为可能有多个类都有虚函数，**每一张虚函数表/vftable都会加载到内存的.rodata区(常量区/只读数据区)**、当定义一个含虚函数的类对象时，它的内存模型中不止含有数据成员，还会有一个vfptr，即虚函数表指针   
    * 虚函数表vftable主要包含RTTI指针(指向一个常量区字符串,类名)和虚函数地址(函数指针)、
    * 听一个类定义多个对象，它们的vfptr都是指向同一张虚函数表
    * 一个类中如果有多个虚函数, 和只有一个虚函数,类对象的内存大小是一样的,都是只需要一个虚函数表指针vfptr  但是虚函数表的大小就不同了，因为虚函数表中会存储虚函数的地址，因此多一个虚函数这个虚函数表就会增大

![image](https://user-images.githubusercontent.com/58176267/166108469-56516a13-892c-4dca-af01-68d6695915cc.png)

### 派生类  

* 如果派生类中方法，和基类继承来的某个方法，返回值，函数名，参数列表都相同，且基类的方法是virtual虚函数,**那么派生类的这个方法自动处理成虚函数(虽然没写virtual)**  
* 编译阶段，会给派生类这个类型生成一张虚函数表vftable 
    * 虚函数表中RTTI指针指向一个类型字符串(派生类类型名，实际上存的是一个RTTI类型的一个对象，这里只是简单理解); 
    * 还存了一个0, 表示vfptr在内存中的偏移量 一般vfptr优先级比较高,因此这个地方一般就是0 (除非是虚继承的情况?)
    * 但是编译器发现派生类重写了这个方法(一般说覆盖了)，就不再记录从基类继承的虚函数地址了，而是存重写的函数地址，**所以说重写是覆盖，指得就是虚函数表中,函数地址的覆盖**
    * 假设基类有两个虚函数,可能是不同名，也可能是重载的，但是派生类只重写了其中一个，那么派生类虚函数表中,会从基类继承下没有重写的那个函数地址  
    * **虚函数表中，函数地址的存放顺序一般是先从基类集成的没重写的虚函数,然后是重写的？ 可能与图中画的顺序不一致，可以通过查看类的内存模型或者断点查看类对象或指针的成员**  
    
![image](https://user-images.githubusercontent.com/58176267/166108954-a5f0059c-e1f0-43a5-8ef9-4730ca45ef8c.png)

### 静态绑定和动态绑定  

* 假设一个基类指针指向了派生类对象
* 会先到基类作用域查看这个不带参数的show的情况，如果发现是一个普通函数，进行静态绑定 如果编译阶段编译器发现：指针是个Base类型,Base作用域下发现show是一个虚函数,就进行动态绑定

* 动态绑定：pb->show(); 发现应该动态绑定————> mov eax, dword ptr[pb]  表示把pb指向的对象(假设是一个派生类对象)的前4个字节(两个字),移动到eax  我们已知，该对象前四个字节存放的是虚函数表的地址   mov ecx, dword, prt[eax] 现在eax指向的是派生类的虚函数表,取四个字节,即取得是派生类show方法的地址  最后再 call ecx     
    * 可以发现, 动态绑定时,编译的汇编指令, 最后是call一个寄存器, 通过在内存上计数我们可能可以知道它调用的是派生类重写的那个show方法,但是在编译阶段,生成的指令中是看不出来调用的是那个函数的,于是将这种绑定叫做动态绑定——————运行时才知道寄存器中存放的函数地址,从而完成函数的调用

```cpp
/*
基类Base 和 派生类 Device的定义

假设基类定义了两个重载的虚函数show 一个是带参数一个不带参数

*/

int main
{
   Base a(50);
   Device d(50);
   
   Base *pa = &a;
   Base *pb = &d;
   
   pa->show(); //静态绑定 静态的意思是编译阶段  绑定是指函数的调用  意思是编译阶段就可以知道调用的哪个函数, 编译的汇编指令类似 call Base::show (01612D)
   
   pb->show(); //会先到基类作用域查看这个不带参数的show的情况，如果发现是一个普通函数，进行静态绑定 如果编译阶段编译器发现：指针是个Base类型,Base作用域下发现show是一个虚函数,就进行动态绑定
   pb->show(10); //假设派生类没有重写重载版本的虚函数,编译器发现pb类型是Base,到Base作用域查看发现是一个虚函数(如果是普通函数直接静态绑定),此时动态绑定,编译完后还是上面类似上面的汇编指令,但是
   return 0;
}
```

**可以将下面这段代码打断点并查看反汇编后的指令,就能知道所谓的静态绑定和动态绑定的本质区别**  

```cpp
class Base {
public:
	Base(int _x):x(_x) {}

	virtual void show() {
		cout << "Base show()" << endl;
	}
	virtual void show(int m) {
		cout << "Base show(int)" << m << endl;
	}

	void func()
	{
		cout << "Base func()" << endl;
	}

private:
	int x;
};


class Device : public Base {

public:
	Device(int _x, int _y) :Base(_x), y(_y) {}


	void show() {
		cout << "Device show()" << endl;
	}
	
	void func() {
		cout << "Device func()" << endl;
	}

private:
	int y;
};


int main()
{
	Base base(100);
	Device device(3, 4);

	Base *p = new Device(1,2);

	p->func();  //静态绑定 汇编代码直接 call Base::func()(xxxxx)
	p->show(); // 动态绑定 
	p->show(10);

	return 0;
}
```

* p->show();对应的汇编代码大概如下：(vs下通过断点反汇编查看)
* 下面的汇编代码可能不完整，只是大概意思
* 在运行起程序后，通过断点调试加反汇编的方式  通过分析类的内存模型等可以分析出最终调用的派生类函数show的地址，但是这个信息，只有在运行时才知道因为汇编指令第一步就要根据p指针指向的内容才能拿到派生类虚函数表,派生类在堆区new的,编译时是不知道确切地址的  

```cpp
mov eax, dword ptr[p]   将p指针指向的内容(即派生类对象)的前四个字节放到 eax   这四个字节放的是虚函数表的地址  
mov edx, dword ptr [eax]  将eax这个地址的前四个字节放到edx  此时eax相当于指向虚函数表，其前四个字节表示派生类虚函数show()的地址  当然如果有其他虚函数可能就不一样了  
call edx  调用派生类的show函数地址
```

### 总结

* **静态绑定绑定是普通函数的调用, 本质上就是编译时生成了call xxx某个具体的函数地址 的汇编代码   动态绑定是对虚函数的调用, 汇编指令最终call的是寄存器 寄存器的地址运行时才知道**
* **覆盖的概念：**基类和派生类的方法, 返回值、函数名及参数列表都相同，而且基类的方法是虚函数,那么派生类的方法就自动处理成虚函数,它们之间成为覆盖关系（派生类的虚函数表中,本来应该是继承自基类的虚函数地址,但是会被自己写的函数地址覆盖! 覆盖就是说的虚函数表中的覆盖）


## 虚函数代价  

* 1.有函数的类需要一张虚函数表，存储指向虚成员函数的指针，在只读数据区？，增大了类
* 2.带有虚函数的类定义的对象，都会有一个指向虚函数表的指针(32位系统可能占4字节)，增加对象的空间大小  
* 3.虚函数不能再定义成内联函数，因为内联函数在编译阶段进行替换，虚函数的调用处，在编译时都不确定到底调用的是哪一个函数，需要运行时才能去欸的那个，因此虚函数不能是内联函数  

## C语言怎样实现类似C++中的继承和多态  

* C语言的结构体不能定义函数
* C语言一个结构体中，定义另一个结构体的对象即实现继承 
* 关于多态可参见八股文C++篇62


<p id="浮点的比较"></p>

## 浮点数的比较  











