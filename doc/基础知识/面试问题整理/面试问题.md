# C++  


## 目录  

* [C++内存模型](#C++内存模型)
* [判断大小端](#判断大小端)
* [判断链表是否有环形、两链表是否相交](#判断链表是否有环形、两链表是否相交)
* [链接过程](#链接过程)  
* [程序必须从main函数开始吗](#程序必须从main函数开始吗)
* [extern关键字](#extern关键字)  
* [volatile关键字](#volatile关键字) 

 
<p id="C++内存模型"></p>
## C++内存模型  

![image](https://user-images.githubusercontent.com/58176267/178879641-6f34146c-a80f-4d45-8d2c-34f2f68d1ade.png)  

<p id="父子类构造函数析构函数的调用顺序"></p>

## 父、子类构造函数、析构函数的调用顺序  




<p id="override"></p>
## override 关键字 (C++11 新特性)  

* 用于成员函数声明之后，表示这是个虚函数，并重写了基类里的虚函数
    * 如果父类中函数忘记了加virtual关键字,编译时就会报错
    * 如果重写时，语义和父类中虚函数不同，不如重写的函数多了个const，不希望修改类成员，这样编译时也会报错
    * 如果不加override 关键字，那么上面两种情况编译时都不会报错，运行效果可能就不是我们想要的

[override 关键字](https://blog.csdn.net/whahu1989/article/details/117535968)



<p id="C++多态与虚函数"></p>

* 多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为
* 实际上，广义上的多态应该分为编译时多态和运行时多态，编译时多态是通过函数重载实现的，运行时多态是通过虚函数,基类指针或引用指向派生类的对象实现的


## static 关键字  

[static 关键字](https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/9601831)  


## const 关键字  

[const 关键字](https://blog.csdn.net/little_rookie__/article/details/111873494)  


## 虚函数  

虚函数实现多态的原理：虚函数表  
* 条件：基类中含有虚函数，派生类重写该虚函数; 基类指针指向派生类对象
* 编译器会为该基类创建一个虚函数表,本质上是个结构体，里面有一个函数指针成员  在基类和派生类的内存模型中(一个struct结构体?),包含一个虚函数表指针,即指向一个虚函数表的实例化对象
    * 其中, 基类的虚函数表指针没有默认值，它不指向一个实例化的虚函数表对象
    * 不同派生类的内存模型中的虚函数表指针指向不同的实例化的虚函数表对象，其中的函数指针指向不同的函数(分别指向自己重写的那个函数)
 
### 含有虚函数的基类
 
* 程序运行时，因为可能有多个类都有虚函数，**每一张虚函数表/vftable都会加载到内存的.rodata区(常量区/只读数据区)**、当定义一个含虚函数的类对象时，它的内存模型中不止含有数据成员，还会有一个vfptr，即虚函数表指针   
    * 虚函数表vftable主要包含RTTI指针(指向一个常量区字符串,类名)和虚函数地址(函数指针)、
    * 听一个类定义多个对象，它们的vfptr都是指向同一张虚函数表
    * 一个类中如果有多个虚函数, 和只有一个虚函数,类对象的内存大小是一样的,都是只需要一个虚函数表指针vfptr  但是虚函数表的大小就不同了，因为虚函数表中会存储虚函数的地址，因此多一个虚函数这个虚函数表就会增大

![image](https://user-images.githubusercontent.com/58176267/166108469-56516a13-892c-4dca-af01-68d6695915cc.png)

### 派生类  

* 如果派生类中方法，和基类继承来的某个方法，返回值，函数名，参数列表都相同，且基类的方法是virtual虚函数,**那么派生类的这个方法自动处理成虚函数(虽然没写virtual)**  
* 编译阶段，会给派生类这个类型生成一张虚函数表vftable 
    * 虚函数表中RTTI指针指向一个类型字符串(派生类类型名，实际上存的是一个RTTI类型的一个对象，这里只是简单理解); 
    * 还存了一个0, 表示vfptr在内存中的偏移量 一般vfptr优先级比较高,因此这个地方一般就是0 (除非是虚继承的情况?)
    * 但是编译器发现派生类重写了这个方法(一般说覆盖了)，就不再记录从基类继承的虚函数地址了，而是存重写的函数地址，**所以说重写是覆盖，指得就是虚函数表中,函数地址的覆盖**
    * 假设基类有两个虚函数,可能是不同名，也可能是重载的，但是派生类只重写了其中一个，那么派生类虚函数表中,会从基类继承下没有重写的那个函数地址  
    * **虚函数表中，函数地址的存放顺序一般是先从基类集成的没重写的虚函数,然后是重写的？ 可能与图中画的顺序不一致，可以通过查看类的内存模型或者断点查看类对象或指针的成员**  
    
![image](https://user-images.githubusercontent.com/58176267/166108954-a5f0059c-e1f0-43a5-8ef9-4730ca45ef8c.png)

### 静态绑定和动态绑定  

* 假设一个基类指针指向了派生类对象
* 会先到基类作用域查看这个不带参数的show的情况，如果发现是一个普通函数，进行静态绑定 如果编译阶段编译器发现：指针是个Base类型,Base作用域下发现show是一个虚函数,就进行动态绑定

* 动态绑定：pb->show(); 发现应该动态绑定————> mov eax, dword ptr[pb]  表示把pb指向的对象(假设是一个派生类对象)的前4个字节(两个字),移动到eax  我们已知，该对象前四个字节存放的是虚函数表的地址   mov ecx, dword, prt[eax] 现在eax指向的是派生类的虚函数表,取四个字节,即取得是派生类show方法的地址  最后再 call ecx     
    * 可以发现, 动态绑定时,编译的汇编指令, 最后是call一个寄存器, 通过在内存上计数我们可能可以知道它调用的是派生类重写的那个show方法,但是在编译阶段,生成的指令中是看不出来调用的是那个函数的,于是将这种绑定叫做动态绑定——————运行时才知道寄存器中存放的函数地址,从而完成函数的调用

```cpp
/*
基类Base 和 派生类 Device的定义

假设基类定义了两个重载的虚函数show 一个是带参数一个不带参数

*/

int main
{
   Base a(50);
   Device d(50);
   
   Base *pa = &a;
   Base *pb = &d;
   
   pa->show(); //静态绑定 静态的意思是编译阶段  绑定是指函数的调用  意思是编译阶段就可以知道调用的哪个函数, 编译的汇编指令类似 call Base::show (01612D)
   
   pb->show(); //会先到基类作用域查看这个不带参数的show的情况，如果发现是一个普通函数，进行静态绑定 如果编译阶段编译器发现：指针是个Base类型,Base作用域下发现show是一个虚函数,就进行动态绑定
   pb->show(10); //假设派生类没有重写重载版本的虚函数,编译器发现pb类型是Base,到Base作用域查看发现是一个虚函数(如果是普通函数直接静态绑定),此时动态绑定,编译完后还是上面类似上面的汇编指令,但是
   return 0;
}
```

**可以将下面这段代码打断点并查看反汇编后的指令,就能知道所谓的静态绑定和动态绑定的本质区别**  

```cpp
class Base {
public:
	Base(int _x):x(_x) {}

	virtual void show() {
		cout << "Base show()" << endl;
	}
	virtual void show(int m) {
		cout << "Base show(int)" << m << endl;
	}

	void func()
	{
		cout << "Base func()" << endl;
	}

private:
	int x;
};


class Device : public Base {

public:
	Device(int _x, int _y) :Base(_x), y(_y) {}


	void show() {
		cout << "Device show()" << endl;
	}
	
	void func() {
		cout << "Device func()" << endl;
	}

private:
	int y;
};


int main()
{
	Base base(100);
	Device device(3, 4);

	Base *p = new Device(1,2);

	p->func();  //静态绑定 汇编代码直接 call Base::func()(xxxxx)
	p->show(); // 动态绑定 
	p->show(10);

	return 0;
}
```

* p->show();对应的汇编代码大概如下：(vs下通过断点反汇编查看)
* 下面的汇编代码可能不完整，只是大概意思
* 在运行起程序后，通过断点调试加反汇编的方式  通过分析类的内存模型等可以分析出最终调用的派生类函数show的地址，但是这个信息，只有在运行时才知道因为汇编指令第一步就要根据p指针指向的内容才能拿到派生类虚函数表,派生类在堆区new的,编译时是不知道确切地址的  

```cpp
mov eax, dword ptr[p]   将p指针指向的内容(即派生类对象)的前四个字节放到 eax   这四个字节放的是虚函数表的地址  
mov edx, dword ptr [eax]  将eax这个地址的前四个字节放到edx  此时eax相当于指向虚函数表，其前四个字节表示派生类虚函数show()的地址  当然如果有其他虚函数可能就不一样了  
call edx  调用派生类的show函数地址
```

### 总结

* **静态绑定绑定是普通函数的调用, 本质上就是编译时生成了call xxx某个具体的函数地址 的汇编代码   动态绑定是对虚函数的调用, 汇编指令最终call的是寄存器 寄存器的地址运行时才知道**
* **覆盖的概念：**基类和派生类的方法, 返回值、函数名及参数列表都相同，而且基类的方法是虚函数,那么派生类的方法就自动处理成虚函数,它们之间成为覆盖关系（派生类的虚函数表中,本来应该是继承自基类的虚函数地址,但是会被自己写的函数地址覆盖! 覆盖就是说的虚函数表中的覆盖）


## 虚函数代价  

* 1.有函数的类需要一张虚函数表，存储指向虚成员函数的指针，在只读数据区？，增大了类
* 2.带有虚函数的类定义的对象，都会有一个指向虚函数表的指针(32位系统可能占4字节)，增加对象的空间大小  
* 3.虚函数不能再定义成内联函数，因为内联函数在编译阶段进行替换，虚函数的调用处，在编译时都不确定到底调用的是哪一个函数，需要运行时才能去欸的那个，因此虚函数不能是内联函数  

## C语言怎样实现类似C++中的继承和多态  

* C语言的结构体不能定义函数
* C语言一个结构体中，定义另一个结构体的对象即实现继承 
* 关于多态可参见八股文C++篇62


<p id="浮点的比较"></p>

## 浮点数的比较  



## 智能指针  

[智能指针](https://blog.csdn.net/bitcarmanlee/article/details/124847634)  

* shared_ptr可能出现交叉引用(循环引用)问题： 如A类含有指针B类的shared_ptr指针，B类含有指向A类的shared_ptr指针； 在某个作用域内，定义了两个shared_ptr指针分别指向A和B类(A和B在堆区创建，即new出来);此时A类和B类的引用计数都为1；  之后由于内存中存在了A和B，可以给A类和B类中的智能指针赋值赋值完，A和B类的引用计数都成了2； 由于在某作用域创建的shared_ptr指针在栈区，当出了该作用域后，会被释放，此时A和B类的引用技术减1，变成了1，因此A和B在堆上的资源不会被释放，导致内存泄露问题  

* 解决：**对象的定义使用强智能指针shared_ptr;  需要引用对象的地方(如某个类的成员变量)，使用弱智能指针weak_ptr 弱智能指针，不会改变引用计数，但同时注意其没有重载* 和 -> 运算符，因此不能像正常使用普通指针那样使用它**  在使用时，比如A类的某个方法，想使用B类的某个方法，此时不能在A类方法中，直接用weak_ptr的->来调用B类方法，需要借助weak_ptr的lock()方法，将弱智能指针先提升为强智能指针，然后再用（提升可能失败，主要看资源是否还在，一般用在多线程中？）
	* shared_ptr<A> ps = _ptra.lock();  if(ps != nullptr) { ps->testA() }; 

	
## 逗号表达式  
* **逗号表达式的值就是最右边表达式的值**
* int a = (x++, ++y, x + y); 最左边的是表达式1，最右边是表达式n  在执行该语句前，假设x = 10; y = 10 那么a最后等于22
	
* **逗号表示式易错题目** 
* arr[0][1]为2   arr[1][2]为7   arr[2][2]为11 但是如果按照下面代码打印，输出就不对 
* **因为二维数组内部每个元素应该也是一个数组，应该用大括号括起来，而下面用小括号括起来，不会报错，是逗号表达式**  
	* 根据逗号表达式的值就是最右边表达式的值，那么下面的(1,2,3,4)相当于4  也就是实际上是这样写的 int arr[3][4] = {4, 8, 12}; 这样初始化，相当于就是第0行为4，8，12，0 后面的元素都为0  
	* 所以arr[0][1]打印是8   arr[1][2]为0   arr[2][2]为0  
```cpp
int arr[3][4] = {(1,2,3,4), (5,6,7,8), (9,10,11,12)}; 
cout << arr[0][1] << " " << arr[1][2] << " " << arr[2][2] << endl;
```


## 自增和自减  

* 后置的++ 或 --  a++  相当于逗号表达式 (int tmp = a, a = a + 1, tmp)
	* 整个表达式返回的是tmp这个临时量，临时量直接放在CPU寄存器中，没有占用任何内存 相当于一个立即数(如20)，这种立即数不能作为左值(左值一定是在内存中占空间，有名的，能取地址的)  

* 前置的++或--   相当于逗号表达式 ++a 相当于 (a = a + 1, a)	

* 下面的代码，编译直接不通过，就别纠结最后a打印几了  看到后置++，就反应出逗号表达式  
```cpp
int a = 10;
a++ = 11;  // (10, a = a + 1, 10)   这里相当于 10 = 11   后置的++，根据逗号表达式，本质上是一个没有内存的临时量，是个立即数 不能当作左值
cout << a << endl;
```

```cpp
int a = 10;
++a = 11; // (a = 10 + 1, a) 相当于a变成11,再返回a  
```
	
* **注意，面试或笔试中，并不是所有让输出结果的题目都是正确的，有可能估计埋坑**  
* 编译器对长的运算符进行断句，类似贪心，从左向右找一次性能最长的合法的运算符(因此类似+++++这种肯定不存在这样一个运算符)  

* **对于 a+++++b   先断到 a++  然后再继续从左向右，++ 最后一个+b  相当于  a++ ++ +b  （不是自己臆想的 a++ + ++b）**
	* (a++)++ +b    (a++)是一个立即数，不能给它++  这就相当于 10++,编译器肯定要报错的  
* 可以自己断句 中间加空格 如 cout << a++ + ++b << endl;  输出21 最后a和b都是11
	
* 对于++a+++b    ++a++ +b    相当于 ++(a++) + b  编译出错！
	* **知识点：对于++和--这种只要一个变量就可以参与运算的，是从右向左结合的**

* 对于(++a)+++b  (++a)++ + b  a前置++变成11，然后后置++，返回的是11这个立即数，再加b，结果是21  a最后是12 b还是10  

```cpp
int a = 10;
int b = 10;
cout << a+++++b << endl; // 错误的表达式  (a++)++ +b
cout << ++a+++b << endl;
cout << (++a)+++b << endl;
```

## 变量未初始化  
	
* 局部变量未初始化，它的值是不确定的，因为在栈区，而如果某个函数结束出栈的操作，只是移动了栈指针，并没有修改栈的数据(所谓的弹出)  而定义一个局部变量，相当于先在内存中找一个栈内存，然后和这个名字绑定在一起，cpu是不知道变量或者变量名的，它只能从某个地址取数据或者数据写入某个内存； int a = 10; 实际上是编译器做了两步: int a; a = 10;   
* 全局变量，静态变量在全局区，没有初始化
	
* 实际场景中问题：比如在网络编程中，基于poll编写服务器时，会需要一个定义一个 struct polled fds[1024]; 其中的每个元素都是一个结构体，这样仅定义，不初始化的操作也是有风险的，这就是为什么一般在后面可以加for循环遍历并初始化一下的原因； 比如后面有代码判断了fds[i]中某个成员的值是否为xxx，不初始化可能会有问题(本来也要初始化其中的fd这个成员为-1，表示还不需要监听)  


## 结构体与联合体  

* 联合体/共用体 union  ：在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作“共用体”类型结构，简称共用体，也叫联合体。
	
	
### 联合体应用之一：分离数据高低字节  
	
* 现在有一个int型变量，需要它的高16位和低16位；本来可以通过除以16(连续除以4个16也就是65536)得到高16位，对65536取余得到低16位  但是一个除法消耗四个机器周期，取余也不简单  
* 可以直接按下面方式，利用联合体数据覆盖的特点  
	* 当然要注意大小端 这里是小端模式，低地址存低字节，高地址存高字节  
	* 因此，a[0]处于低地址，存储的是n的低字节
	* **一开始联合体中我用的是short int a[2]，这样的话，a[0]和a[1]能表示的范围是 [-32768, 32767]， 如果n = 32768 也就是从低到高第16位为1(2^15)；此时按除法和取余计算是正确的，但是如果用short int a[2]，那么a[0]的二进制最高位是0，相当于负数(对应的十进制变成了-32768)**  使用unsigned short的话，int是负数的时候高字节也容易出错  
	
* 一个char 如果对应int 范围是[-128,127] 	

```cpp
#include <vector>  
#include <iostream>

using namespace std;  
  
union div_union {
    int n; // 四个字节
    a[2];
};


int main()  
{  

    div_union dn;
    dn.n = 65536;
    
    cout << "低字节 = " << dn.n % 65536 << endl 
         << "高字节 = " << dn.n / 65536 << endl; 
    

    cout << "dn.a[0] = " << dn.a[0] << endl 
         << "dn.a[1] = " << dn.a[1] << endl; 

    return 0;  
}   
```

* 输出如下：

```shell
低字节 = 0
高字节 = 1
dn.a[0] = 0
dn.a[1] = 1
```	
	
## 数据高低字节分离  
	
* 当对一个数a进行分离高低位操作的时候，将这个数a除以10，就是把这个数的10进制数进行右移1位，也就是丢掉10进制数最右边的1位数。当然，如果除以1000（10 * 10 * 10），则是把这个数的10进制数右移3位，也就是丢掉10进制数最右边的3位数。
* 当对一个数a进行分离高低位操作的时候，将这个数a除以16，就是把这个数的16进制数进行右移1位，也就是丢掉16进制数最右边的1位数。当然，如果除以256（16 * 16），则是把这个数的16进制数右移2位，也就是丢掉16进制数最右边的2位数。
	
* 当对一个数a进行取余操作的时候，将这个数a%10，就是把这个数的10进制数最右边的1位数保留！当然，如果a%1000（10 * 10 * 10），则是把这个数的10进制数最右边的3位数保留，其他的丢弃。
* 当对一个数a进行取余操作的时候，将这个数a%16，就是把这个数的16进制数最右边的1位数保留！当然，如果a%256（16 * 16），则是把这个数的16进制数最右边的2位数保留，其他的丢弃。
	
[数据高低字节分离-含小数扩展](https://blog.csdn.net/qq_42369840/article/details/125526584)     

<p id="判断大小端"></p>  	

## 判断大小端  
	
[判断大小端](https://blog.csdn.net/zhengnianli/article/details/106684336)  
 	

<p id="判断链表是否有环形、两链表是否相交"></p>    	

## 判断链表是否有环形、两链表是否相交      	
	
[判断链表是否有环形、两链表是否相交](https://blog.csdn.net/qq_38619449/article/details/123834068)  
	

<p id="链接过程"></p>   

## 链接过程  
	
[链接过程](https://blog.csdn.net/kking_edc/article/details/113520111)

[符号与符号表](https://www.likecs.com/show-203357697.html)
	
	
<p id="程序必须从main函数开始吗"></p>    	
		
## 程序必须从main函数开始吗  
	
* 程序从main函数开始理解成说的是用户的应用程序层面，大家约定俗成的，但是从汇编角度，程序入口不是main函数  
* **几条命令** 
	* gcc -E xxx.c -o xxx.i  
	* gcc -S xxx.i -o xxx.s
	* gcc -c xxx.s -o xxx.o
	* gcc xxx.o -o xxx
	* 上面几条语句等同于直接执行  gcc xxx.c -o xx

### readelf -a 可执行文件名  
	* readelf 本身可查看elf格式的文件信息 可用来查看 linux可执行文件，动态库(*.so)、静态库(*.a)等文件信息  

* 下面是查看hello可执行文件的信息  
	* 可发现 程序是小端法  
	* 程序入口地址 0x530  到后面查看可知是标号_start

* _start：设置堆栈、将传入参数压入堆栈、调用__libc_start_main(),它最后会调用main函数 从这里也能看出，入口是能被指定的  

```c
int result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);//这是Unix-like下main函数的调用方式，main函数中形参就是这么由来的
```
* result中放着main函数的返回值，然后带着这个值退出  exit (result);

![image](https://user-images.githubusercontent.com/58176267/180700958-cf5f63e8-f4de-4f58-b2e6-a2ac2721671f.png)  
* 符号表信息  
	* 关于符号表中各条目含义见[链接过程](https://blog.csdn.net/kking_edc/article/details/113520111)   
	* Global symbols（模块内部定义的全局符号） 由模块m定义并能被其他模块引用的符号。例如，非static C函数和非static C全局变量  
	* Local 表示仅由模块m定义和引用的本地符号。例如，在模块m中定义的带static的C函数和全局变量  
	* External symbols（外部定义的全局符号） 由其他模块定义并被模块m引用的全局符号  
![image](https://user-images.githubusercontent.com/58176267/180701391-ee9226a3-a7c6-45b8-827c-7deb92577a0a.png)  
![image](https://user-images.githubusercontent.com/58176267/180701402-7fb2202f-4426-42ee-8893-6527453ea46b.png)  

![image](https://user-images.githubusercontent.com/58176267/180703039-9689dc1b-160a-4eb1-a570-55b734f47216.png)

	
* 将hello.c中main函数修改下名字，会编译报错，提示在_start中引用了未定义的符号main  
* 将main名字改为_start，会出现重复定义错误  编译时使用gcc hello.c  -nostartfiles -o hello  编译不报错 但是根据上面_start最终获取main函数返回值以后，需要exit(result),因此这么做需要将return替换为exit(0); 注意实际中不会这么做这只是演示程序的入口问题  
* gcc test.c -nostartfiles -e xxx -o app   指定xxx为入口地址而不使用_start  

	
### nm 命令  

* nm命令用于将二进制文件或可执行文件进行剖析  
	
[nm命令和其内容详解](https://blog.csdn.net/qq_48322523/article/details/118027964)  


<p id="extern关键字"></p>    	
		
## extern关键字    	
	
* [extern关键字](https://zhuanlan.zhihu.com/p/423263090)  
* [extern关键字](https://blog.csdn.net/fuhanghang/article/details/114831993)	


<p id="volatile关键字"></p>      	
		
## volatile关键字  

[volatile关键字](https://www.runoob.com/w3cnote/c-volatile-keyword.html)
 	
