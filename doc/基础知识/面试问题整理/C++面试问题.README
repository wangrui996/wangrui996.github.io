# C++  


## override 关键字 (C++11 新特性)  

* 用于成员函数声明之后，表示这是个虚函数，并重写了基类里的虚函数
    * 如果父类中函数忘记了加virtual关键字,编译时就会报错
    * 如果重写时，语义和父类中虚函数不同，不如重写的函数多了个const，不希望修改类成员，这样编译时也会报错
    * 如果不加override 关键字，那么上面两种情况编译时都不会报错，运行效果可能就不是我们想要的

[override 关键字](https://blog.csdn.net/whahu1989/article/details/117535968)

## 虚函数  

虚函数实现多态的原理：虚函数表  
* 条件：基类中含有虚函数，派生类重写该虚函数; 基类指针指向派生类对象
* 编译器会为该基类创建一个虚函数表,本质上是个结构体，里面有一个函数指针成员  在基类和派生类的内存模型中(一个struct结构体?),包含一个虚函数表指针,即指向一个虚函数表的实例化对象
    * 其中, 基类的虚函数表指针没有默认值，它不指向一个实例化的虚函数表对象
    * 不同派生类的内存模型中的虚函数表指针指向不同的实例化的虚函数表对象，其中的函数指针指向不同的函数(分别指向自己重写的那个函数)
 
* 程序运行时，因为可能有多个类都有虚函数，每一张虚函数表/vftable都会加载到内存的.rodata区(常量区/只读数据区)、当定义一个含虚函数的类对象时，它的内存模型中不止含有数据成员，还会有一个vfptr，即虚函数表指针   
    * 虚函数表vftable主要包含RTTI指针(指向一个常量区字符串,类名)和虚函数地址(函数指针)、
    * 听一个类定义多个对象，它们的vfptr都是指向同一张虚函数表
    * 一个类中如果有多个虚函数, 和只有一个虚函数,类对象的内存大小是一样的,都是只需要一个虚函数表指针vfptr  但是虚函数表的大小就不同了，因为虚函数表中会存储虚函数的地址，因此多一个虚函数这个虚函数表就会增大




