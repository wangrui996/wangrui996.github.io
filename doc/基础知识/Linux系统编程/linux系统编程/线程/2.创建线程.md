# 2.创建线程  


## pthread_self 函数  

* 功能: 获取线程ID   对应于进程中的getpid()函数   
    * 线程ID用于在进程内部，线程的标识(两个进程间线程ID允许相同)  
    * 使用 ps -Lf 进程号  查看某一进程下的LWP变量表示的是进程号，用于CPU调度。  

![image](https://user-images.githubusercontent.com/58176267/173540262-4e9012ea-c3d2-472c-a853-22f1c5f04922.png)  


## pthread_create 函数  

* 函数原型  

![image](https://user-images.githubusercontent.com/58176267/173611283-da670762-ea58-4114-809f-aecbd799d19f.png)  

* 参数  
    * 指针 thread传出参数  新创建线程ID 
    * attr 设置线程状态  
    * 函数指针(回调函数)  start_routine  
    * 回调函数的参数，一个范型指针   如果不需要参数，传入NULL  
* 返回值 
    * 成功 0 
    * 失败 错误号  
* 编译和链接时需要引入线程库  -pthread  

* 下面例子中，如果没有sleep()  主线程return了子线程还没执行，那主线程结束后，他们所共用的内存地址空间就销毁了，因此子线程也无法执行  

![image](https://user-images.githubusercontent.com/58176267/173614357-0caf0259-76e0-4146-b642-3249f1621dda.png)  

* 输出如下  
    * 可以发现，主线程与子线程的进程ID相同，但是线程ID不同  
    * 注意：这里的线程ID明显与使用 ps -Lf 进程号 查看的该进程的线程号LWP不同(那个号与进程ID结构差不多)  
![image](https://user-images.githubusercontent.com/58176267/173614566-07a960f6-9f2f-4f76-a36e-cbe5ca1d37fe.png)


## 循环创建多个子线程  

* 注意这里，32位系统下，void* 指针占4个字节， int类型占4个字节 强制转换才不会导致数据丢失  64位系统下，void* 指针4个字节，int型8个字节 线程函数中用8字节接收4字节可以，但是主线程中将int强转成void* 不会丢失数据吗？  

![image](https://user-images.githubusercontent.com/58176267/173717454-e617cb6f-70f1-4041-9cfa-9fedccfd30d8.png)  
![image](https://user-images.githubusercontent.com/58176267/173717094-ec5f059d-d0a8-4755-abe7-86e522329e69.png)  

* 输出如下  

![image](https://user-images.githubusercontent.com/58176267/173718336-427171cd-dd7c-448e-aec9-fa518820bdda.png)


 


