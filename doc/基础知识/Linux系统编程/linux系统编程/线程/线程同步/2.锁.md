# 2.锁  


## 互斥量(互斥信号量)  

* 需要注意的是，这个锁属于建议锁，如果每个线程的逻辑都是按照正常来的,数据不会发生混乱,但是线程是可以在其他线程对某一共享资源加锁的情况下访问共享数据的如下图的T3线程
* T3线程没有使用锁,可以不受锁的控制  

![image](https://user-images.githubusercontent.com/58176267/173974443-93c1bcc0-3722-440c-b6ef-6248cb971217.png)  


![image](https://user-images.githubusercontent.com/58176267/173974576-e2a4fc52-74e5-490e-bcdf-248da31095f8.png)


## 示例  

![image](https://user-images.githubusercontent.com/58176267/173975125-e7f0d952-f07a-42a7-8007-fe79c63c6472.png)  

* 主线程和子线程都访问了公共区域 stdout 但是没有同步机制  

![image](https://user-images.githubusercontent.com/58176267/173975329-480a7937-ff97-418b-b254-70d8b2b9093d.png)  


## 互斥锁主要函数  

![image](https://user-images.githubusercontent.com/58176267/173975570-8f3a1806-6b53-482c-a07b-190d31011c6b.png)  


## 使用互斥锁的一般步骤  

![image](https://user-images.githubusercontent.com/58176267/173976173-fb2db1c2-d2eb-457c-a193-acbdc70b5368.png)  

## pthread_mutex_init 与 pthread_mutex_destroy 函数    

![image](https://user-images.githubusercontent.com/58176267/173976269-ba1934f0-a72c-4a3f-9f5f-4a95341555b5.png)  


* 参数
    * 第一个参数是互斥锁结构体pthread_mutex_t类型的指针 mutex  
        * **关键字restrict**: **限定指针  表示由本指针所指向的内存空间的内容操作由本指针完成**
    * 第二个参数  表示锁的属性  默认的话可以用NULL   

* 返回值
    * 成功返回0 
    * 失败返回errno  

* **注意：** **锁能够被主线程和其他线程访问  应该是一个全局锁,应该在全局位置**


## pthread_mutex_lock 与 pthread_mutex_unlock 函数  

* 加锁和解锁用到的参数都是前面定义并初始化的那个结构体指针  

![image](https://user-images.githubusercontent.com/58176267/173977227-5053d06c-af7a-429a-8832-81888301fcb7.png)  

## pthread_mutex_trylock 函数  

* 非阻塞轮询机制  
* 在访问共享数据时尝试拿锁,如果拿不到不阻塞而是继续做自己的其他事情  


## 示例  

* **锁能够被主线程和其他线程访问  应该是一个全局锁,应该在全局位置**  

![image](https://user-images.githubusercontent.com/58176267/173977983-9dfa4162-187b-4877-a928-9c471a666d92.png)    
![image](https://user-images.githubusercontent.com/58176267/173978079-4ebb8a86-4548-4f6e-b639-657c8b956952.png)  
![image](https://user-images.githubusercontent.com/58176267/173977899-cfa9fafa-2cef-48c9-a463-352de3f0ffc7.png)  




