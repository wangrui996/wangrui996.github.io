<p id="系统调用和库函数比较"></p>

# 系统调用和库函数比较——预读入缓输出  


fopen & fgetc & fputc 是库函数，也可以完成文件的打开，读取和写入  
open & read & write是系统调用 

当要对文件进行读写操作时，库函数最终也要借助系统调用进入内核态操作驱动，从这个角度考虑直接使用系统调用效率应该要高一些.但实际上是不是这样呢？  

## 拷贝文件测试  

事先准备一个稍微大一点的文件sfile.txt （为了比较的明显一点，接近30M）


### 利用库函数完成拷贝  

```cpp
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    FILE *fp, *fp_put;
    int n;

    fp = fopen("", "r");
    if(fp == NULL) {
        perror("open file failed");
        exit(1);
    }

    fp_out = fopen("", "w");
    if(fp_out == NULL) {
        perror("open file failed");
        exit(1);
    }

    while((n = fgetc(fp)) != EOF) {
        fputc(n, fp_out);
    }

    fclose(fp);
    fclose(fp_out);

    return 0;
}
```
执行程序后直观上发现是一瞬间完成的，ll查看下拷贝出来的文件大小相同

```shell
-rw-r--r-- 1 wr wr 28365570 3月  21 15:07 dfile.txt
-rw-r--r-- 1 wr wr 28365570 3月  21 15:05 sfile.txt
```

### 利用系统调用完成拷贝  

根据[使用read和write实现cp命令](doc/基础知识/Linux系统编程/linux系统编程/使用read和write实现cp命令#使用read和write实现cp命令)中的实现，为了与fputc一致，修改缓冲区为1字节

```c
#include <unistd.h>  
#include <fcntl.h>   //file control  O_RDONLY等定义  
#include <stdio.h>  //其中包含了perror函数
#include <stdlib.h> //包含了exit函数

//#include <string.h>
#define N 1

int main(int argc, char** argv)
{
	char buf[N];

	int n = 0;

	int fd1 = open("sfile.txt", O_RDONLY); //读源文件
	
	if(fd1 < 0) {
		perror("open file error");
		exit(1);
	}

	//要写入的目标文件，如果文件不存在先创建,如果已经存在就截断为0  注意要创建的话就要指定权限
	int fd2 = open("dfile2.txt", O_RDWR | O_CREAT | O_TRUNC, 0664);
	
    if(fd2 < 0) {
		perror("open file error");
		exit(1);
	}

	//缓冲区大小有限，但我们不知道源文件内容有多大因此需要while循环
	while ((n = read(fd1, buf, N)) != 0) {
		if(n < 0) {
			perror("read error");
			break;
		}
		write(fd2, buf, n);
	}
	//!对应open要注意close
	close(fd1);
	close(fd2); 

	return 0;
}
```
执行程序后发现等待相等长一段时间拷贝才完成  

### 使用strace追踪执行过程  

**strace**命令可以跟踪程序执行时所用的**系统调用**

starce + 可执行程序


1.追踪系统调用使用的拷贝  

```shell
strace ./cp1
```  
下面是截取的部分内容，可以发现确实是读一个字节写一个字节，不断循环  
```shell
read(3, "\214", 1)                      = 1
write(4, "\214", 1)                     = 1
read(3, "\n", 1)                        = 1
write(4, "\n", 1)                       = 1
read(3, "g", 1)                         = 1
write(4, "g", 1)                        = 1
read(3, "f", 1)                         = 1
write(4, "f", 1)                        = 1
read(3, "h", 1)                         = 1
```

2.追踪库函数实现的拷贝  

可以发现，fgetc并不是一次读一个字节，fputc也不是一次写一个字节，两者都是一次进行4096个字节的读或写

```shell
read(3, "\345\222\214\n\345\233\233\346\226\271\347\232\204\345\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240"..., 4096) = 4096
write(4, "\346\240\274\345\222\214\346\255\214\346\231\266\344\275\223\347\256\241\350\220\250\345\234\260\346\226\271\345\233\233\346\226"..., 4096) = 4096
read(3, "\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240\274\345\222\214\346\255\214\346\231\266\344\275\223\347"..., 4096) = 4096
write(4, "\345\222\214\n\345\233\233\346\226\271\347\232\204\345\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240"..., 4096) = 4096
read(3, "\347\254\254\344\270\211\344\270\252\n\345\217\215\345\257\271\345\222\214\n\345\233\233\346\226\271\347\232\204\345\222\214"..., 4096) = 4096
write(4, "\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240\274\345\222\214\346\255\214\346\231\266\344\275\223\347"..., 4096) = 4096
```

##   License

### 使用系统调用的情况

* 用户程序的buf指定为1
* 一次read，相当于从用户程序的buf写进了内核空间，写入1个字节
* 但调用write后并不是直接就将一个字节写入了磁盘，因为这属于IO操作(物理操作)，如果每次将一个字节数据写入磁盘，一个大文件写入将非常慢
* 因此操作系统默认维护了一个缓冲区，称之为系统级缓冲，大小默认4096字节（4KB），因此用户想往磁盘写的内容都会先进入内核的缓冲区，当缓冲区满了以后操作系统才会一次性向磁盘写入  
* 如果使用write系统调用一次向内核缓冲区写入一个字节(我们想直接往磁盘写但内核会等缓冲区满)，会频繁的调用write系统调用，也就是不断从用户态转为内核态，这个过程非常耗时(操作系统的课程学过此时涉及到用户栈内核栈的切换等)，

### 使用库函数情况

* fputc库函数内部有一个缓冲区，大小默认为4096，缓冲区满才会调用write向内核写入，因此可以发现，它相比于直接用write一次写一个字节来说，系统调用的次数是直接用write函数的1/4096
* 操作系统的缓冲向磁盘写入，会涉及到进程的调度等，对用户来说不需要过多关注(但学习操作系统要把这一过程搞明白)  

![image](https://user-images.githubusercontent.com/58176267/159220937-a35e7f7c-20f6-4c4d-89ed-e99af7f1535d.png)

一般把read write函数成为无缓冲区I/O  指的是无用户级缓冲区，相当于上图中蓝色的部分，有的缓冲区是程序中写的buffer，如果将此buffer改为1024，或者4096，速度就会快很多


## 总结  预读入缓输出机制  

* 1.缓输出 就是上面介绍的情况，对于

* 2.预读入 指的是操作系统从磁盘尽可能多的读取数据放在缓冲区，用户尽管用read指定的buffer很小比如10个字节，操作系统可能读取的是4096个字节到内核缓冲区，如果后续再有read操作，内核不需要再从磁盘读  






