<p id="系统调用和库函数比较"></p>

# 系统调用和库函数比较——预读入缓输出  


fopen & fgetc & fputc 是库函数，也可以完成文件的打开，读取和写入  
open & read & write是系统调用 

当要对文件进行读写操作时，库函数最终也要借助系统调用进入内核态操作驱动，从这个角度考虑直接使用系统调用效率应该要高一些.但实际上是不是这样呢？  

## 拷贝文件测试  

事先准备一个稍微大一点的文件sfile.txt （为了比较的明显一点，接近30M）


### 利用库函数完成拷贝  

```cpp
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    FILE *fp, *fp_put;
    int n;

    fp = fopen("", "r");
    if(fp == NULL) {
        perror("open file failed");
        exit(1);
    }

    fp_out = fopen("", "w");
    if(fp_out == NULL) {
        perror("open file failed");
        exit(1);
    }

    while((n = fgetc(fp)) != EOF) {
        fputc(n, fp_out);
    }

    fclose(fp);
    fclose(fp_out);

    return 0;
}
```
执行程序后直观上发现是一瞬间完成的，ll查看下拷贝出来的文件大小相同

```shell
-rw-r--r-- 1 wr wr 28365570 3月  21 15:07 dfile.txt
-rw-r--r-- 1 wr wr 28365570 3月  21 15:05 sfile.txt
```

### 利用系统调用完成拷贝  

根据[使用read和write实现cp命令](doc/基础知识/Linux系统编程/linux系统编程/使用read和write实现cp命令#使用read和write实现cp命令)中的实现，为了与fputc一致，修改缓冲区为1字节

```c
#include <unistd.h>  
#include <fcntl.h>   //file control  O_RDONLY等定义  
#include <stdio.h>  //其中包含了perror函数
#include <stdlib.h> //包含了exit函数

//#include <string.h>
#define N 1

int main(int argc, char** argv)
{
	char buf[N];

	int n = 0;

	int fd1 = open("sfile.txt", O_RDONLY); //读源文件
	
	if(fd1 < 0) {
		perror("open file error");
		exit(1);
	}

	//要写入的目标文件，如果文件不存在先创建,如果已经存在就截断为0  注意要创建的话就要指定权限
	int fd2 = open("dfile2.txt", O_RDWR | O_CREAT | O_TRUNC, 0664);
	
    if(fd2 < 0) {
		perror("open file error");
		exit(1);
	}

	//缓冲区大小有限，但我们不知道源文件内容有多大因此需要while循环
	while ((n = read(fd1, buf, N)) != 0) {
		if(n < 0) {
			perror("read error");
			break;
		}
		write(fd2, buf, n);
	}
	//!对应open要注意close
	close(fd1);
	close(fd2); 

	return 0;
}
```
执行程序后发现等待相等长一段时间拷贝才完成  

### 使用strace追踪执行过程  

**strace**命令可以跟踪程序执行时所用的**系统调用**

starce + 可执行程序


1.追踪系统调用使用的拷贝  

```shell
strace ./cp1
```  
下面是截取的部分内容，可以发现确实是读一个字节写一个字节，不断循环  
```shell
read(3, "\214", 1)                      = 1
write(4, "\214", 1)                     = 1
read(3, "\n", 1)                        = 1
write(4, "\n", 1)                       = 1
read(3, "g", 1)                         = 1
write(4, "g", 1)                        = 1
read(3, "f", 1)                         = 1
write(4, "f", 1)                        = 1
read(3, "h", 1)                         = 1
```

2.追踪库函数实现的拷贝  

可以发现，fgetc并不是一次读一个字节，fputc也不是一次写一个字节，两者都是一次进行4096个字节的读或写

```shell
read(3, "\345\222\214\n\345\233\233\346\226\271\347\232\204\345\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240"..., 4096) = 4096
write(4, "\346\240\274\345\222\214\346\255\214\346\231\266\344\275\223\347\256\241\350\220\250\345\234\260\346\226\271\345\233\233\346\226"..., 4096) = 4096
read(3, "\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240\274\345\222\214\346\255\214\346\231\266\344\275\223\347"..., 4096) = 4096
write(4, "\345\222\214\n\345\233\233\346\226\271\347\232\204\345\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240"..., 4096) = 4096
read(3, "\347\254\254\344\270\211\344\270\252\n\345\217\215\345\257\271\345\222\214\n\345\233\233\346\226\271\347\232\204\345\222\214"..., 4096) = 4096
write(4, "\222\214\ngf\345\222\214\ngfhj\351\243\216\346\240\274\345\222\214\346\255\214\346\231\266\344\275\223\347"..., 4096) = 4096
```

##   License

