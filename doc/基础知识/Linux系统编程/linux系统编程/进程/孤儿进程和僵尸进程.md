

# 孤儿进程和僵尸进程  


## 孤儿进程  

**孤儿进程：** 父进程先于子进终止，子进程成为“孤儿进程”  
    * 因为一般情况下一个进程都是被它的父进程创建的

* 子进程的父进程会变成init进程，称为init进程领养孤儿进程（init进程 “进程孤儿院”），init进程接替原来的父进程来管理子进程，主要是完成进程的回收，一个进程死亡后应该由它的父进程来回收，所以孤儿进程被init领养后，init负责这个事

** ps ajx  打印进程信息，同时还会显示每个进程的PPID(父进程id)， PID, PGID（进程组id）, SID    

### 孤儿进程demo  

* 如下图demo，子进程被创建后，会循环执行打印的函数  
* 父进程创建完子进程，打印一句话后，sleep 9s后程序执行结束，父进程就无了


* 程序执行后终端打印的信息，子进程输出自己父进程id，会发现一开始是一个id，父进程无了以后又是另一个id
* 执行程序，并另外打开终端，输入ps ajx 查看进程和父进程id  会发现子进程被init进程领养  

![image](https://user-images.githubusercontent.com/58176267/161434155-d5f3709e-151e-47ed-a5ca-71d0903802ad.png)


## 僵尸进程  

**僵尸进程：** 子进程终止，父进程尚未对子进程进行回收，子进程残留资源(PCB)存放在内核中，变成僵尸(Zombie)进程   
* 子进程终止后，用户空间的内容默认由操作系统帮忙回收，PCB会留在内存中，里面会记录进程死亡的原因，由自己的父进程回收
* 也就是，一个进程终止后，不管是创建自己的父进程还是init进程，还没回收自己之前的这个阶段，进程变为僵尸态
* 理论上每个进程都会经历僵尸态，因为进程终止到父进程回收之间一定有个时间段  

### 僵尸进程demo  

* 子进程创建后sleep几秒就终止  父进程执行while循环（如果父进程died，子进程会进进程孤儿院由init负责在它终止时回收），但是这里父进程没有died，子进程执行一会儿后died

![image](https://user-images.githubusercontent.com/58176267/161435007-058f87c8-59c2-40ef-a296-a1d8c15a04b4.png)

* 子进程结束前，父子进程状态都是正常的 如下图  父进程id 3464  子进程id 3465

![image](https://user-images.githubusercontent.com/58176267/161435158-d7dc6cdb-bef9-47c0-9db2-e971625ad095.png)

* 子进程终止后  父进程正常，子进程名字加上了[] 表示死了 后面 <defunct> 也表示死亡  这种状态表示该进程是一个僵尸进程(已死但还没被回收)  

![image](https://user-images.githubusercontent.com/58176267/161435237-0857b12d-e7d0-4a89-b017-3384c267bcd9.png)

* **kill -9 子进程id  可以杀死一个进程，但是僵尸进程用kill命令是无效的，因为本身就是死亡的**  

**僵尸进程的处理：** **杀死它的父进程，之后子进程的父进程变为init进程，然后init发现它是一个僵尸进程回对它进行回收**   


### Kill命令  

上面那个例子中，子进程会一直打印内容到终端，使用ctrl+c无法终止，因为父进程执行时发会把父进程终止，但父进程终止后，往终端输入指令是bash接收，子进程在后台执行收不到该指令，此时可用kill指令将子进程终止  

* 使用ps aux 或 ps ajx 子进程id假设为xxx  则使用 kill -9 xxxx 终止子进程  
* 注意，如果父进程名字叫a.out，在父进程中创建的子进程也会叫a.out?












