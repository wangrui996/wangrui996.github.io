

# 进程回收  


## wait函数 回收子进程)  

* 子进程终止后，假设它的父进程没有终止，需要对它资源(残留的PCB控制块，用户资源默认被操作系统回收)进行回收，就要利用wait函数(或waitpid)   
    * 残留的资源是PCB，里面含有进程退出的值，从而可以分析它退出的原因等  

**wait函数功能**  

* 1.阻塞等待子进程退出  一旦调用，就等待子进程终止然后回收它，否则就一直阻塞
* 2.回收子进程残留在内核的PCB资源
* 3.获取子进程结束状态(退出原因)  

**函数原型**  

man 2 wait

```c
pid_t wait(int *status)
```

参数：  

* status: 传出参数  回收进程的状态  

返回值：

* 成功，子进程的id 
* 失败， -1，并设置errno

### wait函数 demo  

下面的程序中，父进程创建完子进程后会和子进程争夺CPU的使用权，但是调用wait函数后，子进程如果还没终止，父进程就会阻塞，然后一直等待子进程死亡

![image](https://user-images.githubusercontent.com/58176267/161559290-a50047cf-e32a-4667-a6b8-d8fa4e64b786.png)

程序运行如下  

![image](https://user-images.githubusercontent.com/58176267/161559418-64cb3fe2-5f20-43e1-92b5-2daf9bcd206e.png)


## 获取子进程退出值或异常终止信号    

通过操作系统提供的宏函数实现，把status作为宏函数参数传入  

* WIFEXITED(status) --》 为真(表示正常退出) --》调用 WEXITSTATUS(status) --》 得到 子进程 退出值。
    * 例如，子进程最后 return 100； 正常退出的话， WEXITSTATUS(status)的值就是100；

如果子进程不是正常退出，获取导致子进程异常终止信号

* WIFSIGNALED(status) --》 为真 --》调用 WTERMSIG(status) --》 得到 导致子进程异常终止的信号编号
    * 如，使用kill -10 子进程id    WTERMSIG(status)的值就是10  表示子进程被编号10的信号终止
    * 一个程序，所有的异常终止的情况，都是由于信号  如ctrl c终止进程   
    * **终端输入 kill l (list) 可以看到所有异常信号编号和它对应的含义  如11对应的是段错误**

![image](https://user-images.githubusercontent.com/58176267/161562451-d8c7a78f-bb05-41cb-be88-aa027920b97b.png)

* 查看man手册，还有其他的宏函数，可以判断进程是挂起(不是终止)可以判断它是被哪个信号挂起的等，其他不需要重点掌握  


## wait/waitpid函数  和  子进程终止信息 总结

    一个进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB 还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出值，如果是异常终止则保存着导致该进程
终止的信号是哪个。这个进程的父进程可以调用 wait 或者 waitpid 获取这些信息，然后彻底清除掉这个进程。  **如果不关心子进程的终止信息，则status传入一个空指针即可**
   一个进程的退出状态可以在 shell 中用特殊变量$？查看，因为 shell 是它的父进程，当它终止时，shell 调用 wait 或者 waitpid 得到它的退出状态，同时彻底清除掉这个进程

## waitpid函数  

waitpid 函数： 指定某一个进程进行回收。可以设置非阻塞。  

**函数原型**  

```c
pid_t waitpid(pid_t pid, int *status, int options)
```
**参数：**

* pid：指定回收某一个子进程的pid来回收 
    * 大于0: 待回收的子进程 pid
    * -1：任意一个子进程(这样就和使用wait一样了)
    * 0： 回收和当前调用waitpid同组的所有子进程   进程组 默认情况下，父进程创建的子进程都和父进程处于同一进程组(进程组id叫gid，和父进程id相同) 也可以用方式分离出去，分离出去的就不会回收(如果是-1，分离出去的子进程也会回收) 
    * < -1  : 回收指定进程组内的任意子进程(将进程组号取反)  
        * 例如 父进程id 1000 子进程1001，1002，1003，1004 ，这一组进程的进程组id是1000，假设1003分离出去了，进程组id是1003，然后又创建了子进程1005，1006； 
        * 这种情况，在父进程中调用waitpid，这个参数如果是1002，就会回收1002; 如果是-1，就会回收任意一个子进程; 如果是0,会回收1001，1002，1004; 如果想回收1003进程组的所有进程，传入-1003
        * 也就是说如果是个小于-1的负数表示是个进程组  
        
* status：（传出参数） 回收进程的状态。
* options：  **该参数如果设置为 WNOHANG 则指定回收方式为，非阻塞    该参数为0 表示是阻塞回收  也就是会在这一直阻塞等待要回收的子进程结束然后回收**  


**返回值 pid_t类型**

* 大于0的值 : 成功回收的子进程 pid
* -1:  失败   设置errno
* 0 :  函数调用时， 参数 3 指定了 WNOHANG， 并且，没有子进程结束，返回0 (不阻塞)


**注意**： **一次wait/waitpid函数只能回收一个子进程; 假如父进程在调用wait函数前产生了多个子进程，会随机回收其中一个子进程**


## waitpid回收多个子进程  

不管是wait还是waitpid，一次调用只能回收一个子进程，想回收多个，用while循环  

下面这个demo   
* for循环创建了5个子进程，子进程被创建完后，由于返回值为0接着执行break，因此子进程不会再创建其他子进程，而是退出for循环，执行后面的语句，并且每一个子进程，执行后面的语句时，对应的i不同，分别对应0，1，2，3，4；因为父进程创建子进程时修改的i，和子进程中i不同  
* 代码下半部分，父进程会执行i==5的语句，其他子进程会执行else的语句  

* 使用阻塞回收，比较简单，while判断条件中回收，并判断返回值，如果返回值是一个大于0的，则表示可能还有进程需要回收，就再执行； 什么时候所有子进程都回收了，返回值是-1，也会一直循环，只不过一直打印-1(之后每次调用waitpid都是返回-1)  
* 使用非阻塞回收，回收时如果子进程还没结束，会返回0，因此不能用返回值做条件，应该判断，只要不是-1就仍然继续循环。循环中可以价格判断，如果刚才正确回收了一个(返回值大于0)就打印回收的子进程id并接着回收；如果刚才没有回收成功，比如此时如果没有子进程结束就会返回0(如果返回值是0，就先sleep 1s再回收)


![image](https://user-images.githubusercontent.com/58176267/161578435-3a20dbf9-b85f-4f05-a521-0d7ea8f23c01.png)


## 进程回收总结  

* waitpid(-1, &status, 0) 等价于 wait(&status)








