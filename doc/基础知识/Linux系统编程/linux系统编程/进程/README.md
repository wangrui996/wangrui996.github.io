


# Linux系统编程————进程  


* 并发  
    * 操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。 但是任一时间点上仍只有一个进程在运行  

 
## CPU和MMU

* 存储介质中，越下面的层存储量越大，传输速度越慢  

* CPU内部除了ALU(算数逻辑单元)外，**还有MMU————虚拟内存映射单元**
 
 ![image](https://user-images.githubusercontent.com/58176267/160360105-63fa3523-2a83-4371-a214-441cc236e71c.png)


## 虚拟内存和物理内存映射关系  

* 假设32位cpu, 一个可执行程序运行后，也就是一个进程会拥有0-4g内存空间，其中0-3G是用户数据，3-4G是内核区  
* 但是注意这个0-4G内存空间是虚拟内存空间，是因为32位CPU，最大的寻址范围是4G，是最大的可用范围是4G，而不是实际就是用4G  因为这样的话加入内存只有4G，岂不是只能允许一个进程执行

* 假设用户区的代码段有一个int a = 10，位于8000处, 但是程序实际运行，必须要放到物理内存，也就是虚拟地址和物理地址之间要有个映射，MMU就是完成这一功能的单元  

* 内存一Page是4K，（MMU当初设计时大小为4KB）

* 两个的进程的代码段，全局变量等数据，通过MMU映射到了不同物理地址  
* **两个进程的内核区，是映射到同一块物理地址，内核就是操作系统部分，不同进程的PCB都在同一块物理内存  也就是进程的内核空间是共享的，操作系统只有一份，这也是进程间通信的基础**  

* MMU除了完成虚拟地址到物理地址的映射，还可以修改访问级别   进程可以运行在用户态和内核态，但是内存本身是没有分区分块的  CPU中的MMU会将内存分级，linux下主要是0和3级，如果MMU做映射时，如果映射给用户空间，就设置为3级，如果映射给内核空间，设置为0级    所谓的从用户空间进入内核空间, 是通过MMU修改权限完成的

![image](https://user-images.githubusercontent.com/58176267/160364862-ba19b5dc-568b-4b71-a0bb-79292748467c.png)



## PCB进程控制块  

每个进程都有一个进程控制块(PCB)来维护进程信息，linux下是task_struct结构体    

/usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看其定义 

task_struct结构体：
{
    进程 id ： 每个进程有一个唯一id C语言中用 pid_t 类型表示 本质是个非负整数

    进程状态： 就绪态(与初始化=态合并为一种状态)、运行态、挂起态(阻塞态，等待除cpu以外的其他资源主动放弃cpu)、终止态(停止态)  

    进程切换时需要保存和恢复的一些cpu寄存器
    
    描述虚拟地址空间的信息
    
    描述控制终端的信息(比如进程是否要占用终端)
    
    当前工作目录位置 （进程工作目录位置，比如在终端输入ls  cd.. 等，都可以改变shell进程的工作目录，因此shell进程需要记录这个工作目录）
    
    umask 掩码 （进程的概念）
    
    文件描述符表，包含很多指向file结构体的指针
   
    与信号相关的信息
    
    用户 id 和组 id
    
    会话(Session)和进程组
    
    进程可以使用的资源上限
}

px aux 查看所有进程 其中包含id     







