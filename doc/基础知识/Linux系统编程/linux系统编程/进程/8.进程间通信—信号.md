

# 8.进程间通信—信号  

* 信号的特点  
    * 简单、不能携带大量信息、满足条件才发送  

    * 信号是软件层面上的“中断” (通常所说的中断是硬件帮助实现)。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。

* **所有信号的产生及处理全部都是由内核完成的**

## 信号的概念  

* **产生信号的方式**
    * 1.按键产生
        * 如 Crtl+c   Crtl+z（暂停，程序跑到后台，可以使用fg恢复）    Crtl+\ (终止进程，与Crtl+c效果相同但不是同一个信号)
    * 2.系统调用产生
        * 如kill   raise  abort
    * 3.软件条件产生
        * 定时器 alarm （sleep就是利用定时器实现的） 
    * 4.硬件异常产生
        * 非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)  
    * 5.命令产生  
        * 如kill命令 

* **递达** ： 信号在内核产生并且送达到进程，就叫这个信号递达(递送到达)    直接被内核处理掉
    * 可以认为信号一旦被递达，就会被处理 

* **未决** ： 产生与递达之间状态（可以认为信号一旦被递达，就会被处理）   主要由于阻塞(屏蔽)导致该状态  

* **信号处理方式**
    * 1.执行默认处理动作  每个信号都有他自己的处理动作 
        * Term ： 终止进程
        * Ign  ： 忽略信号(默认即时对该信号忽略操作，注意与信号的第2点处理方式是忽略，这里是说它的处理动作是忽略的)
        * Core ： 终止进程 生成Core文件  （查验进程死亡原因，用于gdb调试）
        * Stop ： 停止(暂停) 
        * Cont ： 继续运行进程  
    * 2.忽略  信号已经递达，内核处理它的方式是选择忽略     而未决是信号没到，所以内核无法处理  
    * 3.捕捉（自定义)  正常是每个信号都有默认的处理动作，捕捉就是捕捉一个信号，然后自定义处理方式  

* **阻塞信号集（信号屏蔽字）**：将某些信号加入集合，对他们设置屏蔽，当屏蔽某信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)   也就是信号的阻塞看这个信号集
    * 本质：位图  用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态

* **未决信号集**：
    * 1.信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态，当信号被处理后对应的为翻转为0， 这一时刻往往非常短暂   
    * 2.信号产生后，由于某些原因(主要是阻塞)不能递达； 这类信号的集合称之为未决信号集。 在屏蔽解除前，信号一直处于未决状态  
    * 本质：位图。用来记录信号的处理状态。该信号集中的信号，表示，已经产生，但尚未被处理。

* 阻塞信号集和未决信号集都在进程的PCB中  

* 如下图例子  
    * 当按键按下  Crtl+c后，未决信号集中对应位(2)置1， 对应的信号屏蔽字为0(默认都是0，说明没被阻塞)，内核会马上对其进行处理(上面提到了三种)，处理好后，内核负责把未决信号集对应位置0，这就完成了信号的产生和使用过程
    * 假如上面这个信号产生以后，由于某种原因，将其设置为屏蔽，信号屏蔽字对应位设置为1，表示其被阻塞，信号不能地递达，就不能处理，因此一直处于未决状态  需要等信号屏蔽字修改，解除屏蔽后，才能处理该信号，未决信号集对应位才可能翻转为0  

![image](https://user-images.githubusercontent.com/58176267/162742147-00d64f6e-424f-4d98-babb-55752badeba7.png)


## 信号四要素和常规信号一览  

* 终端使用 kill -l  列出当前系统中支持的信号
* 1-31号为常规信号(普通信号)
* 34-64为实时信号   
* 所有的常规信号，都要它对应的默认事件和处理动作  
* 实时信号没有默认事件，在应用程序开发时基本不用，底层驱动开发时可能会用到  

### 信号四要素  

* **信号四要素**    每提到一个信号，都要知道它的四要素     （变量三要素  变量类型 变量名 变量值）  、
   * **编号**
   * **名称**
   * **对应事件**
   * **默认处理动作**  

* **最后两个要格外注意，使用一个信号之前，应该先确定它的四要素，再使用**

* **使用 man 7 signal 查看手册**
    * 注意到有的信号的值(编号)不止一个，意味着在不同类型的机器上值不同，如中间的一个值是x86，arm和其他架构的芯片上用的   使用kill -l查看看到的编号就是在自己机器上的编号  
    * 写信号的时候，用宏就不会出错  

* 注意，9号(SIGKILL)和19号(SIGSTOP,暂停，不是终止), 不能被阻塞，忽略  相当于操作系统为自己保留的终止或暂停进程的有效方式，比如一个进程是个病毒，但是它把SIGKILL信号设置为阻塞，将不能被该信号杀死  
* 10号和12号是用户自定义信号，但注意处理动作是默认的，都是终止进程，自定义的是信号的事件
* 11号SIGSEGV(段错误)，默认动作是终止进程并产生core文件，gdb调试能找到代码中哪一行出现段错误，实际上就是通过的core文件  
* 13号SIGPIPE  前面提到， 向一个没有读端的管道写数据，进程会被终止，就是被这个信号终止  
* 14号 定时器  
* kill pid  进程收到的是15号进程，被杀死    与SIGKILL不同，这个15号信号可以被阻塞和终止  使用kill -9 杀死一个进程更稳妥些
* 17号 SIGCHLD 子进程状态变化(暂停，挂起，阻塞，终止)，内核会通过该信号通知它的父进程  默认动作是**忽略**这个信号

* **注意：每个信号对应的事件发生了，该信号才会被递送（不一定递达），因此不能乱发信号！！ 自己想发时可以使用10号和12号完成发信号的需求**

![image](https://user-images.githubusercontent.com/58176267/162745790-da86338f-556f-4911-8471-fa65af04ab3c.png)

![image](https://user-images.githubusercontent.com/58176267/162745490-71b70b6c-ca72-476c-8c47-13b170ecc75e.png)


## kill函数和kill命令  















