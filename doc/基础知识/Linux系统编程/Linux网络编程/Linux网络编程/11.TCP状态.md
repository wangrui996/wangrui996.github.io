# 11.TCP状态  


## TCO主动发起连接和主动关闭连接方的状态  

##  netstat 命令 查看网络状态 (net state)

* 启动服务器进程  
* 打开客户端  

* netstat -apn | grep client  过滤下，查看客户端的状态  

* netstat -apn | grep 端口号  查看某个端口号的网络状态  
    * 可以发现，当服务器与客户端进程都执行以后，双方状态是 ESTABLISHED  服务器还有一个处于LISTEN状态  
    * 在这里主动发起连接方是客户端，状态图中的 SYN_SENT，如果网络畅通，不容易观察到这个状态  

![image](https://user-images.githubusercontent.com/58176267/178522761-18e43322-72a9-4724-ab33-435ee8fe58f0.png)

* **四次挥手**
    * 主动发起方 发送FIN标志位  另一端回复ACK  此时主动方进入**半关闭状态**     
    * 对于下图，FIN_WAIT2相当于就是半关闭状态  
    * 主动方接收到另一端的FIN，并且成功发送ACK后，进入TIME_WAIT状态  
    * 主动方在TIME_WAIT状态时，并没有真正关闭，还需要等待2MSL，主要是防止自己的ACK没有被另一端收到，导致重发FIN，如果等待这段时间又收到FIN，可以重发ACK  
        * 2MSL大约40s？ 过了这个时间，就可以确认被动方收到了自己的ACK  

![image](https://user-images.githubusercontent.com/58176267/178525285-ba7463cc-4cd5-49f0-8f5e-b894ae443cbc.png)  


![image](https://user-images.githubusercontent.com/58176267/178525635-a5a9565d-4f4c-465d-82fc-8761ea463c2c.png)  


* 启动服务器和客户端，然后终止客户端进程  
* 下面TIME_WAIT状态是客户端  也就是主动关闭连接一方，会经历该状态  

![image](https://user-images.githubusercontent.com/58176267/178527187-7e6f314f-d7cd-4003-b4fe-d8a03c6a3f8c.png)


* 注意，如果先关闭客户端，再关闭服务器，此时客户端在短期内是TIME_WAIT状态  此时再次重启服务器是可以的  
* 如果先关闭服务器再关闭客户端，然后再接着启动服务器就报错：bind error:Address already in use  因为此时服务器处于TIME_WAIT,对应的程序里面设置的8000这个端口号还在使用，再次启动时bind函数仍然绑定8000，就报错  


## TCP被动接收连接方和被动关闭连接方状态  

### TCP 被动接收连接  

* 进服务器进程启动，进入LISTEN状态监听，等待对端发送SYN，收到SYN并回复SYN和ACK以后，变为SYN_RCVD状态；等收到主动建立连接方的ACK后，变为ESTABLISHED状态  

### TCP 被动关闭连接  

* 收到主动关闭连接方的FIN，并且自己回复ACK以后，进入CLOSE_WAIT状态(此时主动关闭端如果收到了ACK ,就进入半关闭状态)
* 被动关闭方发送FIN标志位(对程序来说就是被动关闭方调用close)，进入 LAST_ACK 状态(等待对端的ACK，如果没收到会一直发FIN)，假如对端发送了ACK并且自己收到了，就CLOSE状态  





