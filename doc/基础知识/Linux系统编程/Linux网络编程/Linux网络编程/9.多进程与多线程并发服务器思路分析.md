# 9.多进程并发服务器思路分析  



## 回顾 wait 和 waitpid 回收子进程  

![image](https://user-images.githubusercontent.com/58176267/177446395-ca57b949-f9a1-4ea6-8a50-511d50505cbc.png)  


![image](https://user-images.githubusercontent.com/58176267/177446226-48ac1faf-6763-4249-8453-d03f7e16bd3d.png)  

## 服务器端  

* 子进程只需要使用accept函数返回的文件描述符 cfd，因此accept成功返回后，就创建一个子进程，然后在子进程中，关闭监听套接字 lfd ，之后读写数据  
* 父进程中，不需要使用cfd，因此关闭； 另外，之后直接continue继续监听新的连接即可   
* 但是注意：由于父进程一直在while循环中不断监听建立新连接，如果不回收子进程的话，子进程会变成僵尸进程  



* 由于不止要回收一个子进程，父进程需要使用while循环回收，按照下面写法，使用waitpid，第一个参数为0表示回收当前进程组的子进程(一次调用只能回收一个)  第三个参数 WNOHANG 表示不挂起  
* 指定为非阻塞回收必须用循环机制，当前回收失败，那等会儿还需要继续回收  
* 但是按照下面下法，父进程一直在循环回收子进程，假如没有回收完之前，又有新客户端想建立连接，由于父进程无法执行accept，是无法进行连接的  

![image](https://user-images.githubusercontent.com/58176267/177448439-64c32f6e-da1c-46e0-93af-107d458a3378.png)

* 改成wait回收，阻塞回收，后面代码更没机会执行了  

* **因此通过信号捕捉子进程的方式**
    * 注册信号捕捉函数 SIGCHLD   
    * 在回调函数中，完成子进程回收  



## 多线程并发服务器思路分析  

* 不管是多进程还是多线程并发服务器的实现，客户端代码基本一致  
* 子线程也需要回收，如果使用pthread_join函数，会阻塞回收，因此可以使用pthread_detach分离子线程  
* 如果需要回收子线程退出值，子线程函数中可使用pthread_exit((void*)10)返回退出值，主线程此时必须用pthread_join(tid, void**)接收
* 如果需求就是要回收子线程状态，直接在主线程用pthread_join(tid, void**)会阻塞主线程，信号又不适合在多线程中混着用, **此时可以再创建一个新的线程，专门用于回收子线程(兄弟线程之间可以相互回收，join意味着合并，回收一个子线程相当于把自己和要回收的线程合并了)**  但兄弟进程之间不能相互回收，爷爷进程不能回收孙子进程，因此才有信号捕捉机制  










