# 1.阻塞非阻塞、同步和异步  


* 这里主要针对网络I/O的解释  实际上磁盘的IO、网络I/O都有两个阶段  

* **典型的一次I/O有两个阶段： 数据就绪(准备) 和 数据读写  

* **数据就绪： 例如，作为服务器要监听客户端有无数据过来，这是数据就绪状态(数据准备状态)    
    * 
    * 阻塞： 当数据还没有到达之前，调用操作I/O的函数，如果还没有数据到达，就处于阻塞的状态，线程就会挂起，不再占用CPU资源；
    * 非阻塞：数据没有达到，不会处于阻塞状态，不会被挂起   此种情况，一般通过返回值判断对方状态(是有数据发送过来还是没有数据)；

## recv 系统调用  

* sockfd在内核对应有TCP接收缓冲区，当对方已经有数据发过来(到了接收缓冲区)，再调用recv时不会阻塞，反之，数据没有到达，先调用

* 返回值
    * 读到的数据的大小 

![image](https://user-images.githubusercontent.com/58176267/179402408-d23086a4-6cc5-44ea-86cd-e65cc4a507c8.png)  


* **数据读写：数据过来了，也就到了TCP的读缓冲区，此时数据在内核中，此时怎样去读或写，这是数据读写状态  


## 阻塞和非阻塞  


## 同步与异步  

### I/O同步：

*  调用网络I/O接口时，当数据准备好以后(如在TCP接收缓冲区中)，数据的读写是应用层自己读写的，耗时主要耗费在应用程序这里比如recv，当数据还没有从TCP接收缓冲区"搬到"用户buf之前，没法执行后面的程序  
    * 比如自己买了一张机票，现在机票在机场准备好了，自己打车到机场取回家，这个过程耗费的是自己的时间  

### 异步I/O：  

* 自己买了一张机票，现在机票在机场准备好了，机场派人根据自己事先留下的地址送到了门口，自己只需要开门就能拿到机票  

* 异步要看操作系统有没有给自己提供异步IO接口：把socket的fd、自己放数据的buf、通知方式通过接口告知操作系统，应用程序即可执行其它操作，当内核有数据到达(TCP接收缓冲区有数据)，内核把数据放到buf，这个过程由内核完成，用户程序自己仍然在做其它事情; 内核通知应用程序：如sigio信号  
  
![image](https://user-images.githubusercontent.com/58176267/179983305-9c252895-acfc-4019-9e67-596fa2ce1f93.png)  



* **在处理IO的时候，阻塞和非阻塞都是同步IO(read，recv等, 不管是阻塞还是非阻塞的方式读写，都是用户程序自己操作数据，自己从缓冲区读到buf，写数据到写缓冲区)， 只有使用了特殊的API才是异步IO**  

* 异步一般是配合非阻塞去使用，否则调用了异步接口但是又阻塞在这里，程序还是不能继续往下执行，效率没有得到提高  
    
* Linux中的异步IO接口  
    * aio_read    
    * aio_write   

* 使用异步IO接口非常复杂，将来还要捕捉信号，处理等  尤其在多线程中使用信号往往会产生意想不到的问题  

## aio_read  

![image](https://user-images.githubusercontent.com/58176267/179985287-d0487c7f-ba58-4ef4-ab9a-36cb25f2deca.png)  

![image](https://user-images.githubusercontent.com/58176267/179985387-5cdd8465-32fc-4c1b-8cf4-38789104fde8.png)  








