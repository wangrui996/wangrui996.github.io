# 3.socket模型创建流程图  

![image](https://user-images.githubusercontent.com/58176267/175502254-6bb7c72a-36ee-43a3-80e6-57825a830b23.png)  

![image](https://user-images.githubusercontent.com/58176267/175500299-5da5cf1a-fc1b-4d3e-a2f9-8e182cefe348.png)  

## sockaddr 数据结构  

![image](https://user-images.githubusercontent.com/58176267/175500459-19a10b2a-1fb2-4ea0-a345-7fbdd7f1e56a.png)  


* struct aockaddr_in 中的in表示internet  
* struct sockaddr中的14字节地址数据  在 struct aockaddr_in 结构体中表示为16位端口号 32位IP地址 8字节填充    大小没变 因此在IPv4中就可以用这个数据结构  
* 类似的 struct aockaddr_un 表示进程间通信 本地套接字用的 struct aockaddr_in6 是IPv6用的

![image](https://user-images.githubusercontent.com/58176267/175500894-9343fc9b-d60b-494a-9c7f-7a713678318e.png)  


* 在本页内容最开始的bind函数中可以看出,以及socket模型创建流程图中的其他很多函数（listen等）,它们的诞生早于IPv4这些协议，函数接口设计好了，用的是sockaddr这个结构体, 但实际定义时需要定义struct aockaddr_in类型的变量,类型不对应,使用强转  

```c
struct sockaddr_in addr;
bind(fd, (struct sockaddr *)&addr, size);
```

## struct sockaddr_in 数据结构  

* 使用 man 7 ip 查看该结构  

![{2}J(FYH~W8}6J C)E( Q61](https://user-images.githubusercontent.com/58176267/175503613-a1a9e930-057e-46c2-8c25-b90f51700d7d.png)  


