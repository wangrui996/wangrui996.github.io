# 3.socket模型创建流程图  

![image](https://user-images.githubusercontent.com/58176267/175502254-6bb7c72a-36ee-43a3-80e6-57825a830b23.png)  

![image](https://user-images.githubusercontent.com/58176267/175500299-5da5cf1a-fc1b-4d3e-a2f9-8e182cefe348.png)  

## sockaddr 数据结构  

![image](https://user-images.githubusercontent.com/58176267/175500459-19a10b2a-1fb2-4ea0-a345-7fbdd7f1e56a.png)  


* struct aockaddr_in 中的in表示internet  
* struct sockaddr中的14字节地址数据  在 struct aockaddr_in 结构体中表示为16位端口号 32位IP地址 8字节填充    大小没变 因此在IPv4中就可以用这个数据结构  
* 类似的 struct aockaddr_un 表示进程间通信 本地套接字用的 struct aockaddr_in6 是IPv6用的

![image](https://user-images.githubusercontent.com/58176267/175500894-9343fc9b-d60b-494a-9c7f-7a713678318e.png)  


* 在本页内容最开始的bind函数中可以看出,以及socket模型创建流程图中的其他很多函数（listen等）,它们的诞生早于IPv4这些协议，函数接口设计好了，用的是sockaddr这个结构体, 但实际定义时需要定义struct aockaddr_in类型的变量,类型不对应,使用强转  

```c
struct sockaddr_in addr;  
bind(fd, (struct sockaddr *)&addr, size);  
```

## struct sockaddr_in 数据结构  

* 使用 man 7 ip 查看该结构  

![{2}J(FYH~W8}6J C)E( Q61](https://user-images.githubusercontent.com/58176267/175503613-a1a9e930-057e-46c2-8c25-b90f51700d7d.png)  

* sin_family  地址结构类型  IPv4使用 AF_INET  
* sin_port   网络字节序的端口号   因此需要先用 htons 函数将端口号转换下
* sin_addr   网络地址  使用inet_pton 函数抓换后的网络字节序的IP地址 (使用htonl函数转换的话，传入的需要是一个

```c
struct sockaddr_in addr;  
addr.sin_family = AF_INET/AF_INET6;
addr.sin_port = htons(9527); // 本地字节序转网络字节序  16位端口号  
/*
int dst;
inet_pton(AF_INET, "192.168.3.33", (void*)&dst);
addr.sin_addr.s_addr = dst;
*/
// 正常要给addr.sin_addr.s_addr赋值需要通过上述方式，但一般直接使用宏 INADDR_ANY  该宏会自动获取系统中当前有效的任意一个IP地址 默认是二进制形式，只需要转换成网络字节序即可
addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY宏 会自动获取系统中当前有效的任意一个IP地址 默认是二进制

bind(fd, (struct sockaddr *)&addr, size);  
```

* 了解下 inet_addr 函数



 
