# 2.select函数  


* 参数  
    * nfds: 所要监听的所有socket文件描述符中最大的那个再加1  
        * 原理：在select内部，要对所传入的参数做循环，这个参数是循环的上限  
    
    * 三个fd_set类型的指针  **都是传入传出参数**
        * set与信号屏蔽字中的set类似，表示集合  这里是文件描述符集合 指针   本质上是位图，与文件描述符表对应，0表示0号文件描述符状态 1表示..... 
    * readfds
        * 假如一个新的客户端c4想要与服务器建立连接，对select来说，相当于c4给select发了个connect请求   相当于lsd这个文件描述符，有读事件发生  
        * 假如c2这个已经建立连接的客户端，要发送数据给服务器，相当于是写数据到自己的socket的写缓冲区，对于cfd2这个文件描述符，也是读事件  
    * writefds 监听文件描述符的写事件   
    * exceptfds 监听异常事件  
    * struct_timeval 类型的指针 timeout ：超时时长  
        * 结构体中设置秒和微妙
        * 设置的是内核中select等待的时长
        * 该参数分三种情况：
            * 1.NULL 永远等下去 阻塞监听
            * 2.设置timeval，等待固定时间
            * 3.设置timeval里时间均为0，检查描述字后立即返回，轮询(相当于非阻塞，轮询)

![image](https://user-images.githubusercontent.com/58176267/179228287-a6889b77-5b3f-4e90-a3dd-cf4b609eeb55.png)  


* 假如设置了下面三个监听集合，但是监听某文件描述符它不一定有数据，因此这三个参数是传入传出参数  比如读集合，有3，5，6  写监听4，6 异常监听7  调用该函数时，传入的是设置的这些集合，传出时，是实际有事件发生的   比如实际有5，6有数据，那传出时就只有5，6    监听期间4号有写事件，那写集合传出的就有4   现阶段，不管是客户端请求建立连接，还是发送数据给服务器，主要就是用读监听集合，写和异常传入空即可  


* 返回值
    * 返回的是所有监听集合中，有事件的总个数  
    * 0 说明没有任何事件  



