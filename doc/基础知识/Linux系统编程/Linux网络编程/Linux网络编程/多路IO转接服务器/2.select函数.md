# 2.select函数  

![image](https://user-images.githubusercontent.com/58176267/179235674-910bbcb8-aa3f-4483-bdcf-8129197d2a68.png)  


* 参数  
    * nfds: 所要监听的所有socket文件描述符中最大的那个再加1  
        * 原理：在select内部，要对所传入的参数做循环，这个参数是循环的上限  
    
    * 三个fd_set类型的指针  **都是传入传出参数**
        * set与信号屏蔽字中的set类似，表示集合  这里是文件描述符集合 指针   本质上是位图，与文件描述符表对应，0表示0号文件描述符状态 1表示..... 
    * readfds
        * 假如一个新的客户端c4想要与服务器建立连接，对select来说，相当于c4给select发了个connect请求   相当于lsd这个文件描述符，有读事件发生  
        * 假如c2这个已经建立连接的客户端，要发送数据给服务器，相当于是写数据到自己的socket的写缓冲区，对于cfd2这个文件描述符，也是读事件  
    * writefds 监听文件描述符的写事件   
    * exceptfds 监听异常事件  
    * struct_timeval 类型的指针 timeout ：超时时长  
        * 结构体中设置秒和微妙
        * 设置的是内核中select等待的时长
        * 该参数分三种情况：
            * 1.NULL 永远等下去 阻塞监听
            * 2.设置timeval，等待固定时间
            * 3.设置timeval里时间均为0，检查描述字后立即返回，轮询(相当于非阻塞，轮询)


![image](https://user-images.githubusercontent.com/58176267/179233256-0071fe3c-6880-41ea-b056-bc2b2661054a.png)  



![image](https://user-images.githubusercontent.com/58176267/179233522-69054e03-0f62-4513-94d2-17e2beaa46a4.png)  



![image](https://user-images.githubusercontent.com/58176267/179228287-a6889b77-5b3f-4e90-a3dd-cf4b609eeb55.png)  


* 假如设置了下面三个监听集合，但是监听某文件描述符它不一定有数据，因此这三个参数是传入传出参数  比如读集合，有3，5，6  写监听4，6 异常监听7  调用该函数时，传入的是设置的这些集合，传出时，是实际有事件发生的   比如实际有5，6有数据，那传出时就只有5，6    监听期间4号有写事件，那写集合传出的就有4   现阶段，不管是客户端请求建立连接，还是发送数据给服务器，主要就是用读监听集合，写和异常传入空即可  


* 返回值
    * 返回的是所有监听集合中，有事件的总个数  
    * 0 说明没有任何事件  



## 监听集合设置相关函数    

* 需要设置三个监听集合，涉及到位操作，操作系统也提供了相关函数  

* void FD_CLR(int fd, fd_set * set) 清空  表示将某个集合中某个文件描述符对应二进制位清除出去
* int FD_ISSET(int fd, fd_set * set): 返回值int 判断某个文件描述符是否在某集合中
    * 在 ： 1   不在： 0 
* void FD_SET(int fd, fd_set * set): 把某个文件描述符添加到某集合中  
* void FD_ZERO(fd_set * set): 把位图的所有二进制位全置为0  



![image](https://user-images.githubusercontent.com/58176267/179235619-a975ce15-2a1b-4639-8e13-8edbf64dc447.png)  



## select 使用一般步骤  


* void FD_ZERO(fd_set * set)  清空一个文件描述符集合  
    * fd_set rset;
    * FD_ZERO(rset);
* void FD_SET(int fd, fd_set * set) 将待监听的文件描述符，添加到监听集合
    *  FD_SET(3, &rest);  FD_SET(5, &rest);  FD_SET(6, &rest);  

* 如果某个客户端调用了close，关闭了与服务器的连接服务器可以调用FD_CLR
    * 与某个客户端通信时，read返回了0，假设对应的文件描述符是4  此时就可以   FD_CLR(4, &rest);  之后就不再监听4了  




