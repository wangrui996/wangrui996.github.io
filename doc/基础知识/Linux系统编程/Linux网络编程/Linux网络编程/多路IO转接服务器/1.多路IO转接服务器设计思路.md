# 1.多路I/O转接服务器设计思路  


* I/O多路复用（IO多路转接）中的IO，并不是指从键盘输入到程序，或者说程序打印输出内容到屏幕； 而是指得 文件和内存之间的输入输出  
    * 在网络通信中，两端都有个socket套接字，然后在内核都有读写缓冲区，一端向写缓冲区写数据，另一端再从自己的读缓冲区读数据，这里的I/O实际上是指得对缓冲区的操作  
* 多路复用，字面意义是多条路复用成一条。

* I/O多路复用就是可以使程序能够同时监听多个文件描述符(就对应了多个读写缓冲区)，提升程序性能  

* 先回顾下 多进程/多线程 网络服务器基本写法  

* 再来看下做法有什么问题：
    * 不管多进程还是多线程中，主进程(线程)都要亲历亲为，也就是要执行accept阻塞监听客户端的连接，一旦某个客户端连接，就创建一个子进程或者子线程，并用accpet返回的socket描述符与对应客户端进行通信    
    * 客户端数量少还可以，如果客户端数量一多，连接等请求频繁，那服务器就别想做其他事了； 另外服务器一般都是7x24小时在线，如果按之前模式，即使很长时间内，没有客户端与服务器建立连接，服务器由于accpet也会阻塞在那里监听，没法做别的事  
    * 在通信时假设有10个客户端建立了连接，之前的做法可能是，需要循环遍历10个socket文件描述符，每遍历到其中一个，去read看有没有数据，也就是看对应文件描述符对应的读缓冲区有没有数据  


* 那能不能不由服务器进程做这些事，内核帮忙做？  

* 内核有个 select负责这个事，但是它也不是一直accpet阻塞，干等  而是留个电话号码，当有连接需求时，再启accept  

* select负责监听，当监听到有连接请求，通知server，由server调accept，返回一个用于通信的socket描述符cfd，此时不会阻塞因为需求已经来了  相当于server创建好负责监听的socket文件描述符（lfd)，交给select  

* server产生了cfd，假设与c1通信的，但由于它不知道c1什么时候与自己通信，不可能一直在这等，也是交给select监管  

* select有一个ldf用于监听新的连接，cfd用于监听对应的客户端是否发数据，如果发数据了再通知server，server调用read处理  
    * 假如c1建立好连接后，不发数据，server不用一直在这等  

* 其他也同理  某一时刻，c2要与server建立连接，先被select监听到，通知server，调用accept并直接返回一个cfd2，交由select监管(所谓监管就是看cfd2上是否有read，write事件）  而select的lfd监管的是 是否有connect事件  
* server被解放了，一是不用被阻塞在监听这里(accept)，另外是不用阻塞在read和write(有需求了才来read，此时一read就能读到数据)  


## I/O模型 分类


## 阻塞 I/O  

* 阻塞 I/O  BIO (block I/O)  
    * 好处：自己阻塞的时候，CPU执行权限是让出的，不占用CPU资源 
    * 缺点： 同一时刻只能处理一个操作，效率低   read读数据，如果没有数据，read就一直阻塞在这  

![image](https://user-images.githubusercontent.com/58176267/179210478-ec325f69-bd11-42a0-9f6e-7bbffdf4a577.png)  

* 采用多线程/进程支持并发的方式，根本原因是只有一个进程时，一旦与某一个客户端建立起连接后，通信时由于read会阻塞，无法监听其他客户端的连接请求   而且在线程中，执行read也会阻塞  

![image](https://user-images.githubusercontent.com/58176267/179211440-27a2e139-b30d-490a-b391-bc1f0da3b44b.png)  

## 非阻塞, 忙轮询

* 非阻塞, 忙轮询：设置成非阻塞，但是要一直循环探查
    * 阻塞是： 老师讲完一个知识点，问下面学生：能不能听懂，然后就一直在那等学生回复  
    * 非阻塞忙轮询： 老师讲完一个知识点，问下面学生：能不能听懂  没人说话就等下再问一遍
    * 不阻塞程序倒是能多执行了，但是占了更多的CPU资源和系统资源

![image](https://user-images.githubusercontent.com/58176267/179212138-d43149b6-9c81-45cd-bdeb-1f06ab8701ad.png)

* NIO模型  Non-blocking I/O  
    * 有一个连接，就保存一个cfd  通过循环遍历cfd然后read的方式看有没有数据  
    * 但是如果客户端数量巨多，每一次循环，要全遍历一遍并调用read系统调用，尽管可能大多数都没有数据，浪费大量系统资源  
    
![image](https://user-images.githubusercontent.com/58176267/179213195-ec3e435d-2a19-4236-9165-576a0118caf1.png)  


## 响应式/多路IO转接  

* **响应式/多路IO转接**：谁有问题谁来找老师，然后老师作出反应  
    * 这里就是，有人有需求了(连接需求，通信的需求)，就来找，然后server再处理  


* 上面负责这个功能的“秘书”：有 select、poll、epoll  系统调用  

### select/poll  

* 所谓委托内核检测有没有客户端有数据发送，实际上就是检测有没有哪个为念描述符对应的内核读缓冲区有数据  
* 假设100个文件描述符，有5个有数据到达，select和poll，只会告知有5个到达了数据，但不告诉是哪五个，还需要自己遍历，但不是遍历并通过read(或recv)去判断，底层是用二进制位的方式表示的有无数据)，这样效率比之前要高  

![image](https://user-images.githubusercontent.com/58176267/179213648-5e8904b6-affd-4b6a-a64b-6a729fa932b2.png)


### epoll  

![image](https://user-images.githubusercontent.com/58176267/179214153-57065d11-6eb0-4a70-b8ce-d391ac66b0f6.png)



## 总结  

* 所谓I/O多路复用(转接)：是指原先有多个路需要去一个一个检测，比如针对某个文件描述符调用read，看有没有数据，再检测另一个； 现在只用一个，把需要检测的文件描述符交给了内核  







