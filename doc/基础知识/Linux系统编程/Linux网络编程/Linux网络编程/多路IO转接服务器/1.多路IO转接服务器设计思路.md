# 1.多路I/O转接服务器设计思路  


* I/O多路复用（IO多路转接）中的IO，并不是指从键盘输入到程序，或者说程序打印输出内容到屏幕； 而是指得 文件和内存之间的输入输出  
    * 在网络通信中，两端都有个socket套接字，然后在内核都有读写缓冲区，一端向写缓冲区写数据，另一端再从自己的读缓冲区读数据，这里的I/O实际上是指得对缓冲区的操作  
* 多路复用，字面意义是多条路复用成一条。

* I/O多路复用就是可以使程序能够同时监听多个文件描述符(就对应了多个读写缓冲区)，提升程序性能  

* 先回顾下 多进程/多线程 网络服务器基本写法  

* 再来看下做法有什么问题：
    * 不管多进程还是多线程中，主进程(线程)都要亲历亲为，也就是要执行accept阻塞监听客户端的连接，一旦某个客户端连接，就创建一个子进程或者子线程，并用accpet返回的socket描述符与对应客户端进行通信    
    * 客户端数量少还可以，如果客户端数量一多，连接等请求频繁，那服务器就别想做其他事了； 另外服务器一般都是7x24小时在线，如果按之前模式，即使很长时间内，没有客户端与服务器建立连接，服务器由于accpet也会阻塞在那里监听，没法做别的事  
    * 在通信时假设有10个客户端建立了连接，之前的做法可能是，需要循环遍历10个socket文件描述符，每遍历到其中一个，去read看有没有数据，也就是看对应文件描述符对应的读缓冲区有没有数据  


* 那能不能不由服务器进程做这些事，内核帮忙做？  

* 内核有个 select负责这个事，但是它也不是一直accpet阻塞，干等  而是留个电话号码，当有连接需求时，再启accept  

* select负责监听，当监听到有连接请求，通知server，由server调accept，返回一个用于通信的socket描述符cfd，此时不会阻塞因为需求已经来了  相当于server创建好负责监听的socket文件描述符（lfd)，交给select  

* server产生了cfd，假设与c1通信的，但由于它不知道c1什么时候与自己通信，不可能一直在这等，也是交给select监管  

* select有一个ldf用于监听新的连接，cfd用于监听对应的客户端是否发数据，如果发数据了再通知server，server调用read处理  
    * 假如c1建立好连接后，不发数据，server不用一直在这等  

* 其他也同理  某一时刻，c2要与server建立连接，先被select监听到，通知server，调用accept并直接返回一个cfd2，交由select监管(所谓监管就是看cfd2上是否有read，write事件）  而select的lfd监管的是 是否有connect事件  
* server被解放了，一是不用被阻塞在监听这里(accept)，另外是不用阻塞在read和write(有需求了才来read，此时一read就能读到数据)  

* 阻塞 
* 非阻塞忙轮询：设置成非阻塞，但是要一直循环探查
    * 阻塞是： 老师讲完一个知识点，问下面学生：能不能听懂，然后就一直在那等学生回复  
    * 非阻塞忙轮询： 老师讲完一个知识点，问下面学生：能不能听懂  没人说话就等下再问一遍
* **响应式/多路IO转接**：谁有问题谁来找老师，然后老师作出反应  
    * 这里就是，有人有需求了(连接需求，通信的需求)，就来找，然后server再处理  


* 上面负责这个功能的“秘书”：有 select、poll、epoll  系统调用  










