## 10.epoll反应堆模型  

* epoll 反应堆模型 ： ET模式 + 非阻塞 + void * ptr （自动回调）  


* 在 epoll 反应堆模型中，不仅要监听 cds的读事件，还要监听写事件
    * 原来的代码，读之前需要监听读事件, 触发了以后才能读  实际上往客户端写数据前，也要监听写事件，因为并不是服务器想写就可以写的  
    * 之前没出错是因为测试环境非常简单 真正网络环境中，对端有可能处于半关闭、对端滑动窗口有可能满，一旦发生类似情况，是不能随便写的  

![image](https://user-images.githubusercontent.com/58176267/179753025-e8fcdf62-74f1-4a41-93dd-7e36432c7781.png)  



## epoll 反应堆  


* 描述就绪文件描述符相关信息的结构体  myevents_s  
   * last_active 记录每次接入红黑树的时间  因为有时候一个客户端连着但是一直不发数据，对于高性能并发服务器，如果有了这个信息可以做的事比如，一个客户端长时间没事件，就剔出去，让出文件描述符给其他客户端连接  

* 16-37行
![image](https://user-images.githubusercontent.com/58176267/179763732-105b03e9-7df1-4cd4-94c4-c392ab08fcbb.png)  


## 初始化监听socket函数   

* 封装了 socket、bind、listen等封装成一个函数  

* 注意 fcntl设置了非阻塞 
    * 规范的写法应该是 先读出flag，或上非阻塞，再设置回去 libevent库实现时是下面代码这样直接进行了设置  

* main函数中没有调用epoll_ctl,在这里实现了  


* eventset(&g_events[MAX_EVENTS], lfd, acceptconn, &g_events[MAX_EVENTS]);
    * 创建struct myevents_s结构体数组g_events时，数组大小是MAX_EVENTS + 1，这里&g_events[MAX_EVENTS]相当于取数组最后一个元素的地址  
    * lfd 
    * acceptconn 回调函数  这里就是个函数名  
    * &g_events[MAX_EVENTS] 回调函数的 void* 类型的参数 arg  也就是说，结构体myevents中回调函数call_back的传入参数，包括了这个结构体自己  



* 191-216行
![image](https://user-images.githubusercontent.com/58176267/179770377-9844a67d-4041-4599-893a-5d178f78697b.png)


## eventset 函数  

* 功能：将myevent_s 成员变量初始化  设置回调函数  
    * lfd  对应acceptconn     
    * cfd  对应recvdata   
* 参数:
    * strcut myevent_s * ev : 自定义的结构体指针
    * 后面几个参数相当于都是给call_back服务   fd作为call_back第一个参数，arg作为最后一个参数  
* 函数体:
    * 为结构体赋值  
    * ev->events = 0; 相当于没初始化
    * ev->status = 0; 默认状态0 不在监听 也就是不在红黑树上
    * memset 将buf清0，也可以用zero函数 
    * ev->len = 0; 长度默认值 0
    * 时间，取得是调用该函数的时间作为默认值    

* 38-54  
![image](https://user-images.githubusercontent.com/58176267/179771912-107cb87b-ddb5-49af-872a-4926270326e0.png)  



## acceptconn 回调函数  


* 宏 __func__ 表示当前的函数名  
   * __LINE__ 表示行号  

* do while(0) :
    * 一开始的for循环然后if判断，如果在全局数据g_events中没找到一个空闲位置，就break  
    * 给 cfd 设置非阻塞  
    * 调用 eventset，给客户端设置一个 myevents 结构体， 回调函数设置为 recvdata   也就是设置刚连接的客户端对应的回调函数(那么同理，之前初始化函数中，lfd对应的myevents结构体的回调函数是acceptconn,也就是专门用来和客户端连接的，同时设置客户端的myevents结构体和回调函数，并加到树上)   
        * 第一个参数&g_events[i] 这里i是前面for循环结束后的，找到的第一个没有用的(被挂树上)的结构体下标，如果是第一次调用，由于status都初始化为0，所以i等于0时就break了  
        * 在初始化函数中调用了一次，是给lfd构造了一个myevents 结构体  
    * 调用 eventadd 函数 加到红黑树上  


## eventadd 函数  


* 功能：向 epoll监听的红黑树 添加一个 文件描述符   可以设置监听读事件还是写事件  
*  
* 该函数调用：一是在初始化函数中，将lfd加入   二是在lfd对应的回调函数acceptconn中，创建出新连接的客户端文件描述符后，将cfd添加到红黑树上  

* struct epoll_event epv = {0, {0}}; // 一个临时的struct epoll_event 变量，给epoll_ctl用  
* epv.data.ptr = ev   // 给struct epoll_event的成员 data.ptr 赋值成 myevents类型的指针，就是要添加到树上的那个文件描述符对应的 &g_events[MAX_EVENTS]  
    * 这里ptr相当于原来和events搭档的那个fd，只不过这里ptr指向了结构体&g_events[MAX_EVENTS]， 而在调用eventadd 函数前，通过eventset函数已经将结构体赋值，包括fd，回调函数等，如果是lfd将来就回调acceptconn 如果是cfd就回调recvdata  
* epv.events = ev->events = events;  // events是调用时传入的，如EPOLLIN  可通过该形参不断调整监听的事件类型  
* 判断 ev->status(代表是否添加到了红黑树上，默认0表示不在)  

* 55-78  
![image](https://user-images.githubusercontent.com/58176267/179781233-a52b5774-b3e5-404a-83f8-2b58dfed17fc.png)  



## epoll 反应堆模型 main函数  


* while循环中，for循环遍历epoll_wait传出的数组events，对于每个events[i]  判断条件 if((events[i].events & EPOLLIN) && (ev->events & EPOLLIN)) 相当于之前的while循环条件中  if(events[i].data.fd == lfd) 或者 if(events[i].data.fd == cfd)  
* 下面是之前的epoll代码 因为之前是利用了struct epoll_event 这里结构体中 data的fd 所以epoll_wait结束后，遍历events，先判断是不是读事件，是的话，看传出参数的events[i].data.fd是lfd还是cfd 然后对应lfd或者cfd再执行不同的逻辑  
* 现在不用struct epoll_event 这里结构体中 data的fd了，而是利用了data中的void* ptr  

* 218-243行  
![image](https://user-images.githubusercontent.com/58176267/179791457-0da78f2a-5803-405c-8694-b8ecb58c832d.png)  


* 244-253
![image](https://user-images.githubusercontent.com/58176267/179791783-e5d8e2fb-f51a-4b60-b718-ef3418b632de.png)


* wait被触发后的read和write的回调及监听  

* 调用epoll_wait后，nfd得到有事件的文件描述符个数，接下来遍历  
* 对于每一个i  通过传出参数events[i] 相当于


255-最后  
![image](https://user-images.githubusercontent.com/58176267/179790211-a8368c84-47b8-470a-98e6-4c562014d38f.png)  



