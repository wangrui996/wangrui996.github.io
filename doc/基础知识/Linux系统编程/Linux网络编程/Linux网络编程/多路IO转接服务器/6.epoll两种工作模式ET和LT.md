# 6.epoll两种工作模式ET和LT  


* 首先说明：epoll等，虽然主要使用在网络编程中，但是它们的API中的文件描述符，不一定是socket，可以是管道等  


## ET 和 LT  

* LT(Level Triggered) ： 水平触发  
* ET(Edge Triggered) :  边沿触发  



* 看下面例子  
    * 子进程每次向管道写端写入10字节数据 "aaaa\nbbbb\n" 、 "cccc\ndddd\n"......
    * 父进程使用epoll模型监听，由于我们确信只有一个连接，这里demo的实现就很简单 
    * 父进程每次只read缓冲区一半的数据  可知，每次读完以后，到下一次子进程重新向缓冲区写数据之前，缓冲区仍存在数据  


* **LT和ET的区别就是：缓冲区剩下的数据，会不会对epoll_wait进行触发**  

* 默认的 LT 模式就是：当缓冲区仍存在数据时，会对epoll_wait 进行触发   也就是如果父进程再次调用 epoll_wait 时，对应的一个文件描述符读缓冲区有数据，就算作事件  
* ET模式，缓冲区剩下的数据不会对epoll_wait进行触发，什么时候子进程再次向管道写数据后，会触发epoll_wait; 但是注意此时管道中还有bbbb\n没读出来，会先读这些数据  


![image](https://user-images.githubusercontent.com/58176267/179650472-858c5d93-eeff-4c1b-a8d2-1f7ce20ceed5.png)  
![image](https://user-images.githubusercontent.com/58176267/179650518-7a8dafa9-eeb0-4be3-99fa-527d2bfb7f16.png)  


![image](https://user-images.githubusercontent.com/58176267/179650555-4286dc9c-4cce-4d38-a806-db25275e874a.png)  

* 实验现象：
* LT模式：父进程很快的(几乎是瞬间)读到aaaa和bbbb并打印 因为子进程在写一次后会sleep 5秒，父进程很明显在5秒内就读出了aaaa\n和bbbb\n说明就是LT模式(子进程还没进行第二次写，父进程读缓冲区剩余数据就能触发 epoll_wait)   
    * event.events = EPOLLIN  就默认是水平触发 
* ET: 读完aaaa\n以后，等5秒才会再读到bbbb\n  
    * * event.events = EPOLLIN | EPOLLET  就是边沿触发 ET 


* ET模式：新的事件满足才会触发，这里新的事件要看监听的什么，如果是监听的读，那就是有新的读事件满足，此时epoll_wait不是依靠读缓冲区的数据触发，而是看客户端有无真正的行动  

![image](https://user-images.githubusercontent.com/58176267/179653038-f917a6d4-bb40-41d7-a58a-04c80469d062.png)



## 网络中的LT和ET  

* 用服务器客户端实现的上面的demo  


## readn 和 readline  

* readn 中的n，在读的时候，会指定读够n个字节才返回  如n为500，当读到499个字节时，还是阻塞状态  



## 比较  

![image](https://user-images.githubusercontent.com/58176267/179662010-56783ebe-3292-4d7e-be16-0a00520f501b.png)  

## epoll的ET非阻塞模式  

* 上面的阻塞的ET模式基本不会用  

* 下面的代码，假如服务器使用readn读，设定了n为500，但是读到了498，会阻塞   谁调用谁阻塞，所以服务器在readn这里阻塞，没法被唤醒
    * 原来服务器是阻塞在 epoll_wait 上,当有事件满足时，epoll_wait 被唤醒，然后读，此时读应该不会阻塞因为一定是读缓冲区有数据了才有的监听事件，epoll_wait才被唤醒的
    * 该种情况，假设read读完，客户端紧接着发送了两个字节，按原来逻辑需要由 epoll_wait 监听到有事件，再读  但现在阻塞在这 epoll_wait 没法被触发  
 
 
 
 
 

