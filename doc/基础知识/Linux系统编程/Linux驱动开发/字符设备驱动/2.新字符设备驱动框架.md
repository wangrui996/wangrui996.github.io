# 2.新字符设备驱动框架  

* 老的字符设备驱动框架缺点：
    * 使用 register_chrdev 函数注册，需要传入主设备号和设备名，需要自己查当前系统没有使用的设备号，且一个主设备号，会浪费其对应的次设备号  



## 新字符设备驱动框架  


## alloc_chrdev_region 函数 注册设备

* 定义在内核源文件的 char_dev.c 中  

```c
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
```

* 参数：
    * dev： dev_t类型的指针，也就是需要定义一个设备号类型dev_t，然后取地址传进去 
    * baseminor：基础的次设备号  
    * coun：需要几个次设备号
    * name:字符设备的名字   


## unregister_chrdev_region 函数 释放设备  

* 定义在内核源文件的 char_dev.c 中

```c
void unregister_chrdev_region(dev_t from, unsigned count)
```

* 参数：
    * from：设备号  
    * count：要释放的数量  因为前面申请时可以连续申请多个设备  

## register_chrdev_region 注册字符设备并申请指定的设备号  

* 定义在内核源文件的 char_dev.c 中

* **注意：传入的from一般是指定的主设备号，但是类型是dev_t设备号类型，包括了主设备号和次设备号，因此需要先用系统提供的宏 MKDEV(主设备号，0) 构建出dev_t类型的设备号**  
* 然后通过函数，构建完整的dev_t

```c
int register_chrdev_region(dev_t from, unsigned count, const char *name)
```

* 参数：
    * from: 指定的设备号



* 阅读Linux内核中的设备驱动，发现驱动编写一般可遵从下面规则：  
    * 自定义主设备号和次设备号 
    * 判断是否给定了主设备号，给定了的话，使用register_chrdev_region注册并申请对应的设备号  
    * 如果没有定义设备号，使用alloc_chrdev_region注册，并让系统自动分配  

![2022-07-29 09-33-11 的屏幕截图](https://user-images.githubusercontent.com/58176267/181664385-c552cd65-7eef-4cdd-89bc-15c3e21ed59b.png)  


* 一般在Linux驱动开发中如果给出了主设备号，就表示这个设备号已经确定，次设备号基本上都选择0，算是一种习惯  
    * 因此，使用register_chrdev_region 时，传入的det_t类型的设备号，通过 MKDEV(major， 0)来生成  


## 新字符设备驱动框架  

* 1.首先定义一个设备结构体，表示一个设备  

```c
/* LED设备结构体 */
struct newchrled_dev {
	dev_t devid; 	// 设备号  
	int major;  	// 主设备号 
	int minor;		// 次设备号
};
```

* 2.Linux中，使用**cdev**结构体表示一个字符设备 定义在include/linux/cdev.h 文件中  
    * 我们在上面定义了一个表示设备的结构体，其中管理了设备号信息，因此可以在里面定义一个cdev的结构体  

```c
struct cdev {
	struct kobject kobj;
	struct module *owner;  // 表示字符设备属于哪个模块，一般等于THIS_MODULE
	const struct file_operations *ops; // 字符设备操作集
	struct list_head list;
	dev_t dev;
	unsigned int count;
};
```

```c
/* LED设备结构体 */
struct newchrled_dev {
	struct cdev cdev; // 字符设备 
    dev_t devid; 	// 设备号  
	int major;  	// 主设备号 
	int minor;		// 次设备号
};
```

* 3.cdev_init 初始化结构体cdev变量 

```c
void cdev_init(struct cdev *, const struct file_operations *);  
```
* 如：

```c
// 初始化设备  
newchrled.cdev.owner = THIS_MODULE;
cdev_init(&newchrled.cdev, &newchrled_fops);
```

4.cdev_add 函数向Linux系统添加字符设备(cedv结构体变量)  

* 参数 p 指向要添加的字符设备(cdev 结构体变量),参数 dev 就是设备所使用的设备号,参数 count 是要添加的设备数量

```c
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
```

5.cedv_del 注销  

* 在模块卸载函数中注销  与cdev_add成对出现  

```c
void cdev_del(struct cdev *p)
```

## 自动创建设备节点  

* 








