# 寄存器  

markdown汇编代码高亮  ARM汇编	armasm   X86汇编	x86asm


8086 CPU有14个寄存器：AX BX CX DX SI DI SP BP IP CS SS DS ES PSW
每个寄存器为16位，分高八位和低八位两个字节，为了兼容以往8位寄存器的程序，每个字节可以单独作为一个独立的8位寄存器使用  


## 通用寄存器  

AX, BX, CX, DX 四个通用寄存器，用于存放一般数据  每个寄存器可分为高低两个8位寄存器单独使用  

如AX可以分成AH与AL使用   

mov ax, 1234H  将1234H送入寄存器ax  
add ah, 11H   将寄存器ah的值加上11H(结果保存在ah)  

当数据出现溢出时，寄存器只能保存未溢出部分  

另外，当类似 add al, xxH 当相加后出现溢出时，不会向ah进位，因为此时**CPU是将al看作独立的寄存器，在进行8位的运算**

## 注意  

* 进行**数据传送（如mov** 或 **运算(如add)**时，指令的两个操作对象位数应当是一致的


##  8086 CPU寻址  

**补充：**  
* 内存空间实际上并不能说通过地址总线的组合数产生，因为内存生产后，内存空间是客观存在的，如每一个内存空间为1个字节  
* 16位的地址总线，有2^16个组合，可以对应2^16"层”内存，每一层由8位也就是1个字节组成，因此16根地址总线可控制的内存空间范围是2^16字节。也就是64KB
* 8086 CPU有20位地址总线，寻址能力为 2^20B 即 1MB    如果是16位的地址总线，对应的寻址能力为2^16B 即64KB   

![image](https://user-images.githubusercontent.com/58176267/158290531-01d8fe95-140a-459e-b1f5-fa088ef307e4.png)

上图为8086 CPU读写内存时生成物理内存的逻辑结构  

加法器采用**物理地址 = 段地址x16 + 偏移地址**的方式用两个16位寄存器合成物理地址  

**例如**：要访问物理地址为123C8H的内存单元，短地址设置为1230H，偏移地址为00C8H，送入加法器后，**段地址左移4位(乘以16)，得到12300H**，加上偏移地址得到123C8H  

* 可以看出，段地址x16实际上就是段地址左移4位，这里4位是二进制位(因为计算机信息最终都是二进制)**  
* 左移n位实际上是乘2^n  且2进制位左移4位(乘16)，从16进制位角度考虑就是左移了一位(乘16)    2进制位左移8位(乘2^8 = 256)，16进制左移2位(乘16^2 = 256)  

### 物理地址 = 段地址x16 + 偏移地址  本质含义  

8086CPU的这种寻址方式，本质是CPU访问内存时用一个基础地址(段地址x16)和一个相对于寄出地址的偏移地址相加得到物理地址  

也就是**基础地址+偏移地址=物理地址**的一种特殊实现


## 分段的概念  

并不是内存本身进行了分段，而是CPU对内存进行了划分，因为它采用基础地址(段地址x16)+偏移地址=物理地址的寻址方式，我们可以采用分段的方式来管理内存，比如地址10000H~100FFH的内存单元组成一个段，起始地址是10000H，段地址1000H，该段大小为100H  

* **段地址x16的结果必然是16的倍数，因此一个段的起始地址一定是16的倍数**  
* 偏移地址为16位，而16位地址的寻址能力为64KB(2^16B),所以一个段的长度最大为 64KB  如段地址1000H，寻址范围 10000H~1FFFFH   



# 段寄存器  

8086CPU有4个段寄存器： CS、DS、SS、SS  
8086CPU访问内存时由这4个寄存器提供内存单元的段地址  

## CS和IP  

**CS和IP指示了CPU当前要读取指令的地址**  
* CS：代码段寄存器  
* IP：指令指针寄存器  

任意时刻，CS内容为M,IP内容为N，则8086CPU会从Mx16+N单元开始，读取一条指令并执行  

### 修改CS 和 IP 的指令  

* jmp 段地址：偏移地址       同时修改CS和IP的值  
* jmp 某一个合法寄存器/地址   只修改IP的值  
* **不能使用mov指令来改变CS和IP的值，mov是传送指令**  





# 内存访问相关寄存器  

## DS  数据段寄存器  

CPU访问内存必须给出物理地址，8086PC中，内存地址由段地址和偏移地址组成； 其中DS寄存器存通常放的就是要访问的数据的段地址;  


**mov 传送指令** 
* 1.可以将数据直接送入寄存器
* 2.可以将一个寄存器内容送入另一个寄存器
* 3.可以将一个内存单元内容送入寄存器     mov  寄存器名, [内存单元偏移地址]
    * [] 说明操作对象是一个内存单元   
* 寄存器就用寄存器名指明，内存单元则需要用内存地址表示  

```x86asm
mov 寄存器，数据       如 mov ax, 8
mov 寄存器，寄存器     如 mov ax, bx
mov 寄存器，内存单元   如 mov ax, [0]
mov 段寄存器，寄存器   如 mov ds, ax
```

同样有
```x86asm
mov 寄存器，段寄存器       如 mov ax, ds
mov 内存单元，寄存器       如 mov [0], ax 
mov 段寄存器，内存单元     如 mov ds, [0]  会将   ds:0内存单元的值送如ds  
```

下面指令表示将10000H(1000:0)中的数据读到a1中  

```x86asm
mov bx, 1000H
mov ds, bx
mov a1, [0]
```
* **[xxx]中内容表示内存的偏移地址，还需要段地址才能定位一个内存单元，这个段地址CPU会自动从ds寄存器取**

* **段寄存器都无法使用mov直接将地址送入，如不能直接mov ds 1000H, 因此只能先将1000H送入一个一般寄存器，再将该寄存器内容送入ds**  

下面指令是a1寄存器内容送入内存单元10000H  

```x86asm
mov bx, 1000H
mov ds, bx
mov [0], a1
```

### 字的传送

8086CPU是16位结构，有16位地址总线，因此一次可以传送一个字,只需要在mov指令中给出的是16位寄存器就可以进行16位数据传输    

* 将10000：0(10000H)的字型数据送入ax (两个内存单元的内容为一个字  内存单元低位的字节为字的低8位)  
* 将cx中16位置送到1000:0处  
```x86asm
mov bx, 1000H
mov ds, bx
mov ax, [0]   
mov [0], cx
```

## add 和 sub 指令  

add和sub与mov类似，都有两个操作对象  

```x86asm
add 寄存器，数据         add ax，8
add 寄存器，寄存器       add ax，bx
add 寄存器, 内存单元     add ax, [0]
add 内存单元, 寄存器     add [0], ax

sub 寄存器，数据         sub ax, 9
sub 寄存器, 寄存器       sub ax, bx
sub 寄存器, 内存单元     sub ax, [0]
sub 内存单元, 寄存器     sub [0], ax
```










