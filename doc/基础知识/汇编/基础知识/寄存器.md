# 寄存器  


8086 CPU有14个寄存器：AX BX CX DX SI DI SP BP IP CS SS DS ES PSW
每个寄存器为16位，分高八位和低八位两个字节，为了兼容以往8位寄存器的程序，每个字节可以单独作为一个独立的8位寄存器使用  


## 通用寄存器  

AX, BX, CX, DX 四个通用寄存器，用于存放一般数据  每个寄存器可分为高低两个8位寄存器单独使用  

如AX可以分成AH与AL使用   

mov ax, 1234H  将1234H送入寄存器ax  
add ah, 11H   将寄存器ah的值加上11H(结果保存在ah)  

当数据出现溢出时，寄存器只能保存未溢出部分  

另外，当类似 add al, xxH 当相加后出现溢出时，不会向ah进位，因为此时**CPU是将al看作独立的寄存器，在进行8位的运算**

## 注意  

* 进行**数据传送（如mov** 或 **运算(如add)**时，指令的两个操作对象位数应当是一致的


##  8086 CPU寻址  

**补充：**  
* 内存空间实际上并不能说通过地址总线的组合数产生，因为内存生产后，内存空间是客观存在的，如每一个内存空间为1个字节  
* 16位的地址总线，有2^16个组合，可以对应2^16"层”内存，每一层由8位也就是1个字节组成，因此16根地址总线可控制的内存空间范围是2^16字节。也就是64KB
* 8086 CPU有20位地址总线，寻址能力为 2^20B 即 1MB    如果是16位的地址总线，对应的寻址能力为2^16B 即64KB   

![image](https://user-images.githubusercontent.com/58176267/158290531-01d8fe95-140a-459e-b1f5-fa088ef307e4.png)

上图为8086 CPU读写内存时生成物理内存的逻辑结构  

加法器擦用**物理地址 = 段地址x16 + 偏移地址**的方式用两个16位寄存器合成物理地址  

**例如**：要访问物理地址为123C8H的内存单元，短地址设置为1230H，偏移地址为00C8H，送入加法器后，**段地址左移4位(乘以16)，得到12300H**，加上偏移地址得到123C8H  

* 可以看出，段地址x16实际上就是段地址左移4位，这里4位是二进制位(因为计算机信息最终都是二进制)**  
* 左移n位实际上是乘2^n  且2进制位左移4位(乘16)，从16进制位角度考虑就是左移了一位(乘16)    2进制位左移8位(乘2^8 = 256)，16进制左移2位(乘16^2 = 256)  

### 理地址 = 段地址x16 + 偏移地址  本质含义  

8086CPU的这种寻址方式，本质是CPU访问内存时用一个基础地址(段地址x16)和一个相对于寄出地址的偏移地址相加得到物理地址  

也就是**基础地址+偏移地址=物理地址**的一种特殊实现


## 分段的概念  

并不是内存本身进行了分段，而是CPU对内存进行了划分，因为它采用基础地址(段地址x16)+偏移地址=物理地址的寻址方式，我们可以采用分段的方式来管理内存，比如地址10000H~100FFH的内存单元组成一个段，起始地址是10000H，段地址1000H，该段大小为100H  

* **段地址x16的结果必然是16的倍数，因此一个段的起始地址一定是16的倍数**  
* 偏移地址为16位，而16位地址的寻址能力为64KB(2^16B),所以一个段的长度最大为 64KB  如段地址1000H，寻址范围 10000H~1FFFFH   



## 段寄存器  

8086CPU有4个段寄存器： CS、DS、SS、SS  
8086CPU访问内存时由这4个寄存器提供内存单元的段地址  

### CS和IP  

**CS和IP指示了CPU当前要读取指令的地址**  
* CS：代码段寄存器  
* IP：指令指针寄存器  

任意时刻，CS内容为M,IP内容为N，则8086CPU会从Mx16+N单元开始，读取一条指令并执行  
















