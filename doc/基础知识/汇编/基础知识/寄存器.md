# 寄存器  

markdown汇编代码高亮  ARM汇编	armasm   X86汇编	x86asm


8086 CPU有14个寄存器：AX BX CX DX SI DI SP BP IP CS SS DS ES PSW
每个寄存器为16位，分高八位和低八位两个字节，为了兼容以往8位寄存器的程序，每个字节可以单独作为一个独立的8位寄存器使用  


## 通用寄存器  

AX, BX, CX, DX 四个通用寄存器，用于存放一般数据  每个寄存器可分为高低两个8位寄存器单独使用  

如AX可以分成AH与AL使用   

mov ax, 1234H  将1234H送入寄存器ax  
add ah, 11H   将寄存器ah的值加上11H(结果保存在ah)  

当数据出现溢出时，寄存器只能保存未溢出部分  

另外，当类似 add al, xxH 当相加后出现溢出时，不会向ah进位，因为此时**CPU是将al看作独立的寄存器，在进行8位的运算**

## 注意  

* 进行**数据传送（如mov** 或 **运算(如add)**时，指令的两个操作对象位数应当是一致的


##  8086 CPU寻址  

**补充：**  
* 内存空间实际上并不能说通过地址总线的组合数产生，因为内存生产后，内存空间是客观存在的，如每一个内存空间为1个字节  
* 16位的地址总线，有2^16个组合，可以对应2^16"层”内存，每一层由8位也就是1个字节组成，因此16根地址总线可控制的内存空间范围是2^16字节。也就是64KB
* 8086 CPU有20位地址总线，寻址能力为 2^20B 即 1MB    如果是16位的地址总线，对应的寻址能力为2^16B 即64KB   

![image](https://user-images.githubusercontent.com/58176267/158290531-01d8fe95-140a-459e-b1f5-fa088ef307e4.png)

上图为8086 CPU读写内存时生成物理内存的逻辑结构  

加法器采用**物理地址 = 段地址x16 + 偏移地址**的方式用两个16位寄存器合成物理地址  

**例如**：要访问物理地址为123C8H的内存单元，短地址设置为1230H，偏移地址为00C8H，送入加法器后，**段地址左移4位(乘以16)，得到12300H**，加上偏移地址得到123C8H  

* 可以看出，段地址x16实际上就是段地址左移4位，这里4位是二进制位(因为计算机信息最终都是二进制)**  
* 左移n位实际上是乘2^n  且2进制位左移4位(乘16)，从16进制位角度考虑就是左移了一位(乘16)    2进制位左移8位(乘2^8 = 256)，16进制左移2位(乘16^2 = 256)  

### 物理地址 = 段地址x16 + 偏移地址  本质含义  

8086CPU的这种寻址方式，本质是CPU访问内存时用一个基础地址(段地址x16)和一个相对于寄出地址的偏移地址相加得到物理地址  

也就是**基础地址+偏移地址=物理地址**的一种特殊实现


## 分段的概念  

并不是内存本身进行了分段，而是CPU对内存进行了划分，因为它采用基础地址(段地址x16)+偏移地址=物理地址的寻址方式，我们可以采用分段的方式来管理内存，比如地址10000H~100FFH的内存单元组成一个段，起始地址是10000H，段地址1000H，该段大小为100H  

* **段地址x16的结果必然是16的倍数，因此一个段的起始地址一定是16的倍数**  
* 偏移地址为16位，而16位地址的寻址能力为64KB(2^16B),所以一个段的长度最大为 64KB  如段地址1000H，寻址范围 10000H~1FFFFH   



# 段寄存器  

8086CPU有4个段寄存器： CS、DS、SS、SS  
8086CPU访问内存时由这4个寄存器提供内存单元的段地址  

## CS和IP  

**CS和IP指示了CPU当前要读取指令的地址**  
* CS：代码段寄存器  
* IP：指令指针寄存器  

任意时刻，CS内容为M,IP内容为N，则8086CPU会从Mx16+N单元开始，读取一条指令并执行  

### 修改CS 和 IP 的指令  

* jmp 段地址：偏移地址       同时修改CS和IP的值  
* jmp 某一个合法寄存器/地址   只修改IP的值  
* **不能使用mov指令来改变CS和IP的值，mov是传送指令**  





# 内存访问相关寄存器  

## DS  数据段寄存器  

CPU访问内存必须给出物理地址，8086PC中，内存地址由段地址和偏移地址组成； 其中DS寄存器存通常放的就是要访问的数据的段地址;  


**mov 传送指令** 
* 1.可以将数据直接送入寄存器
* 2.可以将一个寄存器内容送入另一个寄存器
* 3.可以将一个内存单元内容送入寄存器     mov  寄存器名, [内存单元偏移地址]
    * [] 说明操作对象是一个内存单元   
* 寄存器就用寄存器名指明，内存单元则需要用内存地址表示  

```x86asm
mov 寄存器，数据       如 mov ax, 8
mov 寄存器，寄存器     如 mov ax, bx
mov 寄存器，内存单元   如 mov ax, [0]
mov 段寄存器，寄存器   如 mov ds, ax
```

同样有
```x86asm
mov 寄存器，段寄存器       如 mov ax, ds
mov 内存单元，寄存器       如 mov [0], ax 
mov 段寄存器，内存单元     如 mov ds, [0]  会将   ds:0内存单元的值送如ds  
```

下面指令表示将10000H(1000:0)中的数据读到a1中  

```x86asm
mov bx, 1000H
mov ds, bx
mov a1, [0]
```
* **[xxx]中内容表示内存的偏移地址，还需要段地址才能定位一个内存单元，这个段地址CPU会自动从ds寄存器取**

* **段寄存器都无法使用mov直接将地址送入，如不能直接mov ds 1000H, 因此只能先将1000H送入一个一般寄存器，再将该寄存器内容送入ds**  

下面指令是a1寄存器内容送入内存单元10000H  

```x86asm
mov bx, 1000H
mov ds, bx
mov [0], a1
```

### 字的传送

8086CPU是16位结构，有16位地址总线，因此一次可以传送一个字,只需要在mov指令中给出的是16位寄存器就可以进行16位数据传输    

* 将10000：0(10000H)的字型数据送入ax (两个内存单元的内容为一个字  内存单元低位的字节为字的低8位)  
* 将cx中16位置送到1000:0处  
```x86asm
mov bx, 1000H
mov ds, bx
mov ax, [0]   
mov [0], cx
```

## add 和 sub 指令  

add和sub与mov类似，都有两个操作对象  

```x86asm
add 寄存器，数据         add ax，8
add 寄存器，寄存器       add ax，bx
add 寄存器, 内存单元     add ax, [0]
add 内存单元, 寄存器     add [0], ax

sub 寄存器，数据         sub ax, 9
sub 寄存器, 寄存器       sub ax, bx
sub 寄存器, 内存单元     sub ax, [0]
sub 内存单元, 寄存器     sub [0], ax
```

## CPU提供的栈机制  SS和SP寄存器

* 8086CPU提供相关指令来以栈的方式访问内存空间，也就是在基于8086CPU编程时可以将一段内存当作栈使用  

**指令**
* PUSH 入栈指令   push ax  表示把寄存器ax的数据送入栈
* POP 出栈指令    pop  ax  表示把栈顶数据取出送入ax  
* 8086CPU的入栈和出栈操作都是以字为单位进行的  


* 下图来源自 王爽 汇编语言(第三版) 

![image](https://user-images.githubusercontent.com/58176267/162107949-958ec434-8c02-4398-918f-2084ea72542b.png)

### SS和SP寄存器  

cpu如何知道当前内存中哪一段是栈呢，比如执行push ax时，需要把ax寄存器的数据送入栈顶，那栈顶位置是哪  

* **段寄存器SS存放栈顶段地址  SP存放偏移地址**

* **任意时刻，SS:SP 指向栈顶 **

* 例如，某一时刻，SS=1000H  SP=000EH  则 SS:SP = 1000EH, 这就是此时的栈顶位置   (注意SS是1000H要左移4位才是段基址，CPU寄存器是16位，地址总线是20，CPU都是采用的合成地址方式来访问内存) 
    * 执行push ax   需要先将 SP = SP - 2    SP变为000CH   栈顶为1000CH
    * 将ax的数据(如1234H)送入栈顶位置1000CH，则1000CH处为34H  1000DH处为12H  (前面讲过，CPU向内存送入一个字时，字的高位存放在内存的高地址，字的低位放在内存的低地址)  
    * 执行 pop bx  首先将SS:SP指向的内存单元送入bx 即将1234H送入bx  
    * 将SP = SP + 2 
    * 注意此时，1234H仍然在内存单元中，只是已经不再栈中了，因为之后再push时会把他们覆盖

* 如果希望将10000H-1000FH这段内存空间当作栈，初始时栈为空，此时 SS = 1000H(基地址就是10000H)， SP = 0010H （如果SP = 000FH，则1000FH是没法使用的）

* 也就是说，入栈时，栈顶从高地址向低地址方向增长  


### 栈顶越界问题  

* 当栈满了继续执行 push ax  则会将栈外的数据覆盖   当栈空了继续执行pop ax 栈顶也会越界 此时取出来的不是栈中元素了 之后如果再push ax 也会覆盖其他元素  非常危险  
* 8086CPU不提供这种栈越界检测的服务，只能自己在操作栈时注意越界问题  

### push和pop指令  

```as86
push 寄存器   !将寄存器数据压栈
pop 寄存器     !将栈顶数据弹出给寄存器

push 段寄存器   !将一个段寄存器数据入栈
pop  段寄存器    !将栈顶数据出栈，给段寄存器

!也可以在内存单元和内存单元之间传送数据
push 内存单元   ! 将一个内存字单元中的字压栈(**8086CPU中栈操作都是以字为单位**)
ppo  内存单元   ! 用一个内存字单元接收出栈的数据
```

**例子**

在push和pop操作时只给出内存偏移地址，段地址通过ds寄存器获取
```as86
mov ax, 1000H 
mov ds, ax     !数据段寄存器ds = 1000H
push [0]       !将 1000：0 (即10000H)处的字压入栈
pop [2]        !出栈数据送入 1000:2(即10002H)处
```

* push和pop操作相当于是两步  push操作时是SP先减2，再传送数据  pop时是先传送数据，再将SP加2   mov是一次转送

* 补充： mov ax, 0  和 sub ax, ax 的效果相同都是把ax清0  但前者对应的机器码是3个字节 后者是2个字节  







