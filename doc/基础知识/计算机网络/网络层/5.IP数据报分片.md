


# 5.IP数据报分片  

![image](https://user-images.githubusercontent.com/58176267/162470730-7ce1f56c-0f4f-44bf-9b54-b45bf81e5a46.png)

## 最大传输单元/MTU  

* **网路链路存在MTU————链路层数据帧可封装的数据的上限**  如以太网是1500字节？

* 假如一个数据报，在一个较大的MTU的链路上传输时，可以封装到一个数据帧中传输，但是可能经过一个路由器，转发到下一MTU较小的链路时，一个数据帧可能就装不下  

![image](https://user-images.githubusercontent.com/58176267/162471734-5102cb30-6864-4424-98dc-4c73c01fa4bd.png)

## IP分片与重组  

* 注意，这里的**可以**，要看标志位是否允许  如果不允许，路由器就会扔掉该分组，并向源主机发送一个ICMP报文  

* **路由器只分不装**   路由器将IP分组分片后，这些分片只有到达目的主机后才进行“重组”  如果某个路由器提前重组了，后面还可能需要MTU较小的链路还要分片，浪费资源  
* IP首部的相关子段用于标识分片以及确定分片的相对顺序
    * 因为，需要明确一个分组是分片了还是没分片，分片了的话，是哪一个片，片与片的相互顺序关系，否则目的主机无法“重组”
    * 如果某个分片丢失了，目的主机会等待一段时间，如果还没收全，会丢掉所有相关分片  


![image](https://user-images.githubusercontent.com/58176267/162473069-3d4899d2-11e6-422d-a7c1-6ae5ed894890.png)


## IP分组格式  

![image](https://user-images.githubusercontent.com/58176267/162473168-627cfb99-e923-4f7d-bbe4-cec8ba1698d0.png)


* **标识字段**： 16 位  标识一个分组  实际上还需要源IP地址和目的IP地址，否则网络中的分组 标识ID还是可能重复
    * IP协议用计数器，产生一个分组计数器加1，作为该分组的标识  

* **标志位** 3位  第一位没使用

* 下面的标准是否适用于现在的IP协议？
* MF = 1 不是一个独立的IP分组，是分片出来的，而且不是最后一片
* MF = 0  没有分片或者是分片的最后一片

![image](https://user-images.githubusercontent.com/58176267/162473863-8175347d-96ef-4845-a620-5864c9a4f050.png)

* **片偏移**字段  13 位 ： 一个IP分组分片封装原IP分组数据的相对偏移量
    * 0 IP分组没有分片    
    * 当MF = 1时，说明是个分片，且不是最后一片，这里的片偏移，就说明了这一片到底是原IP分组的哪一片，也就是从哪一个字节的数据开始分片封装的
    * 如果 MF = 0 且片偏移不等于0，说明这个分组是一个分片的最后一个分钟速
    * 如果 MF = 0, 偏移量 = 0 说明这个分组没有分片  
    * **片偏移字段的值以8字节为单位** (否则以字节为单位不够表示？)  一个分组分片成多个分片，前面的所有分片封装的数据字节数，都是8的倍数  因为这里偏移量是以8字节为单位

## IP分片过程  

* IP分组头部20字节每个分片也必须要有
* 除最有一个分片，其他分片均分为MTU允许的最大的分片  即下图中的M
* 因为片偏移量以8字节为单位，所以除了最后一片，前面的片封装的字节数一定是8的倍数   
* 公式：对于一个最大分片 可封装数据  M - 20 是每个分片能带的数据的字节数  如果没有时8的倍数要求那这就是最大分片可封装的字节数 但是要求是8的倍数，则**需要找一个满足 小于等于M - 20且是8的倍数的最大的数** ，把M-20/8 向下取整然后乘8 就是答案  

* 总片数 L - 20 即分组封装的数据(字节)，除以每个分组可封装的最大数据，向上取整  

![image](https://user-images.githubusercontent.com/58176267/162478468-9b8f3626-335d-4952-9ac2-d4f285ffc3de.png)


* 每片的片偏移字段取值 ：  最大能封装的字节数d除以8(该字段以8字节为单位) * (i - 1) 
    * 第一片 取0 （i=1） 

* 每片的总长度字段： 除最后一片，其余都是d+20      最后一片 源分组总长度L - (n-1)d  就是源分组总长度L 减去（前面分组的个数n-1 * 每个分组携带的字节数d）(也相当于数据相减再加上20字节头)  

![image](https://user-images.githubusercontent.com/58176267/162479996-f91b4e7b-24d5-45e3-b905-8757b6f58b62.png)


### 例子  





