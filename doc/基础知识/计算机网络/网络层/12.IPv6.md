# IPv6  


##  IPv6出现动机

* 如果要分片，源主机分，目的主机组装  
* 对于每个IP数据报，路由器有望只处理固定大小的40字节的头部，从而提高IP数据报的转发速度

![image](https://user-images.githubusercontent.com/58176267/170400878-af5941db-8241-4d08-9b68-09d5f8757c3a.png)


## IPv6数据报格式  

* 流标签:期望IPv6网络能够根据不同的流标签提供不同类型的服务  
* 载荷长度：16bit 理论上可以达到65535即64k的载荷长度
* 下一个首部：如果没有扩展首部，这个字段指向的是上层协议首部(如TCP首部)   **具体还要再查资料**
* 跳步限制：对应IPv4中的TTL  路由器转发一次将跳步数减1，如果跳步数被减到0，路由器会丢弃该数据报，并发送ICMP报文
* 源地址  目的地址  128位的地址空间  

![image](https://user-images.githubusercontent.com/58176267/170402163-0563727c-6774-44a3-8208-81f624b3bb1a.png)


## IPv6 VS IPv4  

* ICMPv6附加的报文类型如 “Packet Too Big” : IPv6网络中路由器不对IP数据报进行分片，如果一个IPv6数据报在一个链路上传输时，封装到数据帧中，超过了链路层的MTU，就会丢弃，同时向源主机发送一个 “Packet Too Big”的ICMPv6报文 由源主机绝对如何分片   

![image](https://user-images.githubusercontent.com/58176267/170402774-6959bfb9-8ad2-460f-a27f-b6dd26f161fc.png)

## IPv6地址表示形式  

* **采用冒号分割的16进制形式**
    * 128bit的IPv6地址，按照16bit一组，划分成8组，每16bit转换成16进制表示，用冒号连接
    * 压缩形式  中间连续的0可以用2个冒号代替 如示例，**注意：由于这样写没有声明代替了多少个0，因此不能出现两次连续的冒号，否则出现歧义**   
    * 如果使用点分十进制表示会太长，不便于书写
* IPv6不再使用子网掩码(如IPv4中的子网掩码255.255.255.0) 
* 由于采用冒号分割的16进制形式，在URL表示中容易出现歧义，因此在URL中会用中括号将IPv6地址括起来

![image](https://user-images.githubusercontent.com/58176267/170403393-14368782-dd3e-4ad5-9a3b-3f7595ba6e02.png)




