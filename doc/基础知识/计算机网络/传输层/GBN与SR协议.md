

# GBN与SR协议


# GBN协议   

* 假设分组头部包含 k bit序列号  则共有2^k序列号可用  
* 窗口尺寸为N，最多允许N个分组为确认  

![image](https://user-images.githubusercontent.com/58176267/160112562-0f3bec93-e4e9-4fdb-a5ce-c9f99bdae223.png)  

绿色部分：已经发送并被确认的分组  

**滑窗中最小的那个序列号，定义为send_base**

黄色部分：已经发送，还未确认的分组

蓝色部分：滑窗内可用的序列号 

nextseqnum: 滑窗内可用的序列号最小的那个  所以接下来如果要用就用这个  

白色部分： 当前不可使用的序列号(滑窗还没覆盖到)  

## GBN 发送方


**GBN采用累积确认的机制**

* ACK(n) : 确认到序列号n(包含n)的分组均已被正确接收  即序列号为 n， n-1， n-2....的分组都已经被正确接收了 
    * 可能收到重复的ACK  由于信道可能存在丢包等，可能会收到重复的ACK，可以解决
* 为空中的分组设置**计时器(timer)**  
* 超时(timeout)时间 ：超时是发生在某个分组上的(序列号)，假设对应的是N，则重传序列号大于等于n，但未收到ACK的所有分组


### GBN发送方扩展(包含了变量)的FSM  


![image](https://user-images.githubusercontent.com/58176267/160113849-a53ef0a9-9ea9-4dee-9bf0-9b7f580b331e.png)

* 初始时 base(上图中的send_base) = 1  （base表示滑窗中最小的序列号） nextseqnum = 1 （nextseqnum表示滑窗内新发送分组时可用的起始序列号）

* 上层应用需要发送数据时 ,发送方：
    * 如果nextseqnum < base + N  表示滑窗内还有可用序列号  利用该序列号制作一个分组，调用udt_send发出去 并判断 
        * 如果base == nextseqnum 启动定时器   nextseqnum++   实际上就是刚开始滑窗时启动定时器？  
    * 如果nextseqnum >= base + N 也就是滑窗内没有可用的序列号了，refuse_data（data）  

    * 进入wait状态等待新事件

* 如果发生了timeout事件
    * 重启timer 
    * 将nextseqnum之前（base为起始位置）的分组都重发一次   (GBN设计的)

* 如果收到ACK 
    * 因为GBN的确认采用累积确认， 将ACK中的序列号取出后 + 1然后赋值给base (因为取出的值表示在这个序列号之前的(包括这个序列号)都已经确认了，所以base位置移动到这个序列号 + 1位置)  
    * 所谓的窗口滑动，实际上就体现在这里，base移动了，窗口大小还是N，相当于窗口滑动了  
    * 判断base == nextseqnum
        *  base == nextseqnum 停止定时器   这种情况表示已经发送的分组都被正确接收了，  停止定时器后，如果再收到上层应用发送数据的时间，会重新启动
        *  否则，重新开始计时器，还有消息没有被确认(base到nextseqnum之间的分组)  但已经收到了一次ACK，所以之前定时器的定时应该清零，重新开始定时并等待ACK  



### GBN接收方扩展FSM  

接收方没有缓存

* 维持一个变量expectedseqnum : 当前期望收到的序列号

* 收到一个分组，分组没坏，并且序列号是它所期望的(理想情况)
    * 向上层交付数据
    * 发送ACK，其中的序列号为expectedseqnum
    * 将期望收到的分组序列号expectedseqnum++ 
    * 这里也是能体现接收方是没有缓存的 

* ACK机制 ： 发送拥有最高序列号的、已被正确接收的分组的ACK  
    * 可能产生重复的ACK
    * 只需要记住唯一的expectedseqnum  

* 乱序到达的分组
    * 停等协议中，发一个等发一个等，乱序情况出现的较少 但流水线机制中乱序可能比较多，比如可能接收到期望分组是5, 但收到了7 此时GBN处理是直接丢弃
    * **已经收到的但不是我期望的分组：直接丢弃————>接收方没有缓存**  
    * 重新序列号最大的、按序到达的分组  
    * 如期望的是5，收到的7，会丢弃7这个分组，恢复ACK中的序列号为4，表示4及以前的都收到了  

![image](https://user-images.githubusercontent.com/58176267/160117660-8615d90e-1206-4778-8a10-ff5f66bead61.png)



## GBN示例  

* pkt0-pkt3  
   * 发送方连续发送pkt0到pkt3 
   * 接收方正确收到pkt0和pkt1，分别发送ACK0,ACK1, 
   * pkt2丢失，接收方收到pkt3，会丢掉，并发送ACK1(期望的是2，收到了3，不缓存，丢弃，发送当前收到的最大的序列号)  
* 发送方收到ACK0，向前滑动，发送pkt4    收到ACK1，发送pkt5  
* 某一时刻，分组2的定时器发生timeout事件，会重发 pkt2到pkt5的所有分组  

![image](https://user-images.githubusercontent.com/58176267/160118732-4ca88349-845d-4ac6-bd34-bf169cf1d4b3.png)


## 练习题  

该情况下，发送方的base = 4  nextseqnum = 8  发生超时事件，则会重传滑窗内nextseqnum之前的所有数据(base就是滑窗起始位置)

![image](https://user-images.githubusercontent.com/58176267/160118823-4ee25cf0-42f4-4312-9b76-577de0cbf77f.png)


# SR协议  Selective Repeat

**GBN协议的缺陷**   

* 重传分组  当某一个分组丢失，会重传它和它以后的所有还没确认的分组  

## SR协议  

* 接收方对每个分组**单独进行确认** (接收方对于每个正确接收的分组都进行确认，也就是都发ACK回去)
   * 设置**缓存机制**，缓存乱序到达的分组 
* 发送方只重传那些没收到ACK的分组
   * 为每个分组设置定时器  当这个分组的定时器超时，就重传这一个分组  
* 发送方窗口与GBN一样 
    * N个连续的序列号
    * 限制已发送且未确认的分组   
* SR协议多了一个接收方窗口  

## SR协议的发送和接收方窗口示意  

### 接收方窗口  

* 窗口前白色部分：已经按序到达，正确交付的分组  
* 窗口中白色部分：当前希望收到但还没收到的分组
* 窗口中红色部分：乱序到达的分组(缓存起来并发送了ACK,将来乱序的前面的分组收到后可以一起提交给上层应用)
* 窗口中蓝色部分：当前滑窗可以接收的序列号的范围  
* 窗口后面部分： 当前滑窗没有用到的序列号  

变量rev_base: 接收方滑窗开始序列号  

注意：SR协议中，发送方和接收方窗口的位置不是同步对应的，彼此不知道对方的位置  


![image](https://user-images.githubusercontent.com/58176267/160138744-b42bad9c-3633-462a-bbf2-bdf27e4be80d.png)


### SR协议  

**发送方**

* 发送方出现超时事件，因为每个分组有一个定时器，会知道是哪个分组超时，重传这个分组并重启它的定时器
* 发送方收到ACK，判断ACK中序列号信息是否在[sendbase, sendbase+N]内，在的话就标记这个分组已经被正确接收，如果这个序列号(n)是窗口中最小的那个base，那就向右滑动窗口  

**接收方**

* 收到一个分组n，如果它在[revbase, revbase+N-1]内，就说明是自己期望的分组，就send ACK(n) 同时
    * 如果是乱序的(如期望的是4，来的是,5)，就把它缓存到buffer  
    * 如果是按序到达的，就把它已经它后面可以连上的分组一起交付给上层应用 （如上面期望4来的5，缓存了5，但自己还是期望的4，此时如果是按序到达的就是说来的是4，那么就会把4,5分组一起交付给上层） 同时向右滑动窗口  
* 如果收到的分组，序列号n,不在窗口范围内(如在区间[rcvbase-N, rcvbase-1],也就是上个窗口范围)，**发送ACK(n)**， 此时，接收方已经正确接收了序列号为n的分组，滑窗向右移动了，但是之前发回去的ACK(n)丢失了，发送方没收到ACK(n)会重传，所以，此时发送 ACK(n告知发送方自己已经收到了序列号为n的分组  

* 其他情况，接收方忽略  

### SR协议示例  

假设发送方窗口 N = 4  

![image](https://user-images.githubusercontent.com/58176267/160143221-3dc74877-85e0-4063-a2b5-b492a2bf7bc6.png)


### SR协议的困境  


网络是一个分布式系统，下面两个场景  

a场景中，接收方会将重复的分组0(由于三个ACK都没收到，重传了自己第一个滑窗中序列号为0的分组)当作新的分组0(下一个滑窗的0处)  
b场景中，发送方收到了ACK0以后向右滑动并发送pkt3，之后收到了ACK1因此继续向右滑动，并发送pkt0(新的分组)，但是之前的pkt3丢失了，此时收到pkt0，也是会缓存下来(因为期望的是pkt3)  

所以对于接收方来说，a，b场景最终导致自己的情况是先相同的，但是自己并不知道发送方到底发生了什么也就是a，b情况自己是不能区分的  

**问题在于** ： **序列号空间比较小(2位表示，只能用4个序列号)，但窗口尺寸比较大(N=3)**  

发送方和接收方序列号空间大小与窗口尺寸应该满足：    

**Ns + Nr <= 2^k**     

其中k表示序列号位数，即可用序列号为2^k   那么 发送方窗口尺寸Ns + 接收方窗口尺寸Nr 需要小于 总序列号个数2^k  



## 可靠数据传输原理与协议总结  

* 信道具有不可靠特性 (针对错误(比如位翻转)、丢失等要有不同措施)
* 可靠数据传输的需要  (不错、不乱、不丢)  
* rdt1.0
* rdt2.0、rdt2.1、rdt2.2
* rdt 3.0 （分析它的性能，发现不能采用停等协议，需要流水线）  
* 流水线与滑动窗口协议  
* GBN
* SR

**以上各协议，总结下每个协议解决了什么问题，又有什么缺陷**

















