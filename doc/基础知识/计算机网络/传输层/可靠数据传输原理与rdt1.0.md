# 可靠数据传输原理  

## 可靠  

* 不错 如分组在传输过程中有一位发生了错误，需要纠正过来
* 不丢 分组传输过程中发生了丢失
* 不乱 分组顺序不能乱  

## 可靠数据传输协议  

* 可靠数据传输对应用层、传输层、链路层都很重要  
* 网络Top-10问题  
* 信道的不可靠特性决定了可靠数据传输协议(rdt)的复杂性  


## 可靠数据传输协议(rdt)基本结构 ： 接口  

![image](https://user-images.githubusercontent.com/58176267/158301002-abfde68d-1730-4d6f-b110-5b3d7e5000a3.png)


rdt_send(): 被上层网络应用调用，将数据将给rdt以发送给对方  

udt_send(): 被rdt调用，在不可靠信道上向接收方传输数据 在Iternet上，这里的unreliable channel就是IP  

rdt_rcv() : 当分组到达接收方信道时被调用  

deliver_data() : 被接收方rdt调用，向上层应用交付数据  


### 注意：  
* 1. rdt_send()被应用单向调用一次， deliver_data() 是接收方rdt单向调用一次，  **也就是对于应用层来说，发送方应用只管把数据交给rdt剩下的就不管了，接收方应用只接收rdt处理好的数据，其余的事情不管**   
* 2. **rdt和不可靠信道之间的调用都是双向的**   


## rdt  

* 渐进地设计可靠数据传输协议的发送方和接收方
* 只考虑**单向数据传输**  
    * **但控制信息双向流动**   
* 利用状态机(Finite State Machine， FSM)刻画传输协议   

### 有限状态自动机  

![image](https://user-images.githubusercontent.com/58176267/158303554-938e93e1-407f-4cd5-8810-776f693afee8.png)


* 每一个圆圈表示一个状态
* 圆圈之间的箭头表示状态的变迁  
* 箭头上方  红线上面表示引起状态变迁的事件  红线下方表示状态转换过程中要采取的动作    
* 状态必须唯一确定  状态之间的变迁必须要明确，不能一个事件引起状态1既向状态2变迁又向状态3变迁  



# rdt1.0  可靠信道上的可靠数据传输  

* 底层信道完全可靠  
    * 不会发生错误(bit error) 
    * 不会丢失分组，乱序  
* 发送方和接收方的FSM独立 
* 由于发送方和接收方之间的信道是完全可靠的，发送方确信数据正确发送到接收方  两者之间不需要其他信息的交互 也就是不需要控制信息  因此发送方接收方状态相互独立  


![image](https://user-images.githubusercontent.com/58176267/158304785-cf62eb69-6b11-4fc9-82a1-188a150940e3.png)


## 发送方 有限状态自动机 FSM刻画  
 
**只有一个圆圈表示只有一个状态————等待上层应用调用**  
 
当发生调用事件时(rdt_send(data)) , 要采取一些活动：packet = make_pkt(data)创建一些分组  udt_send(packet)通过下层信道将分组发出去  由于确信分组会正确无误的发送到接收方所以不需要做其他的了，就 **“继续回到等待上层调用的状态”**
 
 
## 接收方 状态机  

* 一个状态：等待下层的调用(rdt_rev(packet)这个事件)、
* 等有这个事件发生时，进行活动： 从分组中提取数据，并交付给上层应用  (因为确信分组正确) 
* 活动完后，继续回到等待接收下层调用的状态  
 
 
 # rdt 2.0  产生位错误的信道  
 
 假设： 认为信道传输数据时只可能发生位错误  
 
 * 接收方收到数据，需要检查数据是否正确  
 * 如果是错误的数据，想办法纠正错误  因此，接收方可能要和发送方交互  


* 底层信道可能翻转分组中的位(bit)  
    * 利用**校验和**检测位错误  

* 如何从错误中恢复？  
    * **确认机制(Acknowledgements, ACK)** : 接收方显式地告知发送方分组已正确接收  
    * **NAK**(negtive ACK)： 接受方显示地告知发送方分组有错误  
    * 发送方收到NAK， **重传**分组  

* 基于这种重传机制的rdt协议称为 **ARQ(Automatic Repeat reQuest)协议**    Automatic Repeat reQuest 自动重复请求
 
 
## rdt2.0中引入的新机制  

* 差错检测  （如利用**校验和**）  
* **接收方反馈控制消息** ： ACK/NAK  
* **重传**  



## 怎样设计————利用FSM  

![image](https://user-images.githubusercontent.com/58176267/158388310-178e17d6-3c59-49c0-a53c-e9363902ea35.png)

### 发送方

* 发生方两个状态： 1.等待上层应用  2.等待ACK或NAK   **停——等协议**

* 发送方处于等待上层应用状态时，上层应用如果通过一个调用rdt_send事件触发了它，它会产生状态变迁，发生的活动是 利用data产生package，**注意，此时在产package时要加入checksum**，并调用udt_send将分组交给下层信道； 转换为等待ACK/NAK状态 (因为此时不知道刚才发送的数据，接收方有没有正确收到)  
* 等待ACK/NAK状态，如果收到对方发回的消息，若是NAK，需要重传，即重新调用udt_sned(); 重新发送完以后，仍然进入等待ACK/NAK状态  
* 只有当对方返回的控制消息且是AVK时，进行状态转换到等待上层调用状态，此时action为空，不需要进行操作  

## 接收方  

* 一个状态  等待下层调用的状态  
* 当下层有数据过来时(rdt_rcv(rcvpkt)), **执行动作： 判断收到的分组是否错误，如果有错误，反馈一个NAK控制消息，具体就是调用udt_send(NAK)** 
    * 可以看出udt_send()发送方可接收方都可以调用  
* 如果分组没有错误，从中提取数据，向上层交付，**并调用udt_send(ACK)**,告知发送方已经正确收到  


### rdt 2.0 总结  

* 针对的信道特性：可能发生位错误的信道
* 利用的机制  
    * 差错检测机制
    * 接收方显示确认机制(发送控制消息ACK或NAK) 
    * 重传机制


## rdt2.1  

### rst 2.0缺陷  

* 如果ACK/NAK消息发生错误/被破坏, rdt2.0处理不了?
    * 为ACK/NAK增加校验和，检错并纠错  
    * 发送方收到被破坏ACK/NAK时不知道接收方发生了什么，添加额外的控制消息？比如再次询问接收方刚才的消息是否正确收到，但额外的控制消息仍然可能被破坏  
    * 如果ACK/NAK坏掉，发送方重传  
    * 但是不能简单的重传，因为**会产生重复分组**  

* 解决重复分组问题  
    * **序列号(Sequence number)** : 发送方给每个分组增加序列号  
    * 接收方丢弃重复分组  
 
在rdt2.0基础上，增加序列号  

### rdt 2.1  发送方，应对ACK/NAK破坏  

![image](https://user-images.githubusercontent.com/58176267/158394531-542fdb3a-0e69-40af-83ac-00c589e1fe84.png)


* 发送方状态数翻倍  
* 发送方接收到上层调用时，制作package时将序列号加进去  如一开始将序列号0加入，之后转到等待ACK/NAK状态  
* 如果遇到所收到的确认消息ACK/NAK坏掉了的时候， 重传(udt_send)
* 只有收到一个没有坏掉的确认消息并且是ACK时，切换状态为等待上层调用状态**并改变序列号**   如从0变为1，再次收到上次调用制作分组时序列号设置为1    变为1以后也是对应两个状态，接下来过程与原来一样，序列号是来回切换的  



### rdt 2.1  接收方，应对ACK/NAK破坏  

![image](https://user-images.githubusercontent.com/58176267/158395192-69881fe1-9866-4874-b000-57f92b34e186.png)
 
 * 接收方状态变成了两个   假设初始时处于希望收到序列号为0的分组的状态
 * 图中最上面代表的情况：如果收到一个分组，分组没有错误并且自己期望的序列号是1且收到的分组序列号也是0，就从分组中提取数据向上层交付，发送ACK  
 * 图中左上角代表的情况，如果收到一个分组，分组坏掉了，与rdt2.0一样，调用udt_send发送一个NAK 
 * 图中左下情况，收到一个分组，分组没有坏掉，但是当前期望的是序列号为0的分组，但收到的是序列号为1的分组  此时需要发送ACK
    * 此时置之不理肯定不行发送方需要等待接受方的控制消息
    * 发送NAK，此时如果发送NAK，根据发送方的FSM，会认为接收方收到错误数据，进行重发，但重发时序列号不会改变仍然为1；
    * 发送ACK，发送方认为刚才序列号为1的消息被正确接收，会转变状态到等待上层调用且序列号为0  
* 另外因为需校验ACK/NAK消息是否发生错误，因此接收方制作控制信息时也要加入校验和，发送方收到控制消息


## rdt 2.1 总结  

* 发送方  
    * 为每个分组增加了序列号  
    * 两个序列号(0,1)就够用，因为采用的是停——等协议  一个序列号的分组发出去以后要等待，知道这个序列号的分组被正确接收才转换到下一个状态，切换序列号，分组被正确接收需要再次转换状态时，不需要序列号3，只需要循环回去即可
    * 需校验ACK/NAK消息是否发生错误，因此接收方制作控制信息时也要加入校验和  
    * 状态数据数量翻倍
        * 状态必须"记住""当前"的分组的序列号  

* 接收方  
    * 需要判断分组是否重复
        * 当前所处状态提供了期望收到分组的序列号  
    * 接收方无法知道ACK/NAK是否被发送方正确收到   



## rdt 2.2 无NAK消息协议  

* 有没可能取消掉NAK消息，较少程序处理逻辑  

* 在ACK消息中**显式地加入被确认分组的序列号**  **也就是告诉发送方，你现在确认了那个分组被正确接收**  
* 接收方通过ACK告知最后一个被正确接收的分组  
* 发送方收到重复ACK后，采取与收到NAK消息相同的动作  
   * 重传当前分组  

**例如： 发送方发送了一个序列号为1的分组，（rdt2.1中接收方要么发个ACK要么发个NAK），现在如果接收方发现数据坏掉了，发送ACK但是告诉发送方所确认的序列号是0(最后一次正确接收)； 发送方根据此消息发现自己发送的分组序列号是1但结束方收到的是0，说明这个消息没被正确收到，此时发送方收到重复ACK，采取与收到NAK一样的动作也就是重传**    

 
### rdt2.2 FSM片段  

* 如下图片段，假设发送方已经正确发送了序列号为1的分组(接收方也正确收到了)，此时发送方处于等待上层调用且序列号为0状态   接收方处于等待序列号0的分组的状态 收到edt
* 接收方受到上层调用，发送序列号为0的分组并进入等待ACK状态    接收方受到rdt_rev调用后，进行判断发现数据错误，此时发送udt_send时，ACK信息包含序列号为1，表示自己当前正确收到的分组是序列号为1的分组    如果判断后发现此时收到的分组序列号为1，但自己想要的是0的分组，也是发送相同的控制消息，即ACK中序列号为1(接收方会认为自己序列号为0的分组没有正确被收到，重传)  、
* 发送方如果收到ACK检查发现ACK破坏，会重发   如果发现ACK中序列号为1，此时认为接收方正确收到的是序列号为1的分组，于是重发  
* 接收方收到分组后如果检查序列号是自己想要的(0), 且数据没错误，就向上层交付，并发送ACK(序列号是0)  
* 发送方接收到ACK后，如果ACK中序列号是0表示自己现在想要发的分组和接收方正确收到的分组一致，就会转换状态  如果此时ACK破坏，(上面是接收方没收到，同时ACK被破坏，现在是接收方明明正确收到了，但ACK被破坏，也会重发);  但结束方状态已经改变，期望接收序列号为1的分组，此时发送方发送后接收方发现不一致，控制消息的ACK中序列号是0(正确接收后接收方状态已改变)，这个控制消息被发送方再次接收到时，就是到接收方已经正确收到序列号为0的消息，就会转换状态。。。。。。。。


经过仔细模拟多种情况可以发现，取消掉NAK并通过在ACK中设置已经正确的收到序列号的方式是可行的  

![image](https://user-images.githubusercontent.com/58176267/158401713-26c266eb-b5f1-47b5-a968-1b7ee9335478.png)  


## rdt3.0  



























