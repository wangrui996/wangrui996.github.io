# 0088.合并两个有序数组   
[力扣题目链接](https://leetcode-cn.com/problems/merge-sorted-array/)    


## 题目描述  

给你两个按 **非递减顺序** 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。  

请你 **合并** nums2 到 nums1 中，使合并后的数组同样按 **非递减顺序** 排列。    

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。    


**示例 1：**

    **输入**：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
    **输出**：[1,2,2,3,5,6]
    **解释**：需要合并 [1,2,3] 和 [2,5,6] 。
    合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

**示例 2：**

    输入：nums1 = [1], m = 1, nums2 = [], n = 0
    输出：[1]
    解释：需要合并 [1] 和 [] 。 
    合并结果是 [1] 。

**示例 3：**

    输入：nums1 = [0], m = 0, nums2 = [1], n = 1
    输出：[1]
    解释：需要合并的数组是 [] 和 [1] 。
    合并结果是 [1] 。
    注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。

**提示：**

    * nums1.length == m + n
    * nums2.length == n
    * 0 <= m, n <= 200
    * 1 <= m + n <= 200
    * -109 <= nums1[i], nums2[j] <= 109

**进阶**：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？  


## 思路分析  

1.直接将nums2元素放入到nums1中，然后排序，时间复杂度是O((m+n)log(m+n)),因此直接不考虑了先  

2.因为合并后数组也要按照**非递增顺序**排列，因此很容易想到新建一个数组，用两个指针分别从两个数组中最小元素开始比较，选择小的那个放入新数组，同时移动指针，当某个数组元素遍历完后，另一个数组剩余元素直接依次放入到新数组就可以了；但这种做法**空间复杂度是O(m+n)**  
其实可以原地操作的，只不过需要计算两个数组的元素个数总和然后扩容其中一个数组作为结果；     

对于这个题，明确说了要向nums1合并，而且看nums1的size已经等于m+n(后n个元素初始化为0) ，所以意思已经很明确了；但是有个问题就是如果我们直接**从左向右**比较，当**值小的那个是nums2数组中元素时，需要向nums1中插入，需要将nums1插入位置后面元素都先向后移动一位防止覆盖**，还不如用空间换时间呢。 

3.**那么能不能做到不覆盖呢?**,既然按照数组从左往右，谁小谁先插入的方法会存在需要额外移动数组元素的操作，那么**从右向左的顺序**呢？**这时只需要比较谁大，就把谁放到nums1的最后位置，这样就不再需要考虑会不会有元素被覆盖的问题**  

## 方法1 双指针 从右向左移动（逆向双指针）

至于nums1中元素永远不会被覆盖的证明： 假设nums1中指针p1指向当前要比较的元素，nums2中指针p2指向nums2当前要比较的元素，则：  
nums1数组中目前有m-p1-1个元素被放入了nums1后半部分，nums2中有n-p2-1个 元素 被放入了nums1后半部分； 此时nums1后半部分空余位置是 m+n-p1-1；  
      m+n-p1-1>= m-p1-1 + n-p2-1成立的条件是： p2>=-1; 永远成立

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m-1, p2 = n-1, p3 = m + n - 1;
        while(p1 >= 0 || p2 >= 0)
        {    
            if(p1 < 0)  
                nums1[p3--] = nums2[p2--];          
            else if(p2 < 0)
                nums1[p3--] = nums1[p1--];
            else if(nums1[p1] >= nums2[p2])
                nums1[p3--] = nums1[p1--];
            else   
                nums1[p3--] = nums2[p2--];
        }
    }
};
```
