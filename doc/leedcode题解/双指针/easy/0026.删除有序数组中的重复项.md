# 0026.删除有序数组中的重复项  

[力扣题目链接](https://leetcode-cn.com/problems/implement-queue-using-stacks/https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)  



## 题目描述  

给你一个有序数组 nums ，请你 原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。  

不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。    

 
**说明:**

为什么返回数值是整数，但输出的答案是数组呢?  

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。  

你可以想象内部操作如下:    

    // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
    int len = removeDuplicates(nums);

    // 在函数里修改输入数组对于调用者是可见的。
    // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
    for (int i = 0; i < len; i++) {
        print(nums[i]);
    }



**示例 1：**  

    输入：nums = [1,1,2]
    输出：2, nums = [1,2]
    解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

**示例 2：**  

    输入：nums = [0,0,1,1,1,2,2,3,3,4]
    输出：5, nums = [0,1,2,3,4]
    解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 

**提示：**  

    0 <= nums.length <= 3 * 104
    -104 <= nums[i] <= 104
    nums 已按升序排列

## 思路分析  

这个题如果不要求**原地修改**就没啥意思了  


**思路1：** 暴力解法  
* 遍历数组，如果当前元素与前一个元素相等，就将该元素后面元素向前移动，时间复杂度O(n^2)  

**思路2：** 双指针  

解决这种需要原地修改但复杂度太高的情况自己先想到的是能否用**双指针**  


## 方法1  
开始想的双指针是这么用的(但实际上是**三指针**) 
本步骤如下：
* 1.先用一个指针j指向要修改元素的位置，初始时指向整个数组的首元素  
* 2.对于每一组重复元素（也可以仅包含一个元素），用两个快慢指针，初始时两个指针p1,p2都指向一组重复元素的首元素；
,慢指针p1不动，快指针p2向后遍历，直到遇到不相等的元素时，区间[p1,p2)内就包含了一组重复元素    
* 3.将p1指向的元素放入到j指向位置（nums[j] = nums[p1]），j++, p1 = p2, 重复操作2

上面的操作直到快指针p2越界为止，但注意此时最后一组重复元素还没有执行步骤3  

由于每一次得到得到区间[p1,p2)内的元素至少有一个，所以执行步骤3时不会覆盖没有遍历到的元素  

时间复杂度：O(n)  

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n == 0)return 0;
        int p1 = 0, p2 = 0;
        int ans = n;
        int j = 0;
        while(p2 < n)
        {
            if(nums[p1] == nums[p2])
                p2++;
            else
            {
                nums[j++] = nums[p1];
                p1 = p2++;
            }
        }
        nums[j++] = nums[p1];
        return j;
    }
};
```

## 方法2 双指针     

上面的方法本来想用双指针的但成了三指针，其原因在于：上面的快慢指针其实可以省略一个，因为数组是有序的，**重复元素一定都在一块**；上面的方法中我用p2作为快指针逐一和p1指向元素比较是否相等，不相等时，为了获取刚才那一组重复元素的值，所以p1一直没有动，目的是可以执行nums[j] = nums[p1]；但实际上，一旦遇到nums[p2]!= nums[p2-1],直接nums[j] = nums[p2-1]就可以了  


直接上代码，下面代码中为了与上面的分析对应，两个指针一个用了j，一个是p2  

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n == 0)return 0;
        int j = 0, p2 = 1;
        while(p2 < n)
        {
            if(nums[p2] != nums[p2-1])
            {
                nums[j++] = nums[p2-1];
                p2++;
            }
            else
            {
                p2++;
            }
        }
        nums[j++] = nums[p2-1];
        return j;
    }
};
``` 

上面思路是p2指针每遍历到一个与 前面 元素不同的元素时，就将前面元素放入慢指针指向位置，导致最后还有考虑最后一组元素；如果**每次p2遇到新元素时，直接将新元素放入慢指针的位置**呢，这样最后一组元素是不需要额外考虑的，但是第一组重复元素就被漏了？我们知道，整个数组的首元素也就是nums[0]其实是不需要动的，那么j可以从索引1位置开始，快指针也从索引1开始，代码如下；  

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n == 0)return 0;
        int j = 1, p2 = 1;
        while(p2 < n)
        {
            if(nums[p2] != nums[p2-1])
            {
                nums[j++] = nums[p2];
            }          
            p2++;    
        }
        return j;
    }
};
```