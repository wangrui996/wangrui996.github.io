# 剑指offer 15.二进制中1的个数

[力扣题目链接](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)  


## 题目描述    

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。    



**提示：**  

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。  
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。  



**示例 1：**  

    输入：n = 11 (控制台输入 00000000000000000000000000001011)
    输出：3
    解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

**示例 2：**  

    输入：n = 128 (控制台输入 00000000000000000000000010000000)
    输出：1
    解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

**示例 3：**  

    输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
    输出：31
    解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。  

**提示：**

    输入必须是长度为 32 的 二进制串 。  


## 思路分析  

在之前做过的一道题目中已经用到过了，那就是[0461.汉明距离](https://github.com/wangrui996/leedcode/blob/master/%E4%BD%8D%E8%BF%90%E7%AE%97/easy/0461.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB.md)  

* 1.在计算两个整数汉明距离时，实际上就是比较的两整数对应的二进制数的不同位的个数，通过**按位异或**操作后，不相等的位置为1，其余为0，统计1的个数即可；所以该题统计1的个数只要利用**按位与**操作和**右移**操作即可完成  

**注意：**虽然右移1位和把这个整数除以2在数学上等价，但是**除法的效率要低很多**  


## 方法1 按位与+右移运算  

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while(n)
        {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
};
```

# 扩展 输入的为一个任意整数（剑指offer第二版——面试题15）  


## 思路分析    

上面的做法在输入的是无符号整数时没有问题，包括计算汉明距离那个题，题目都限制了数字为非负整数，但这里如果仅说是个整数的话，允许输入负数可能会带来一个问题：对负数右移后仍然会保持它是一个负数，这就导致程序**可能陷入死循环** 

**先补充小知识点：**  
    * 计算机中有符号整数是以补码方式表示的  
        * 正数的反码以及补码与原码相同
        * 最高位为符号位，正数为0，负数为1；  
        * 负数需要对除符号位以外的所有位取反得到反码，然后反码加1得到补码。
    
以8位有符号整型为例,32位同理：0000 0000表示0, 0111 1111表示+127， 1000 0001到1111 1111表示-1~-127，还有个1000 0000因为已经有0了这里不是-0，而是-128；  


好，假设现在输入的整数为n = -128(1000 0000),右移一位后如果是0100 0000就变成了+64，而我们知道-128除以2应该是-64，所以右移后变为1100 0000，这样问题就出来了右移一位还多了个1，如果继续右移就会发现最终变成了1111 1111，while循环如果移以n!=0为条件，就会陷入死循环  


换个思路，检测二进制数n中某一位是否是1，我们用一个二进制数b和它做按位与运算即可，这个b的要求是除了x中的要检测的那一位是1以外，其余位全为0；在这个题中，我们将1和n按位与操作，之后将1左移一位（变成0000 0010），再与n按位与，这时检测就是n中次低位是否为1了  

## 方法1 与运算+左移（对1左移）  

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        unsigned int flag = 1;
        while(flag)
        {
            if(n & flag)
                count++;
            flag <<= 1;
        }
        return count;   
    }
};
```  

## 方法2 优化时间  

上面的做法具有很高的通用性，不管n是正数还是负数都可以用，但是32位整数就需要将1左移32次，但这里面如果n有很多0的话，比如n = 0x8000 0000，前31次循环相当于都没什么用，能否优化一下?  


```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while(n)
        {
            //n不为0，说明n的二进制数中至少含有一个1，++count；
            ++count;
            //通过n与自身减1按位与，可以将n的二进制数中最右侧的1变为0，假设刚才加上的1就是这个1，接下来只需判断n是否为0即可，不为0就说明还有1
            n &= (n - 1);
        }
        return count;   
    }
};
```