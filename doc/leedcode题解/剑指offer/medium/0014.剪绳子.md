<p id="剪绳子"></p>

# 剑指offer 14.剪绳子    

[力扣题目链接](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

## 题目描述  

给你一根长度为 n 的绳子，请把绳子剪成**整数长度**的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。  

**示例 1：**

    输入: 2
    输出: 1
    解释: 2 = 1 + 1, 1 × 1 = 1

**示例 2:**

    输入: 10 
    输出: 36
    解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

**提示：**

    2 <= n <= 58

## 思路分析  

### 动态规划   

最优化问题(求最大最小值)一般可以通过动态规划解决  

### 1.状态的定义   

假设f(i)表示长度为i的绳子剪成若干段的最大乘积;  

### 2.推导转移方程  

* 长度为i的绳子，因为剪出来的绳子长度都是整数，最小是1，我们剪第一刀时可以有i-1种选择，将绳子长度分成(1, i-1),(2, i-2)....  
    * 对于第一刀切成(1, i-1)的情况，我们可以继续分成两类，一是后半部分不再继续切分，这样乘积就是 1 * (i-1); 第二是后半部分也切分，这样最大乘积就是 1 * f(i-1);所以这样切最终的乘积最大值应该是max(1 * (i-1), 1 * f(i-1));
    * 同理对于第一刀切成(k, i - k)的情况，最大乘积应该是max(k * (i-k), k * f(i-k));  
* 因此对于长度为i的绳子，要计算它切成m段后的最大乘积，需要用一个循环计算

**初始化**  
长度为2时，因为最少剪成2段且每段都为整数，此时只能剪成长度为1和1的两段，即f(2) = 1*1 = 1;
长度为3时，可以是1,1,1三段，也可以是1,2两段，因此f(3) = 2


```cpp
class Solution {
public:
    int cuttingRope(int n) {
        if(n < 2)
            return -1;
        if(n == 2)
            return 1;
        if(n == 3)
            return 2;

        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 1;
        dp[3] = 2;

        for(int i = 4; i <= n; ++i)
        {
            int maxDp = 0;
            for(int k = 1; k <= i/2; ++k)
            {
                int tmp = max(k * (i-k), k * dp[i-k]); 
                maxDp = tmp > maxDp ? tmp : maxDp;
            }
            dp[i] = maxDp;

        }
        return dp[n];

    }
};
```


###  动态规划思路2  


一段长度为i的绳子切成m段，最大乘积，理论上第一刀我们有i-1中切法；假设第一刀将绳子切成了k和i-k长度的两段绳子，那么很明显此时最大乘积应该是f(k) * f(i-k),由于k是从1到i-1的，所以f(i)等于(f(k) * f(i-k)中的最大值；但是绳子长度为4时我们切一下看看，当k是2时，如果直接等于f(2)*f(2),结果是1，但我们知道此时最大乘积是4，也就是切完这一刀不再继续切了；问题就出在这里，就是说i >= 4后，当k是2时，f(2)应该为2，因为再切只会更小，同理f(3)应该为3，所以：  

对于程序而言，应该先判断绳子长度:  
* 如果为1，没法切，返回-1；
* 长度为2，返回1，因为最少切一刀
* 长度为3，返回2；  

但初始化dp[1] = 1  dp[2] = 2  dp[3] = 3  

这样从i = 4开始，计算最大乘积时切分的最小块就是以2或3为结束的；比如i = 5；k从1到4分别是：  
* k = 1  f(1)*f(4) = 1 * 4 = 4  
* k = 2  f(2)*f(3) = 6 
* k = 3  f(3)*f(2) = 6 
* k = 4  f(4)*f(1) = 4 
因此f(5) = 6  

同时我们还发现，k取到i/2即可，后面都是重复的  


```cpp
class Solution {
public:
    int cuttingRope(int n) {
        if(n < 2)
            return -1;
        if(n == 2)
            return 1;
        if(n == 3)
            return 2;

        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;

        for(int i = 4; i <= n; ++i)
        {
            int maxDp = 0;
            for(int k = 1; k <= i/2; ++k)
            {
                int tmp = dp[k] * dp[i-k];
                maxDp = tmp > maxDp ? tmp : maxDp;
            }
            dp[i] = maxDp;
        }
        
        return dp[n];
    }
};
```




### 贪心  

 


