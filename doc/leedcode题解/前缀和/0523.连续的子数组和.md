<p id="连续的子数组和"></p>

# 0523. 连续的子数组和  


[力扣题目链接](https://leetcode.cn/problems/continuous-subarray-sum/)      


## 题目描述  

给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

* 子数组大小 **至少为 2**
* 子数组元素总和为 k 的倍数。
如果存在，返回 true ；否则，返回 false 。

如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。

 
**示例 1：**

    输入：nums = [23,2,4,6,7], k = 6
    输出：true
    解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。

**示例 2：**

    输入：nums = [23,2,6,4,7], k = 6
    输出：true
    解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
    42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。

**示例 3：**

    输入：nums = [23,2,6,4,7], k = 13
    输出：false
 

**提示：**

    1 <= nums.length <= 105
    0 <= nums[i] <= 109
    0 <= sum(nums[i]) <= 231 - 1
    1 <= k <= 231 - 1


## 方法1 前缀和

* 如果不限制子数组个数最少为2，那该题类似0974，可以计算能被k整除的子数组个数
* 该题要求了子数组元素最少为2，且让判断有无而不是个数；
* 分析一下，如果仍然采用974题的策略，计算前缀和并更新余数，记录到哈希表中key为余数，value为该余数出现的次数，当找到两个前缀和对k的余数相等时无法判断对应符合条件的子数组区间(元素个数)；
* 既然不需要统计子数组个数而是判断有无，哈希表的key为前缀和对k的余数，value为前缀和区间的最后一个元素下标  但是有可能有多个前缀和对k的余数相等，只需要记录最开始出现的那个也就是下标小的那个    当遍历到下标i时，计算对应区间[0,i]的前缀和并计算其对k的余数，在哈希表中查找是否有该key，有的话判断i与key对应的value差值是否大于等于2，是的话就直接返回true就好了，如果差值小于2，则直接continue，注意此时是不需要更新哈希表的。 如果哈希表中没找到，就记录到哈希表中


```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int count = 0;
        int preSum = 0;
        unordered_map<int, int> mp;
        // 针对preSum对k取余等于0的情况,也就是它本身就是k的倍数，此时实际上只需要[0, i]这个区间大于等于2就可以了，因此在哈希表中,应该对key等于0的情况初始化
        // 之前不要求子数组最少含有两个元素的，且求的是个数的情况下,可以初始化mp[0] = 1
        // 这里是判断有无,哈希表的value存的是出现这个key最早的下标，结合[1,1] k = 2这个例子来说，当i = 1时 [1,1]就满足题意,因此mp[0]应该初始化为-1,不能是0
        mp[0] = -1;
        for(int i = 0; i < nums.size(); ++i) {
            preSum += nums[i];
            int key = preSum % k;
            if( mp.find(key) != mp.end() ) {
                if(i - mp[key] < 2)
                    continue;
                return true;
            } 
            mp[key] = i;
        }
        return false;
    }
};
```