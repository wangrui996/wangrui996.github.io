<p id="整数除法"></p>

# 剑指offerII 001. 整数除法   

[力扣题目链接](https://leetcode-cn.com/problems/xoh6Oh/)    


## 题目描述  

给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。

**注意：**

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1
 

**示例 1：**

    输入：a = 15, b = 2
    输出：7
    解释：15/2 = truncate(7.5) = 7

**示例 2：**

    输入：a = 7, b = -3
    输出：-2
    解释：7/-3 = truncate(-2.33333..) = -2

**示例 3：**

    输入：a = 0, b = 1
    输出：0

**示例 4：**

    输入：a = 1, b = 1
    输出：1
 
**提示:**

    -231 <= a, b <= 231 - 1
    b != 0
 

## 方法1 二分(倍增除)  

```cpp
class Solution {
public:
    int limit = (INT_MIN >> 1);

    int divide(int a, int b) {
        if(a == INT_MIN && b == -1)
            return INT_MAX;
        if(a == 0)
            return 0;
        if(b == 1)
            return a;
        else if(b == -1)
            return -a;
        
        bool flag = true;
        if(a > 0) {
            a = -a;
            flag = !flag;
        }
        if(b > 0){
            b = -b;
            flag = !flag;
        }
        return flag ? div_fun(a, b) : -div_fun(a, b);
    }

private:

    int div_fun(int x, int y) {
	    int res = 0;
	    // 只要小于等于y 除的结果就大于等于1 循环继续
	    while (x <= y) {
		    int count = 1;
		    int tmp = y;

		    if (tmp < limit) {
			    x -= tmp;
			    res++;
			    continue;
		    }

		    while (x <= tmp) {
                if (tmp < limit || count < limit)
                    break;
                tmp += tmp;
                count <<= 1;
            }
            res += (count >> 1);
            x -= (tmp >> 1);		
        }
	    return res;
    }

};
```






* 该题难点在于 
    * 不能使用 除法，乘法，取模运算
    * 限制了机器只能用32位整型，即不能使用long 
    * 需要考虑溢出的问题  
    * 题目说了除数b = 0因此不需要特判

* 先分析溢出问题,发现 ：INT_MIN为被除数，-1为除数时才会溢出，其他情况不会溢出，因此这种情况直接特殊处理即可

* 一开始我考虑都取绝对值来计算，但是负数转正数可能会有溢出情况(**如果可以使用long类型，可以都转换为long类型再取绝对值就不会越界，但是针对该问题不行**)，因此，可以采用都转换为负数进行计算  

* 两个数相除, 结果一定是在一个区间范围内的,因此可以在这个区间用二分来计算,同时不能直接用乘法取模等,因此**需要用加法、位运算等实现快速乘法，可以使用——倍增乘法**  

* **倍增乘法**  
    * 假设乘数x = 16  y = 8  定义 x * y的结果为res，初始化res = 0;
    * 我们知道，计算乘法，可以用一个for循环的加法计算，比如循环16次每次加8; 或者循环8次每次加16; 这么做的问题在于，当两个数非常大时，循环次数过多
    * 我们以循环16次，每次加8为例来分析这个问题: 每次加8加的太少了，得加好久才能到16次，能不能每次加的多一点？比如每次加16？，每次加16那就循环8次，每次加32呢？循环4次; 但是我们一开始是没法确定到底加多少合适的；
    * 分析为什么循环16次，每次加8一定是加少了呢？ 16的2进制 10000 我们发现，这个x不为0，并且二进制最低位等于0，说明什么，说明x大于等于2！大于等于2不就意味着最少包含2个8吗(**实际上是2^n倍个8**)，那此时有必要加上8吗，此时加8相当于破坏了2^n个8的关系。 那这种情况我们不加8，而是将y >>= 1,也就是缩小两倍,这样的话y也要扩大两倍才能使结果不变;  **如果x的最低位是1，那说明x要么就等于1要么就是2^n个y再加上1个y**，此时可以将结果里面加上y，并不会破坏2^n倍这个关系
    
    * 以16和8的例子 第一次循环，x>0,然后x的最低位是0(10000)，不需要加8，因此,16 >> 1 得到8(1000) 8 << 1 得到16 
    * 第二次循环 x > 0,  最低位还是0，不需要加y(16)  x————>4（100） y————>32
    * 第三次循环 x > 0   最低位为0  不需要加32   x————>2（10） y——————> 64
    * 第四次循环 x > 0   最低位为0  不需要加64   x————>1（1） y——————> 128
    * 第五次循环 x > 0   最低位为1  需要加上y   res = 128  x————>0 y——————> 256
    * 此时x 为0，终止循环 
    * 可以发现，虽然加法避免不了，但每次加上的数都是倍增的，大大降低了循环次数  

**倍增算法模板**

* **注意，这里的写法只是用与两个数都为正的情况，因为负数位运算可能出问题，这个在计算一个数的二进制含有多少个1的问题中已经遇到过了**  
* 注意这里由于y的倍增可能会超过int边界，两个int相乘也可能越界，因此用了long型

* **正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。负数的右移，就是补码高位补1,然后按位取反加1即可。** 例如 -1 左移一位是-2; -1右移一位还是-1(不是0，因为最高位补的是1不是0)  



```cpp
long mul(long x, long y) {
    long sum = 0l;
    while(x > 0) {
        if((x & 1) == 1) {
            sum += y;
        }
        x >>= 1;
        y <<= 1;
    }
    return sum;
}
```


## 两个正数的快速除 

* 对于两个正整数的除法 x / y  当x大于等于y时进入循环  
    * 循环中，
    * 判断 x 与 y * 2^1大小，看x是否够y的2^1倍  再看x与 y * 2^2的大小，看x是否够 y * 2^2倍，直到找到一个k，使得 x大于等于 y * 2^k 但是 x 小于 y * 2^(k+1)  此时将结果加入 2^k  此时，将被除数x变为 x - y * 2^k  除数y不变  
    * 继续外循环，判断x是否大于等于y

* 例子：19 / 2  x = 19  y = 2
    * 第一次循环，定义临时变量int tmp = y; while循环更新tmp，19 > 2 * 2^1  ..... 19 > 2 * 2^3  19 < 2 * 2^4 = 24 置 x = x - tmp = x - 2 * 2^3 = 3   res += 2^3;
    * 第二次循环，tmp = 2   x > 2 * 2^1 不成立内循环退出 x = x - tmp = x - 2 = 1   y = 2  res += 1;
    * x = 1 < y = 2 循环结束  结果res = 9

* **注意：在循环中一直通过tmp和count的左移寻找那个k，是可能越界的，对正数而言，左移以后可能会超过INT_MAX，因此如果当前tmp或者count已经大于INT_MAX的一半，就退出循环**

```cpp
int limit = (INT_MAX >> 1);

int div_fun(int x, int y) {
	int res = 0;
	// 只要x大于等于y 除的结果就大于等于1 循环继续
	while (x >= y) {
		int count = 1;
		int tmp = y;

		while (x >= tmp) {
			if (tmp > limit || count > limit)
				break;
			tmp <<= 1;
			count <<= 1;
		}
		res += (count >> 1);
		x -= (tmp >> 1);
	}
	return res;
}

```


## 两个负数的快速除  

* 对于限制在int范围的任意两个数相除，如果都转换为正数可能会越界，但是所有正数转换为负数都不会越界，因此可以都用负数做除法，最后符号注意一下即可(如果允许使用long类型, 可以都转换为正整数使用上面的方法计算)

* 负数x / 负数y 与上面思路一致，区别在于，是当 x <= y 进入循环 
* 每次循环中，也是找 x含有y * 2^k，即找k  这里仍然除了越界判断条件不同，其他都一样，最后x也是减去(tmp >> 1)，因为(tmp >> 1)是个负数，相当于加上了一个正数

```cpp
int limit = (INT_MIN >> 1);

int div_fun(int x, int y) {
	int res = 0;
	// 只要小于等于y 除的结果就大于等于1 循环继续
	while (x <= y) {
		int count = 1;
		int tmp = y;

		if (tmp < limit) {
			x -= tmp;
			res++;
			continue;
		}
		while (x <= tmp) {
			if (tmp < limit || count < limit)
				break;
			tmp += tmp;  // 力扣上不支持 tmp << 1因为认为负数的左移是未定的操作
			count <<= 1;
		}
		res += (count >> 1);
		x -= (tmp >> 1);		
	}
	return res;
}
```
* 补充
* 对于int类型正数，超过INT_MAX / 2的正数如果左移1位会越界，最小的正整数1，右移1位等于0 
* 负数的左移右移也代表将其乘2或者除以2，但是需要注意下-1右移1位还是-1(防止死循环)，小于INT_MIN / 2的int型变量左移1位会越界  