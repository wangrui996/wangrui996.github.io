<p id="摆动序列"></p>

# 0376.摆动序列  

[力扣题目链接](https://leetcode-cn.com/problems/wiggle-subsequence/)        


## 题目描述   

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

* 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

* 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 **摆动序列** 的 **最长子序列的长度** 。

 
**示例 1：**

    输入：nums = [1,7,4,9,2,5]
    输出：6
    解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

**示例 2：**

    输入：nums = [1,17,5,10,13,15,10,5,16,8]
    输出：7
    解释：这个序列包含几个长度为 7 摆动序列。
    其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

**示例 3：**

    输入：nums = [1,2,3,4,5,6,7,8,9]
    输出：2
 

**提示：**

    1 <= nums.length <= 1000
    0 <= nums[i] <= 1000
 

## 方法1 贪心  

题目要求的**子序列**可以通过在原数组基础上删除某些元素（也可不删）来获取，剩下的元素保持原有顺序。  那么应该删除什么地方的元素？  

* 如果某元素的两侧元素都小于它，那么他就是一个**峰**
* 如果某元素的两侧元素都大于它，那么他就是一个**谷**  
* 既不是峰也不是谷的元素暂且称为**过渡元素**  

**贪心**：将过渡元素元素删除，尽可能多的留下(统计)峰或谷，最后整个序列拥有最多的峰和谷，从而达到最长摆动序列  

**贪心的证明**    

反证法：

* 假设遍历过程选择了某个过渡元素，则它两侧（不一定是紧挨着）一定有一个峰F和一个谷G  ；最后得到的序列中，该过渡元素必须满足：要么比它两侧的元素小，要么比它两侧的元素大；
* 如果过渡元素比它两侧元素小，那么原序列中过渡元素两侧的谷G，一定没有在序列中，那么选择了该过渡元素就肯定会丢掉G   反之，如果过渡元素比它两侧元素大，那么原序列中的F肯定被丢掉了
* **既然选择一个过渡元素总会丢掉它两侧的一个峰或者谷，那么干脆直接不选择过渡元素直接选择原序列的峰和谷**
* 即使峰和谷之间的过渡元素不止一个，这之间的过渡元素也只能选择一个，所以上面的情况仍然成立  

* 因此最终，只需要统计原序列中峰和谷的数量（不需要真正删除过渡元素）  
    * 需要注意相邻的重复元素要跳过
    * 两端的元素只要和它们的那一个相邻元素不相等，也算作峰或谷  

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if(n < 2) 
            return n;

        int res = 0;
        int preState = nums[1] - nums[0];
        
        res += preState != 0 ? 2 : 1;
        for (int i = 2; i < n; ++i) {
            int curState = nums[i] - nums[i-1];
            if (curState > 0 && preState <= 0 || curState < 0 && preState >= 0) {
                res++;
                preState = curState;
            }            
        }
        return res;

    }
};
```


## 方法2 动态规划  

### 定义状态

 

### 转移方程  

