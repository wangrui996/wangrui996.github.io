<p id="汉明距离"></p>

# 0461.汉明距离

**力扣hot100**

[力扣题目链接](https://leetcode-cn.com/problems/hamming-distance/)  


## 题目描述  

两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。  

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。  


**示例 1：**  

    输入：x = 1, y = 4
    输出：2
    解释：
    1   (0 0 0 1)
    4   (0 1 0 0)
           ↑   ↑
    上面的箭头指出了对应二进制位不同的位置。  

**示例 2：**   

    输入：x = 3, y = 1
    输出：1  

**提示：**

    0 <= x, y <= 231 - 1  


## 思路分析  

**写在前面**  
看到这个题目真是异常的亲切，因为在ORB特征匹配时就是对两个特征点的Brief描述子计算汉明距离，这个距离越小，就认为两个特征点越相似。当然官方题解也介绍了，在其它很多领域也都用到了汉明距离。  

根据题目描述可知该题特点非常明显，要计算的是两个数字（非负）对应的二进制位不同的位置数目。如果对C++运算符熟悉的话很容易想到按位异或运算符 ^  

[关于C++逻辑运算符及其妙用]()  

假设ans = x ^ y; 表示将x对应的二进制数与y对应的二进制数按位异或后对应的十进制数  
    例如：x = 3（0000 0011），y = 1（0000 0001）  ans = x ^ y = 0000 0010 = 2  

通过运算，ans对应的二进制数中，1的个数即我们要求的答案。  

**现在问题被转换成了如果求一个数对应的二进制中1的个数？**   

我们分两步解决这个问题：   

### 1.判断最低位是否为1
* 通过上面链接补充的知识，我们可以利用逻辑与&运算（按位），逻辑与有如下性质：  
    1.假设x为二进制0或1，则：
    * x & 0 = 0
    * x & 1 = x
    * 即x与0，等于0；x与1等于它自身；  
就是有个逻辑与运算的使用技巧就是我们可以利用0，将某个数的某些二进制位重置为0；利用1，保持某些位不变；  
* 所以我们来看如果将上面x和y按位异或的结果做如下运算，**res = ans & 1；** 由于1这个数对应的二进制数只有最低位是1，其他位为0，所以ans和1做按位与运算后，得到的二进制数除最低位外全为0，最低位要和1做与运算，结果等于自身。**也就是说如果ans的最低位是1，res就等于1；ans最低位是0，res就等于0；**  

### 2.移位运算  
先补充下面的知识点
[关于C++位运算符及其妙用]()  

通过第1步我们已经可以判断一个二进制数最低位是否为1，那么再结合右移操作符>>每次判断完后将最低位移除，这样每次都是判断最低位就可以；  

**那右移什么时候结束呢?**  
如果我们知道这个数对应的位数如32位可以直接设置循环次数，如果res为1，就把res+1；但实际上考虑优化一下时间的话不是每次都一定要将每一个都判断完的，如果右移（相等于除以2）以后发现ans为0了，那么接下来就没必要再计算了  

## 方法1 移位和逻辑与运算实现位计数  

时间复杂度：O(logC) 循环中每次对ans右移一位，相当于除以2，因此假设ans最大范围是C，时间复杂度是logC，本题是log(2^31) = 31;      
空间复杂度：O(1)  

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans = x ^ y, res = 0;
        while(ans)
        {
            res += ans & 1; //ans & 1返回1：表示ans最低位为1,；返回0表示ans最低位是0；
            ans >>= 1;  //ans右移一个后结果保存在ans中
        }
        return res;
    }
};
```  

## 方法2 使用内置计数函数

C++的__builtin_popcount(x)函数计算二进制表达中1的个数  
```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        return __builtin_popcount(x ^ y);
    }
};
```  

## 方法3 Brian Kernighan算法  



















