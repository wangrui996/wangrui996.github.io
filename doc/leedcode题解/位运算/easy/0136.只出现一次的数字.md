# 0053.只出现一次的数字

[力扣题目链接](https://leetcode-cn.com/problems/single-number/)   


## 题目描述  

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。  

**说明：**  

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？  

**示例 1:**  

    输入: [2,2,1]  
    输出: 1  
**示例 2:**  

    输入: [4,1,2,1,2]  
    输出: 4  


## 思路分析      

最暴力的解法是遍历每个元素，然后去找数组剩下的元素中有没有重复的，没有就返回，时间复杂度是O(N^2)，直接不考虑了  

咋降低一下复杂度呢，如果数组是个有序的是不是就省劲了，每遍历一个元素，只要判断它的下一个元素是否和它相等就可以了，时间复杂度O(nlgn)  

能不能用空间换时间呢？可以利用标准库的哈希集合（unordered_set）（或者unordered_map）去除重复元素，题目描述说除了一个元素只出现了一次外其余的均出现两次，**注意是刚好两次而不是两次及以上。**  
**步骤**：遍历数组，只要哈希集合中没有这个元素就放进去，已经有的就将它从哈希集合中删除，这样最后哈希集合中一定只有一个元素，就是要求的答案。 但是这样空间复杂度不满足题意，只是个思路。  

想进一步优化空间复杂度，达到题目要求的O(1),我就没有思路了，看了下题解才知道了下面的方法，就是**利用按位异或操作符** 

使用的是按位异或操作的性质，我们知道以下两个值0和1按位异或，结果为1（0001）
    0001
    0000
很容易就总结出一个性质，一个数与0进行按位异或，结果还是这个数；  
一个数与它自身进行按位异或，等于0  

**所以根据这个性质，结合题目中说了重复的数字只重复两次，因此如果遍历所有元素并依次按位异或操作，重复的元素就会被抵消。**  而且重复的元素不需要在数组中是紧挨着的，因为假设有一对重复元素被另外一对重复元素隔开了，但这两组运算后仍然为0；  

以题目示例为例：（这里只用一个字节表示，超出这个范围高位的运算同理）  
1. 2， 2， 1 即00000011，00000011，00000011
首先nums[0]与nums[1]按位异或结果：00000000

00000000与00000011按位异或结果：00000011（3）  

2. 4, 1, 2, 1, 2 即00000100，00000001，00000010, 00000001, 00000010
首先nums[0]与nums[1]按位异或结果：00000101（5）  

00000101与00000010按位异或结果：00000111（7）  
00000111与00000001按位异或结果：00000110（6）  
00000110与00000010按位异或结果：00000100（4）  
最后结果就是4  

## 按位异或运算性质  
上面说了这么多，实质上用了按位异或的两个性质：  
**1. n ^ n === 0 ， n ^ 0 === n**   
**2.异或运算遵循交换律 a ^ b ^ c === a ^ c ^ b === b ^ a ^ c**  


## 方法1 哈希集合

时间复杂度： O(N)   遍历数组
空间复杂度： O(N)   需要额外的哈希集合

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_set<int> ans;
        for(int tmp : nums)
        {
            if(ans.count(tmp))
                ans.erase(tmp);
            else 
                ans.insert(tmp);
        }
        return *ans.begin();
    }
};
```

## 方法2  按位异或   

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int n = nums.size();
        int ans = nums[0];
        for(int i = 1; i < n; ++i)
        {
            ans ^= nums[i];
        }
        return ans;
    }
};
```




