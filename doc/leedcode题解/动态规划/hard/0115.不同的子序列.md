<p id="不同的子序列"></p>

# 0115.不同的子序列  

[力扣题目链接](https://leetcode.cn/problems/distinct-subsequences/)    


## 题目描述   

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。


**示例 1：**

    输入：s = "rabbbit", t = "rabbit"
    输出：3
    解释：
    如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。


**示例 2：**

    输入：s = "babgbag", t = "bag"
    输出：5
    解释：
    如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 


**提示：**

    0 <= s.length, t.length <= 1000
    s 和 t 由英文字母组成  




## 方法1 dp  


* 状态定义： dp[i][j] 表示t中的子串[0, i - 1]在s的子串[0, j - 1]的子序列中出现的个数 
    * 为了方便描述，下面用 t[0, i - 1]表示t的一个子串   s[0, j - 1]表示s的一个子串  

* 转移方程：
    * dp[i][j] 的情况要看 t[i - 1]和s[j - 1]
    * t[i - 1] != s[j - 1] 这种情况比较简单，此时要想t[0, i - 1]是s[0, j - 1]的子序列，只有在s[0, j - 2]去找  
        * dp[i][j] = dp[i][j - 1]
    * t[i - 1] == s[j - 1]  两个子串最后一个字符相等时，不能直接dp[i][j] = dp[i - 1][j - 1] 因为这表示选择了最后一个字符匹配，但是并不是非要匹配最后一个字符，才能找到子序列； 此时有两种选择，一是就让这两个字符匹配，此时 dp[i][j] = dp[i - 1][j - 1]; 而是可以确定的不让这两个字符匹配，此时dp[i][j] = dp[i][j - 1]; 这两种情况是组合关系，因此 : dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];
        * 例如示例一：s = "rabbbit", t = "rabbit"   t[0, 2] 为 "rab"  s[0, 4]表示"rabbb"  求dp[3][5] 时 ，比较 t[2] == s[4] == 'b' 此时应该有两种选择，一是如果就让这两个字符匹配 dp[3][5] = dp[2][4]; 或者不让它们匹配 dp[3][5] = dp[3][4]  

* 初始化与遍历顺序：
    * 根据递推公式和状态的定义，i，j应从1开始遍历(实际上我们就是故意这么定义的)，当前状态依赖前一列上一行的状态，因此应该从左至右从上至下遍历  
    * dp[0][j] 表示 t中的空串，在s子串的子序列的个数  那s的任意一个子串，有没有空字符串这个子序列呢，把所有元素都不选就是，也就是s的任意一个子串(包括空串)中，出现空串这个子序列的个数都是1  dp[0][j] = 1
    * dp[i][0] 表示，t这个子串，在空串中子序列的个数，显然都是0 (除了dp[0][0],但是dp[0][0]上面已经初始化过了)
    * 代入到递推公式看对不对呢：t[0] == s[0]时   dp[1][1] = dp[1][0] + dp[0][0] = 0 + 1 = 1;  t[0] != s[0]时,dp[1][1] = dp[1][0] = 0  


* 注意这个题的数组类型，int型和long long 类型在执行dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];都有测试用例越界  因此改为了unsigned long long因为dp[i][j]最小是0  

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int n1 = s.size(), n2 = t.size();
        if(n1 < n2)
            return 0;
        
        vector<vector<unsigned long long>> dp(n2 + 1, vector<unsigned long long>(n1 + 1));

        for(int j = 0; j <= n1; ++j) {
            dp[0][j] = 1;
        }

        for(int i = 1; i <= n2; ++i) {
            for(int j = 1; j <= n1; ++j) {
                if(t[i - 1] == s[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }

        return dp[n2][n1];
    }
};
``
