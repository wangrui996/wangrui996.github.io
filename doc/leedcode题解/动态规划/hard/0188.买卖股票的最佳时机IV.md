<p id="买卖股票的最佳时机四"></p>

# 0188.买卖股票的最佳时机 IV  

[力扣题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)      

## 题目描述   

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 
**示例 1：**

    输入：k = 2, prices = [2,4,1]
    输出：2
    解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

**示例 2：**

    输入：k = 2, prices = [3,2,6,5,0,3]
    输出：7
    解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
        随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
 

**提示：**

    0 <= k <= 100
    0 <= prices.length <= 1000
    0 <= prices[i] <= 1000


## 方法1 动态规划  

* 与0123.买卖股票的最佳时机III类似，那题是最多交易两次，这里是最多交易k次

* 状态定义：dp[i][j] 表示第i天持股状态j情况下所得最大金额   最多交易两次，j范围是[0, 2 * 2 + 1]  最多交易k次，j范围是[0, 2 * k + 1]
    * dp[i][0]  第i天 表示不操作情况下所得最大金额
    * dp[i][1]  第i天 第一次持股
    * dp[i][2]  第i天 第一次不持股 
    * dp[i][3]  第i天 第二次持股
    * dp[i][4]  第i天 第二次不持股
    
    * dp[i][2 * k - 1] 第i天，第k次持股
    * dp[i][2 * k]  第i天，第k次不持股
    
    *发现，奇数的时候是持股，大于0的偶数就是不持股  


* 转移方程  
    * dp[i][0] 第i天没有操作，那么所获最高金额和前一天一样  dp[i][0] = dp[i - 1][0];
   
    * dp[i][1] 第i天在第一次持股状态下所得最高金额   两种情况 一是第i天买入，二是之前就持股  
        * 第i天买入，说明前一天没有操作，最高金额就是前一天所得最高金额，减去今天买入的钱 dp[i][1] = -price[i] + dp[i - 1][0] 
        * 第i - 1天就是第一次持股状态，当前灭有别的操作  dp[i][1] = dp[i - 1][1]
        * dp[i][1] = max(-prices[i] + dp[i - 1][0], dp[i - 1][1]);  

    * 对于 dp[i][2] 第i天在第一次不持股状态下所得最高金额  两种情况  一是第i天就第一次卖出了股票，一是第i - 1天就不持股  
        * 第i天第一次卖出股票情况，那么所得最高金额就是当前股价加上前一天，第一次持有股票下的所得最高金额 dp[i][2] = prices[i] + dp[i - 1][1]  
        * 第i - 1天就是第一次不持股状态，那么所得最高金额就是前一天第一次不持股所得最高金额  dp[i][2] = dp[i - 1][2]
        * dp[i][2] = max(prices[i] + dp[i - 1][1], dp[i - 1][2]);


    * 类比得到剩下的 
```cpp
for(int i = 0; i < prices.size(); ++i) {
    dp[i][0] = dp[i - 1][0];
    for(int j = 1; j <= 2 * k; ++j) {
        if(j % 2 == 1) {
            dp[i][j] = max(-prices[i] + dp[i - 1][j - 1], dp[i - 1][j]);
        } else {
            dp[i][j] = max(prices[i] + dp[i - 1][j - 1], dp[i - 1][j]);
        }
    }
}   
```

* 初始化  
    * dp[0][0] 第0天没有任何操作 dp[0][0] = 0;
    * 与之前类似，第0天第j次持股情况，不管是第几次持股，只能是当天买入的，都是-prices[0];
    * 第0天第j次不持股，所获最高金额一定是0  

```cpp
for(int j = 0; i <= 2 * k; ++k) {
    if(j % 2 == 0) {
        dp[0][j] = 0;
    } else {
        dp[0][j] = -prices[0];
    }
}
```

* 遍历顺序  顺序遍历  

* 最后收益最大，一定是不持股状态下，第k次不持股又一定比前面不持股所得最高金额要高(起码不会低)

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if(prices.size() <= 1)
            return 0;

        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for(int j = 0; j <= 2 * k; ++j) {
            if(j % 2 == 0) {
                dp[0][j] = 0;
            } else {
                dp[0][j] = -prices[0];
            }
        }

        for(int i = 1; i < prices.size(); ++i) {
            dp[i][0] = dp[i - 1][0];
            for(int j = 1; j <= 2 * k; ++j) {
                if(j % 2 == 1) {
                    dp[i][j] = max(-prices[i] + dp[i - 1][j - 1], dp[i - 1][j]);
                } else {
                    dp[i][j] = max(prices[i] + dp[i - 1][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[prices.size() - 1][2 * k];

    }
};
```


## 滚动数组  

* 略  



