<p id="最佳买卖股票时机含冷冻期"></p>

# 0309.最佳买卖股票时机含冷冻期

[力扣题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)    


## 题目描述   

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 
**示例 1:**

    输入: prices = [1,2,3,0,2]
    输出: 3 
    解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**示例 2:**

    输入: prices = [1]
    输出: 0

**提示：**

    1 <= prices.length <= 5000
    0 <= prices[i] <= 1000  




## 方法1 动态规划  

* 状态定义：dp[i][j] 表示第i天持股状态j情况下所得最大金额  
    * dp[i][0] 表示第i天 是冷冻期状态下所得最大金额
        * 注意此时说明前一天只能是卖出状态，因此之前没有冷冻期要求时，所谓不持股状态需要继续细分出来两种状态
    * dp[i][1] 表示第i天 持股状态下所得最大金额  
    * dp[i][2] 表示第i天 刚好卖出股票所得最大金额
    * dp[i][3] 表示第i天，保持不持股状态所得最大金额 注意这里的不持股状态指的是今天手里一定没有股票，不会卖出，也不会买入    


* **注意，由于有了一个所谓的冷冻期状态，它特殊在，它的前一天一定是，当前卖出股票状态，而不是保持卖出股票的状态，因此，如果和持股状态一样只有不持股状态，是无法推导冷冻期的转移方程的，因为冷冻期最高收益dp[i][0] = dp[i - 1][??] 这里的？？如果是不持股状态肯定不合适，因此这里把不持股分成两种状态**  


* 转移方程  
    * 对于 dp[i][0]  一定是第i - 1天是卖出股票状态，那所获金额与昨天是一样的， dp[i][0] = dp[i - 1][2]

    
    * 对于 dp[i][1] 两种情况 一是第i天买入，二是之前就持股  
        * 第i天买入,又分两种情况:(实际上就是看今天买入时，昨天可能是上面的哪些情况)
            * 一是昨天是冷冻期，今天买入 dp[i][1] = dp[i - 1][0] - prices[i]
            * 二是昨天不是冷冻期,但昨天是保持不持股状态  dp[i][1] = dp[i - 1][3] - prices[i]
            * 此时第i天买入的情况，dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][3] - prices[i]);
        * 第i-1天就是持股状态 dp[i][1] = dp[i - 1][1]
        * 因此，dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][0] - prices[i], dp[i - 1][3] - prices[i]));

    * 对于 dp[i][2]  第i天刚好卖出股票，那第i-1天一定是持股状态(可能昨天刚买也可能之前就持有，总之是dp[i - 1][1]),肯定不会是冷冻期，因为冷冻期是刚卖出后的一天  dp[i][2] = dp[i - 1][1] + prices[i]

    * 对于 dp[i][3] 第i天是保持不持股状态  
        * 有可能前一天是冷冻期 dp[i][3] = dp[i - 1][0]
        * 有可能前一天就是保持不持股状态 dp[i][3] = dp[i - 1][3]
        * 因此，dp[i][3] = max(dp[i - 1][0], dp[i - 1][3]);    

* 初始化  
    * dp[0][0] = 0; 第0天是冷冻期，肯定收益是0
    * dp[0][1] = -prices[0]  第0天持股状态，只能是当天买入
    * dp[0][2] = 0 第0天卖出最大金额 不可能没买入就卖出，但收益不会是负数，因此也是0
    * dp[0][3] = 0 与上面一样，也是0  

* 遍历顺序  顺序遍历  


* 返回值：最后一天分及中国情况，持股状态下收益一定不是最大的，那么最后一天是刚好卖出，保持不持股状态都有可能是最大收益，同时注意，最后一天是冷冻期也可能获得最大收益，还是那句话，不确定就从里面取个最大值  

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        vector<vector<int>> dp(prices.size(), vector<int>(4));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = 0;

        for(int i = 1; i < prices.size(); ++i) {
            dp[i][0] = dp[i - 1][2];
            dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][0] - prices[i], dp[i - 1][3] - prices[i]));
            dp[i][2] = dp[i - 1][1] + prices[i];
            dp[i][3] = max(dp[i - 1][0], dp[i - 1][3]); 
        }
        return max(dp[prices.size() - 1][0], max(dp[prices.size() - 1][2], dp[prices.size() - 1][3]));

    }
};
```



