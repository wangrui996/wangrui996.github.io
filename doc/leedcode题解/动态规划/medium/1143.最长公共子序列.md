<p id="最长公共子序列"></p>

# 1143.最长公共子序列    

[力扣题目链接](https://leetcode.cn/problems/longest-common-subsequence/)     


## 题目描述  

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。


**示例 1：**

    输入：text1 = "abcde", text2 = "ace" 
    输出：3  
    解释：最长公共子序列是 "ace" ，它的长度为 3 。

**示例 2：**

    输入：text1 = "abc", text2 = "abc"
    输出：3
    解释：最长公共子序列是 "abc" ，它的长度为 3 。

**示例 3：**

    输入：text1 = "abc", text2 = "def"
    输出：0
    解释：两个字符串没有公共子序列，返回 0 。
 

**提示：**

    1 <= text1.length, text2.length <= 1000
    text1 和 text2 仅由小写英文字符组成。



## 方法1 dp  

* 状态定义：dp[i][j] 表示text1中区间[0, i -1]的子串和text2中区间[0, j - 1]的子串，最长公共子序列的长度  
    * 注意在0718题最长重复子数组中，dp[i][j] 表示以**nums1[i - 1]**结尾 和以 **nums2[j - 1]**结尾构成的最长公共子数组的**长度**  
    * 而这里dp[i][j]并不一定指以i-1结尾或者j-1结尾，那样的话转移方程很复杂，因为这种状态的话 当text1[i - 1] == text2[j - 1]时，dp[i][j] 并不一定等于 dp[i - 1][j - 1] + 1  仔细想想是不是  

* 转移方程  
    * dp[i][j]的状态，需要比较text1[i - 1]和text2[j - 1]
    * 如果 text1[i - 1] == text2[j - 1]  说明两个子字符串的最后一位相等 所以最长公共子序列又增加了 1
        * dp[i][j] = dp[i - 1][j - 1] + 1;  也就是text1的区间[0, i -2]的子串和text2区间[0, j -2]的子串的最长公共子序列的长度 加1 
        * 这里text1的区间[0, i -2]的子串和text2区间[0, j -2]的子串的最长公共子序列，并不一定以i - 2或者j - 2结尾
        * 比如ac和bc 它们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。 也就是dp[2][2] = dp[1][1] + 1 = 0 + 1 
    * 如果 text1[i - 1] != text2[j - 1]  不相等  如果题目是连续子数组，那次是 dp[i][j]是0 但是这里是子序列
        * 求区间text1的[0, i - 1]和text2的[0, j - 1]的子串的最长公共子序列，既然两个子串的最后一个字符不相等，那就只能去看下text1的[0, i - 2]的子串和text2的区间[0, j - 1]的子串的最长公共子序列的长度 或者 text1的[0, i - 1]的子串和text2的区间[0, j - 2]的子串的最长公共子序列的长度 两者取大的即可  因为此时，所以范围比这两个小的任意两个子串，都包含在了这其中

        * dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        * 比如 ace 和 bc  求dp[3][2] 时 由于 text1[2] != text2[1]  dp[3][2] = max(dp[3][1], dp[2][2]) = max(0, 1) = 1; // ace 和 b   ac 和 bc


* 初始化
    * dp[0][j] 和 dp[i][0] 都是没有意义的，但是初始化为多少呢  
    * 这两个分别表示，text1中的空串和 text2区间[0, j - 1]的子串的最长公共子序列长度 和 text1区间[0, i - 1]的子串和text2的空串的最长公共子序列长度  显然是 0 
    *  text1[i - 1] == text2[j - 1]时  dp[i][j] = dp[i - 1][j - 1] + 1;  对于dp[1][1] ， dp[1][1] = dp[0][0] + 1 = 1    dp[1][j] = dp[0][j - 1] + 1  = 0 + 1 = 1 没问题 
    *  text1[i - 1] != text2[j - 1]时  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);   dp[1][1] = max(dp[0][1], dp[1][0]) = 0;    dp[i][1] = max(dp[i- 1][1], dp[i][0]) = dp[i- 1][1]; 没问题  


* 遍历顺序  
    * 看转移方程，当前dp[i][j]依赖于dp[i-1][j-1] dp[i][j-1].dp[i-1][j] 因此顺序遍历
    * 另外，由于初始化dp[0][j]和 dp[i][0]都为0，数组定义时已经初始化为0，所以遍历时可以从i，j = 1开始  


* 不太好优化成滚动数组的形式


```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size(), n2 = text2.size();
        int maxLength = 0;
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1));

        for(int i = 1; i <= n1; ++i) {
            for(int j = 1; j <= n2; ++j) {
                if(text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
                maxLength = maxLength > dp[i][j] ? maxLength : dp[i][j];
            }      
        }
        
        return maxLength;
    }
};
```

