# 0139.单词拆分


[力扣题目链接](https://leetcode.cn/problems/word-break/)  



## 题目分析  

* 单词能用单词表中的单词拼接而成，意味着该单词能够分成几份，分别对应着单词表中的单词  

## 方法1 dfs 回溯  

* 最暴力的方法, 直接拆分单词的所有可能, 如 “leedcode” 设置指针初始时指向l, 取该指针左侧的部分为一个单词   递归的第一层，也就是树形结构的第一层，可以循环遍历整个单词，即“l”,"le"...“leedcode”
* 对于当前层选出的单词subStr,判断是否在单词表,如果不在这一分支就没必要继续了，如果在，那么将递归后半部分  如示例1：
* "leedcode"， 第一层一直到“leed”找到在单词表, 然后下一层看单词"code"能否用单词表中的单词拼接成，那做法和第一层一样 将其拆分成"c"、“co”、“cod”和“code”看
* 递归返回值为bool型变量

* 35 / 45 个通过测试用例  超时了  

```cpp
class Solution {
public:
    
    bool dfs(string s, int start, const unordered_set<string>& wordDictSet) {
        if(start >= s.size())
            return true;

        for(int i = start; i < s.size(); ++i) {
            string sub = s.substr(start, i + 1 - start);
            if(wordDictSet.find(sub) != wordDictSet.end()) {
                // 如果 i及以前的左半部分子字符串能找到，那就递归的看右半部分能否被拼接成，可以的话就返回true，注意如果如果不可以，不是返回false而是继续for循环看其他分支
                // 只有当for循环结束，说明i遍历过程中左半部分字串都没有找到，或者找到了但右半部分无法被拆分 
                bool flag = dfs(s, i + 1, wordDictSet);
                if(flag)
                    return true;
            }
        }
        return false;
    }
    
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordDictSet(wordDict.begin(), wordDict.end());
        return dfs(s, 0, wordDictSet);
    }
};
```  

