<p id="最长回文子序列"></p>

# 0516.最长回文子序列    

[力扣题目链接](https://leetcode.cn/problems/longest-palindromic-subsequence/)  


## 题目描述  

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 
**示例 1：**

    输入：s = "bbbab"
    输出：4
    解释：一个可能的最长回文子序列为 "bbbb" 。

**示例 2：**    

    输入：s = "cbbd"
    输出：2
    解释：一个可能的最长回文子序列为 "bb" 。
 

**提示：**

    1 <= s.length <= 1000  
    s 仅由小写英文字母组成  


## 方法1 动态规划  

* 注意与647题回文子串数量的区别，如果这里是问最长的回文子串长度(力扣第五题)，我们仍可以采用中心扩展法，只不过同时维护一个最大长度即可  这里问的是子序列  

* 状态定义：dp[i][j]：区间[i, j]范围的最长回文子序列的长度  

* 转移方程：
    * 关键逻辑在于看 s[i] 与 s[j] 是否相等  
    * 1.如果 s[i] == s[j]  那一定是要把它们作为这个区间选出的最长子序列的左右端点，只有这样得到的才是最长的 dp[i][j] = dp[i + 1][j - 1] + 2  
    * 2.如果 s[i] != s[j]  本着尽量不浪费它们的原则，既然它们不相等，最后选出的最长子序列，肯定不能都留着，考虑只留一个  
        * 如果留着s[i], dp[i][j] = dp[i][j - 1]  注意这里没有加1或者加2  
        * 如果留着s[j], dp[i][j] = dp[i + 1][j]
        * 因此，dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])


* 初始化与遍历顺序
    * 看递推公式，假设i为行，j为列  计算dp[i][j]时，有可能需要下一行 前一列的数据，因此按照从下向上，从左至右遍历即可  
    * 最后我们要求的结果即为dp[0][s.size() - 1]，在求dp[i, j]时，根据定义，当i > j 时是无意义的，因此画出二维矩阵来看的话，只有右上角的上三角区域有意义，外层循环从s.size() - 1开始到0，内层循环j如果从i开始，dp[i][j]还是会用到无意义的数据，因此，j可以从i+1开始，然后矩形的对角线上元素，也就是i == j时，区间内的最长回文子序列长度就是1，初始化为1即可  
   
```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for(int i = 0; i < n; ++i) {
            dp[i][i] = 1;
        }

        for(int i = n - 1; i >= 0; --i) {
            for(int j = i + 1; j < n; ++j) {
                if(s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }

        return dp[0][n - 1];
    }
};
```

