<p id="不相交的线"></p>

# 1035.不相交的线    

[力扣题目链接](https://leetcode.cn/problems/uncrossed-lines/)       


## 题目描述  

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。



## 方法1 动态规划  

* 本题与1143.最长公共子序列一样  不相交可不就是子序列吗  

* 状态定义 ： dp[i][j] 表示 nums1中[0, i -1]的区间和nums2中[0, j - 1]的区间的最大不相交的连接数  
    * 至于为什么定义成是右开区间，其实为了方便写代码 一开始可以不在意这个，先写递推公式  


* 递推公式  
    * 当 nums1[i - 1] == nums2[j - 1] 时，最长不相交连线肯定增加一条，dp[i][j] = dp[i - 1][j - 1] + 1;
    * 当 nums1[i - 1] != nums2[j - 1] 时  那两个区间中最后一个元素既然组不成一条连线，那就没必要包含了，可以去掉任意一个数字，看剩下的区间的最大连线数，这里有两个选择，取最大值即可   dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);


* 初始化
    * 这里就涉及到上面的状态定义了，在双重for循环中写出了递推公式以后，如果按照右闭区间，也就是 dp[0][0] 表示nums1中[0, 0]和nums2中[0, 0]，也就是比较第一个元素，看递推公式此时会出现dp[-1][-1]  实际上当dp[i][0] 或者 dp[0][j] 都有类似情况，所以循环需要从i = 1 和 j = 1开始， 但是按照右闭区间，等于1的时候，nums1或者nums2已经包含了两个元素，那就需要额外对等于0的情况进行初始化！想想是不是，比如先写一个i = 0，j从0到n2 - 1的循环初始化 dp[0][j] 同样一个循环 初始化dp[i][0]. 初始化的值，不一定都是0，因此要写逻辑判断的
    * 而按照我们上面的状态定义  i，j同样从1开始循环，dp[1][1]表示[0, 1)这个区间的值也就是第一个元素，此时dp[0][j] 或者 dp[i][0]都初始化为0即可，因为此时表示nums1中不选元素，或者nums2中不选元素，当然是0  再代入到递推公式发现也是正确的 比如 dp[1][1] = dp[0][0] + 1 = 1   


```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size(), n2 = nums2.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1));
        
        for(int i = 1; i <= n1; ++i) {
            for(int j = 1; j <= n2; ++j) {
                if(nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[n1][n2];

    }
};
```