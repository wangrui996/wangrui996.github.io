<p id="爬楼梯"></p>

# 0070.爬楼梯  

[力扣题目链接](https://leetcode-cn.com/problems/climbing-stairs/)  

## 题目描述  
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。  
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？    

注意：给定 n 是一个正整数。  

示例 1：

    输入： 2
    输出： 2
    解释： 有两种方法可以爬到楼顶。
    1.  1 阶 + 1 阶
    2.  2 阶
示例 2：

    输入： 3
    输出： 3
    解释： 有三种方法可以爬到楼顶。
    1.  1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 2 阶
    3.  2 阶 + 1 阶

## 思路分析  
该题一看用什么遍历的思想就无从下手，属于动态规划中典型的计数问题  

### 1.确定状态
* 最后一步    
不管前面怎么走的，有多少种走法，最后一步一定是走了1个台阶或2个台阶走完

* 转换成子问题     
由最后一步可以推出    
爬n阶台阶全部的不同走法 = 爬n-1阶台阶全部的不同走法 + 爬n-2阶台阶全部的不同走法(这里实际上用了加法原理，爬n-1阶台阶全部的不同走法，都是再走一阶就可以到n阶，所以通过这种方式走到n阶的方式数就等于爬n-1阶台阶方式数，注意不要再+1)
原问题:n阶台阶有多少种不同走法  

子问题成了：  
n-1阶台阶有多少种不同走法和n-2阶台阶有多少种不同走法  
缩小了问题规模

* 状态：设f[i]表示i阶台阶有f[i]中不同走法，

### 2.转移方程  
对于任意给定的台阶数i，有f[i]中不同方式爬完 
    f[i] = f[i-1] + f[i-2]


### 3.初始条件与边界条件   
作为数组索引时i-1和i-2小于0怎么办?
什么时候停下来?

* 边界条件——解决第一个问题
    * 如果没有任何方式能爬到k阶台阶，就可以定义f[k] = 0; 如f[-1] = f[-2] = 0;(所以这里就代表了程序中要有个判断，索引小于0时，返回0就好)    

* 初始条件  
用转移方程算不出来的，但我又需要它的定义，如f[0] = f[-1] + f[-2] = 0;
f[1] = f[0] + f[-1] = 0； 但我们知道f[1] = 1,f[0] = 1;所以需要手动定义  
    f[0] = 1；//第0阶台阶可以认为只有一种方式到达  
    f[1] = 1; //1阶台阶只有1种方式爬完  
    （验证一下f[1] = f[0] + f[-1] = 1 + 0 = 1;是满足的，f[2] = f[1] + f[0] = 2;满足；f[3] = f[2] + f[1] = 2 + 1 = 3）

### 4.计算顺序  

计算f[1],f[2],f[3],,,,,f[i]  
保证了计算f[i]时，f[i-1]与f[i-2]都已经计算过了  

时间复杂度: O(n) 
空间复杂度: O(n)

## 方法1 动态规划

```cpp
class Solution{
public:
    int climbStairs(int n){
        int f[n+1];
        int i;
        //初始条件
        f[0] = 1;
        f[1] = 1;
        for(i = 0; i <= n; ++i)
        {
            if(i == 0 || i == 1)continue;
            f[i] = f[i-1] + f[i-2];

        }
        return f[n];
    }
};
```


## 方法2 动态规划 + 滚动数组  
这个题还可以优化一下空间复杂度，因为f[i] = f[i-1] + f[i-2]，也就是说当前状态至于它前两个状态有关，那我们实时维护三个变量就可以了

```cpp
class Solution{
public:
    int climbStairs(int n){      
        int p, q;
        //初始条件
        p = 1;
        q = 1;
        int m = 1;
        for(int i = 2; i <= n; ++i)
        {
            m = p + q;
            p = q;
            q = m;
        }
        return m;
    }
};
```  


## 关于初始化的思考  
在上面代码和思考中，是将f[0]初始化成了1，看了Carl哥的在B站的讲解视频后受到了一些启发：就是我们每次做初始化时，都应该理解f[i]及其下标i代表的含义，在这个基础上，去发现递推公式中无法直接求的那一个或几个状态   
比如这个题，题目明确说了n是个正整数，所以f[0],到达第0阶台阶有几种方式本身就没有意义，但我们知道f[1] = 1.f[2] = 1;所以初始化可以写这两个，然后遍历时直接从i=3开始求


## 扩展一下  
还是n阶台阶，如果每次可以走1步，2步，3步，，，，m步，总共有几种走法呢?  
可以借鉴完全背包问题的思路？  



