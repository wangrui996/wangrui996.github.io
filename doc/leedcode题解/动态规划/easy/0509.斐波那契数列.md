<p id="斐波那契数列"></p>

# 0509.斐波那契数列  

[力扣题目链接](https://leetcode-cn.com/problems/fibonacci-number/)  

## 题目描述  
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：  

    F(0) = 0，F(1) = 1
    F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给你 n ，请计算 F(n) 。  

示例 1：

    输入：2
    输出：1
    解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：

    输入：3
    输出：2
    解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：

    输入：4
    输出：3
    解释：F(4) = F(3) + F(2) = 2 + 1 = 3
 

提示：

    0 <= n <= 30

easy题，为了练习动态规划，用动态规划思路求解问题  

## 解题步骤
1.确定状态  
最后一步，求dp[i]最后一步一定是将dp[i-1] + dp[i-2];
由此就转换成了子问题，求dp[i-1]和dp[i-2]

  
2.递推方程/转移方程  
对这个简单题来说，题目中已经给出了递推公式。  
dp[i] = dp[i-1] + dp[i-2]；

3.初始条件与边界条件  
边界问题：i-1与i-2小于0怎么办
初始条件：dp[0]和dp[1]都没法用递推公式求得，所以应该初始化，题目已经直接给出了  
dp[0] = 0； dp[1] = 1;  

4.遍历顺序  
这题很明显是从前向后遍历  

## 方法1 动态规划
```cpp
class Solution {
public:
    int fib(int N) {
        vector<int> dp(N+1);
        //初始化
        if(N == 0 || N == 1)return N;
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= N; ++i)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[N];
    }
};
```


## 方法2 动态规划 + 有限变量代替数组  进行压缩状态

```cpp
class Solution {
public:
    int fib(int N) {
        int p, q, r;
        if(N == 0 || N == 1)return N;
        p = 0;
        q = 1;
        for(int i = 2; i <= N; ++i)
        {
            r = p + q;
            p = q;
            q = r;
        }      
        return r;
    }
};
```


