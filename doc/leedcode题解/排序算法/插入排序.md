# 插入排序算法  


## 思路  

对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入  

假设是升序排列，从后向前找，比当前元素小就继续向前找，同时需要将当前元素向后移动； 比当前元素大就放在它后面


**类似打牌时摸到一张牌给插到对应位置**  


```cpp
//　３　插入排序
void InsertSort1(vector<int>& nums)
{
	int n = nums.size();
	if (n <= 1)
		return;

	int tmp;
	int i;
	int j;

	for (i = 1; i < n; ++i)
	{
		tmp = nums[i];
		for (j = i - 1; j >= 0; --j)
		{
			if (nums[j] <= tmp)break;
			//nums[j]比tmp大，说明tmp应该在nums[j]前面，将nums[j]向后挪一位
			nums[j + 1] = nums[j];
		}
		nums[j + 1] = tmp;
	}
}
```


## 插入排序优化  

上面插入排序的不足很明显：
* 1 每遍历到一个新的元素nums[i],寻找它的插入位置时需要从已排序好的元素从后向前逐个遍历(如果nums[i]是序列中最小值，需要遍历到最前面才知道)  
* 2 需要频繁的移动元素  

### 优化方案  

* 1 搜索插入位置时采用二分查找  
* 2 携带多个元素 如将nums[i], nums[i+1], nums[i+2]排序后一起找
* 3 数据链表化 如要排序的是个结构体数组而不单是一个整数数组  
* 4 希尔排序  


